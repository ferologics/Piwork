#!/usr/bin/env bash
#MISE description="Build VM runtime pack (kernel, initramfs with node+pi)"
#MISE sources=["mise-tasks/runtime-build", "runtime/taskd.js"]
#MISE outputs=["tmp/build/boot/initramfs-virt-fast"]
set -euo pipefail

ROOT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)
TMP_DIR="$ROOT_DIR/tmp"
BUILD_DIR="$TMP_DIR/build"
DOWNLOADS_DIR="$TMP_DIR/downloads"
ALPINE_VERSION="3.23.3"
ALPINE_ISO="$DOWNLOADS_DIR/alpine-virt-${ALPINE_VERSION}-aarch64.iso"
ALPINE_MIRROR="https://dl-cdn.alpinelinux.org/alpine"

# Output paths
BOOT_DIR="$BUILD_DIR/boot"
KERNEL="$BOOT_DIR/vmlinuz-virt"
INITRAMFS_ORIG="$BOOT_DIR/initramfs-virt"
INITRAMFS_FAST="$BOOT_DIR/initramfs-virt-fast"
INITRAMFS_DIR="$BUILD_DIR/initramfs-fast"

# Node/pi paths
NODE_DIR="$BUILD_DIR/runtime-node"
PI_DIR="$BUILD_DIR/runtime-pi"
KMOD_DIR="$BUILD_DIR/runtime-kmods"

# Runtime install location
if [[ "$(uname -s)" == "Darwin" ]]; then
    RUNTIME_DIR="$HOME/Library/Application Support/com.pi.work/runtime"
else
    RUNTIME_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/piwork/runtime"
fi

RPC_PORT=19384

echo "=== Building Piwork runtime ==="

#
# 1. Download Alpine ISO if missing
#
if [[ ! -f "$ALPINE_ISO" ]]; then
    echo "[1/6] Downloading Alpine ISO..."
    mkdir -p "$DOWNLOADS_DIR"
    curl -L "$ALPINE_MIRROR/v${ALPINE_VERSION%.*}/releases/aarch64/alpine-virt-${ALPINE_VERSION}-aarch64.iso" -o "$ALPINE_ISO"
else
    echo "[1/6] Alpine ISO exists"
fi

#
# 2. Extract kernel + initramfs from ISO
#
if [[ ! -f "$KERNEL" || ! -f "$INITRAMFS_ORIG" ]]; then
    echo "[2/6] Extracting kernel from ISO..."
    mkdir -p "$BOOT_DIR"
    bsdtar -xf "$ALPINE_ISO" -C "$BOOT_DIR" boot/vmlinuz-virt boot/initramfs-virt 2>/dev/null || true
    mv "$BOOT_DIR/boot/"* "$BOOT_DIR/" 2>/dev/null || true
    rmdir "$BOOT_DIR/boot" 2>/dev/null || true
else
    echo "[2/6] Kernel exists"
fi

#
# 3. Download Node.js + deps from Alpine packages
#
if [[ ! -f "$NODE_DIR/usr/bin/node" ]]; then
    echo "[3/6] Downloading Node.js + dependencies..."
    rm -rf "$NODE_DIR"
    mkdir -p "$NODE_DIR" "$BUILD_DIR/apk-cache"
    
    PACKAGES=(
        "main/nodejs" "main/ada-libs" "main/brotli-libs" "main/c-ares"
        "main/icu-libs" "main/icu-data-en" "main/libgcc" "main/libstdc++"
        "main/nghttp2-libs" "main/sqlite-libs" "main/zlib" "main/zstd-libs"
        "main/libcrypto3" "main/libssl3" "main/simdjson" "main/simdutf"
        "main/ca-certificates-bundle"
    )
    
    for pkg_path in "${PACKAGES[@]}"; do
        repo="${pkg_path%%/*}"
        pkg="${pkg_path##*/}"
        
        # Get version from APKINDEX
        version=$(curl -sL "$ALPINE_MIRROR/v${ALPINE_VERSION%.*}/$repo/aarch64/APKINDEX.tar.gz" \
            | tar -xzO APKINDEX 2>/dev/null \
            | grep -A1 "^P:${pkg}$" | grep "^V:" | cut -d: -f2 | head -1)
        
        [[ -z "$version" ]] && continue
        
        apk_file="${pkg}-${version}.apk"
        apk_path="$BUILD_DIR/apk-cache/$apk_file"
        
        [[ ! -f "$apk_path" ]] && curl -sL "$ALPINE_MIRROR/v${ALPINE_VERSION%.*}/$repo/aarch64/$apk_file" -o "$apk_path"
        tar -xf "$apk_path" -C "$NODE_DIR" 2>/dev/null || true
    done
    
    rm -f "$NODE_DIR"/.PKGINFO "$NODE_DIR"/.SIGN.* 2>/dev/null || true
    echo "  Node $(cat "$NODE_DIR/usr/lib/node_modules/npm/package.json" 2>/dev/null | grep version | head -1 || echo "installed")"
else
    echo "[3/6] Node.js exists"
fi

#
# 3b. Prepare 9p kernel modules from linux-virt package
#
echo "[3b/6] Preparing 9p kernel modules..."
rm -rf "$KMOD_DIR"
mkdir -p "$KMOD_DIR" "$BUILD_DIR/apk-cache"

LINUX_VIRT_VERSION=$(curl -sL "$ALPINE_MIRROR/v${ALPINE_VERSION%.*}/main/aarch64/APKINDEX.tar.gz" \
    | tar -xzO APKINDEX 2>/dev/null \
    | grep -A1 "^P:linux-virt$" \
    | grep "^V:" \
    | cut -d: -f2 \
    | head -1)

[[ -z "$LINUX_VIRT_VERSION" ]] && { echo "ERROR: failed to resolve linux-virt version"; exit 1; }

LINUX_VIRT_APK="$BUILD_DIR/apk-cache/linux-virt-${LINUX_VIRT_VERSION}.apk"
[[ ! -f "$LINUX_VIRT_APK" ]] && curl -sL "$ALPINE_MIRROR/v${ALPINE_VERSION%.*}/main/aarch64/linux-virt-${LINUX_VIRT_VERSION}.apk" -o "$LINUX_VIRT_APK"

tar -xf "$LINUX_VIRT_APK" -C "$KMOD_DIR" 2>/dev/null || true

KMOD_KERNEL_VERSION=""
for maybe_dir in "$KMOD_DIR"/lib/modules/*; do
    [[ -d "$maybe_dir" ]] || continue
    KMOD_KERNEL_VERSION=$(basename "$maybe_dir")
    break
done

[[ -z "$KMOD_KERNEL_VERSION" ]] && { echo "ERROR: linux-virt modules missing"; exit 1; }

echo "$KMOD_KERNEL_VERSION" > "$KMOD_DIR/.kernel-version"
echo "  linux-virt ${LINUX_VIRT_VERSION} (kernel ${KMOD_KERNEL_VERSION})"

#
# 4. Prepare pi package
#
if [[ ! -f "$PI_DIR/dist/cli.js" ]]; then
    echo "[4/6] Preparing pi package..."
    rm -rf "$PI_DIR"
    
    # Find pi installation
    PI_SOURCE=$(npm root -g 2>/dev/null)/@mariozechner/pi-coding-agent
    [[ ! -d "$PI_SOURCE" ]] && PI_SOURCE=$(dirname "$(readlink "$(which pi)" 2>/dev/null)")/.. 2>/dev/null
    [[ ! -d "$PI_SOURCE/dist" ]] && { echo "ERROR: Cannot find pi installation"; exit 1; }
    
    mkdir -p "$PI_DIR"
    cp -r "$PI_SOURCE/dist" "$PI_SOURCE/node_modules" "$PI_SOURCE/package.json" "$PI_DIR/"
    echo "  pi copied from $PI_SOURCE"
else
    echo "[4/6] pi package exists"
fi

#
# 5. Build fast initramfs
#
echo "[5/6] Building initramfs..."
rm -rf "$INITRAMFS_DIR"
mkdir -p "$INITRAMFS_DIR"

# Extract base Alpine initramfs
bsdtar -xf "$INITRAMFS_ORIG" -C "$INITRAMFS_DIR"

# Add busybox symlinks
for cmd in mount umount ip udhcpc cat echo printf grep sed awk chmod chown mv cp rm mkdir ls ln test nc sleep insmod uname; do
    ln -sf /bin/busybox "$INITRAMFS_DIR/bin/$cmd" 2>/dev/null || true
done

# Copy Node.js runtime (Alpine APK structure)
rsync -a "$NODE_DIR/" "$INITRAMFS_DIR/"

# Inject 9p modules from linux-virt APK (base initramfs omits these)
KMOD_KERNEL_VERSION=$(cat "$KMOD_DIR/.kernel-version" 2>/dev/null || true)
if [[ -n "$KMOD_KERNEL_VERSION" ]]; then
    MODULES=(
        "kernel/fs/netfs/netfs.ko.gz"
        "kernel/net/9p/9pnet.ko.gz"
        "kernel/net/9p/9pnet_virtio.ko.gz"
        "kernel/fs/9p/9p.ko.gz"
    )

    for rel in "${MODULES[@]}"; do
        src="$KMOD_DIR/lib/modules/$KMOD_KERNEL_VERSION/$rel"
        [[ -f "$src" ]] || { echo "ERROR: missing module $rel"; exit 1; }

        dest="$INITRAMFS_DIR/usr/lib/modules/$KMOD_KERNEL_VERSION/${rel%.gz}"
        mkdir -p "$(dirname "$dest")"
        gzip -dc "$src" > "$dest"
    done

    mkdir -p "$INITRAMFS_DIR/lib"
    ln -sfn /usr/lib/modules "$INITRAMFS_DIR/lib/modules"
    echo "  Added 9p modules for kernel $KMOD_KERNEL_VERSION"
fi

# Copy pi package
mkdir -p "$INITRAMFS_DIR/opt/pi"
rsync -a "$PI_DIR/" "$INITRAMFS_DIR/opt/pi/"

# Copy taskd supervisor script
mkdir -p "$INITRAMFS_DIR/opt/piwork"
cp -f "$ROOT_DIR/runtime/taskd.js" "$INITRAMFS_DIR/opt/piwork/taskd.js"
chmod +x "$INITRAMFS_DIR/opt/piwork/taskd.js"

# Copy auth if available
AUTH_PATH="${PIWORK_AUTH_PATH:-}"
AUTH_MODE="${PIWORK_AUTH_MODE:-auto}"

# If ANTHROPIC_OAUTH_TOKEN is set, bake it into env for the VM
AUTH_ENV_FILE=""
if [[ -n "${ANTHROPIC_OAUTH_TOKEN:-}" || -n "${ANTHROPIC_API_KEY:-}" ]]; then
    mkdir -p "$INITRAMFS_DIR/opt/pi-agent"
    AUTH_ENV_FILE="$INITRAMFS_DIR/opt/pi-agent/env.sh"
    : > "$AUTH_ENV_FILE"
    if [[ -n "${ANTHROPIC_OAUTH_TOKEN:-}" ]]; then
        printf 'export ANTHROPIC_OAUTH_TOKEN=%q\n' "$ANTHROPIC_OAUTH_TOKEN" >> "$AUTH_ENV_FILE"
    fi
    if [[ -n "${ANTHROPIC_API_KEY:-}" ]]; then
        printf 'export ANTHROPIC_API_KEY=%q\n' "$ANTHROPIC_API_KEY" >> "$AUTH_ENV_FILE"
    fi
    chmod 600 "$AUTH_ENV_FILE" 2>/dev/null || true
    echo "  Included ANTHROPIC_OAUTH_TOKEN in VM env"
fi

if [[ "$AUTH_MODE" != "env" ]]; then
    [[ -z "$AUTH_PATH" && -f "$HOME/.pi/agent/auth.json" ]] && AUTH_PATH="$HOME/.pi/agent/auth.json"
    if [[ -n "$AUTH_PATH" && -f "$AUTH_PATH" ]]; then
        mkdir -p "$INITRAMFS_DIR/opt/pi-agent"
        cp -f "$AUTH_PATH" "$INITRAMFS_DIR/opt/pi-agent/auth.json"
        chmod 600 "$INITRAMFS_DIR/opt/pi-agent/auth.json" 2>/dev/null || true
        echo "  Included auth from $AUTH_PATH"
    fi
else
    echo "  Skipping auth.json (PIWORK_AUTH_MODE=env)"
fi

# Write init script
cat > "$INITRAMFS_DIR/init" <<'INITEOF'
#!/bin/sh
export PATH=/usr/local/bin:/usr/bin:/bin:/sbin
export LD_LIBRARY_PATH=/usr/lib
export NODE_PATH=/opt/pi/node_modules
export PI_PACKAGE_DIR=/opt/pi
RPC_PORT=19384
WORKDIR=/mnt/workdir
TASK_STATE_DIR=/mnt/taskstate
AUTH_STATE_DIR=/mnt/authstate
TASK_STATE_MOUNTED=0
AUTH_STATE_MOUNTED=0
SESSIONS_ROOT=""
INITIAL_TASK_ID=""
AUTH_PROFILE="default"

mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs dev /dev
mount -t tmpfs tmpfs /run

modprobe virtio_pci 2>/dev/null || true
modprobe virtio_net 2>/dev/null || true
modprobe netfs 2>/dev/null || true
modprobe 9pnet 2>/dev/null || true
modprobe 9pnet_virtio 2>/dev/null || true
modprobe 9p 2>/dev/null || true

if ! grep -q $'\t9p$' /proc/filesystems 2>/dev/null; then
    KVER=$(uname -r)
    MODROOT="/usr/lib/modules/$KVER/kernel"
    insmod "$MODROOT/fs/netfs/netfs.ko" 2>/dev/null || true
    insmod "$MODROOT/net/9p/9pnet.ko" 2>/dev/null || true
    insmod "$MODROOT/net/9p/9pnet_virtio.ko" 2>/dev/null || true
    insmod "$MODROOT/fs/9p/9p.ko" 2>/dev/null || true
fi

for arg in $(cat /proc/cmdline); do
    case "$arg" in
        piwork.sessions_root=*)
            SESSIONS_ROOT="${arg#piwork.sessions_root=}"
            ;;
        piwork.task_id=*)
            INITIAL_TASK_ID="${arg#piwork.task_id=}"
            ;;
        piwork.auth_profile=*)
            AUTH_PROFILE="${arg#piwork.auth_profile=}"
            ;;
    esac
done

ip link set eth0 up
udhcpc -i eth0 -q -n -t 3 -T 1

# QEMU user-mode networking provides DNS at 10.0.2.3
echo "nameserver 10.0.2.3" > /etc/resolv.conf

# Mount working folder if available (9p virtio share)
mkdir -p "$WORKDIR"
if mount -t 9p -o trans=virtio,version=9p2000.L workdir "$WORKDIR"; then
    echo "Mounted working folder at $WORKDIR"
    export PI_WORKING_DIR="$WORKDIR"
    export PIWORK_WORKSPACE_ROOT="$WORKDIR"
    cd "$WORKDIR"
else
    echo "No working folder mounted"
fi

# Mount task state folder if available (9p virtio share)
mkdir -p "$TASK_STATE_DIR"
if mount -t 9p -o trans=virtio,version=9p2000.L taskstate "$TASK_STATE_DIR"; then
    TASK_STATE_MOUNTED=1
    echo "Mounted task state at $TASK_STATE_DIR"
else
    echo "No task state mounted"
fi

# Mount auth state folder if available (9p virtio share)
mkdir -p "$AUTH_STATE_DIR"
if mount -t 9p -o trans=virtio,version=9p2000.L authstate "$AUTH_STATE_DIR"; then
    AUTH_STATE_MOUNTED=1
    echo "Mounted auth state at $AUTH_STATE_DIR"
else
    echo "No auth state mounted"
fi

if [ -z "$SESSIONS_ROOT" ]; then
    if [ "$TASK_STATE_MOUNTED" = "1" ]; then
        SESSIONS_ROOT="$TASK_STATE_DIR/sessions"
    else
        SESSIONS_ROOT="/sessions"
    fi
fi

if [ "$AUTH_STATE_MOUNTED" = "1" ]; then
    PROFILE_DIR="$AUTH_STATE_DIR/$AUTH_PROFILE"
    if [ -f "$PROFILE_DIR/auth.json" ]; then
        export PI_CODING_AGENT_DIR="$PROFILE_DIR"
        echo "Using mounted auth profile: $AUTH_PROFILE"
    elif [ -f "$AUTH_STATE_DIR/default/auth.json" ]; then
        export PI_CODING_AGENT_DIR="$AUTH_STATE_DIR/default"
        echo "Using mounted auth profile: default"
    fi
fi

if [ -z "${PI_CODING_AGENT_DIR:-}" ] && [ -f /opt/pi-agent/auth.json ]; then
    export PI_CODING_AGENT_DIR=/opt/pi-agent
    echo "Using baked auth at /opt/pi-agent"
fi

[ -f /opt/pi-agent/env.sh ] && . /opt/pi-agent/env.sh

echo "READY"

if [ -x /usr/bin/node ] && [ -f /opt/pi/dist/cli.js ] && [ -f /opt/piwork/taskd.js ]; then
    mkdir -p "$SESSIONS_ROOT"
    export PIWORK_RPC_PORT="$RPC_PORT"
    export PIWORK_PI_CLI=/opt/pi/dist/cli.js
    export PIWORK_TASKD_SESSIONS_ROOT="$SESSIONS_ROOT"
    [ -n "$INITIAL_TASK_ID" ] && export PIWORK_INITIAL_TASK_ID="$INITIAL_TASK_ID"

    echo "Runtime: taskd"
    echo "Taskd sessions root: $SESSIONS_ROOT"

    /usr/bin/node /opt/piwork/taskd.js 2>&1 &
else
    echo "ERROR: taskd runtime dependencies missing"
fi

exec /bin/sh -i
INITEOF
chmod +x "$INITRAMFS_DIR/init"

# Create cpio archive
(cd "$INITRAMFS_DIR" && find . -print0 | cpio --null -o -H newc | gzip -9 > "$INITRAMFS_FAST")
echo "  $(du -h "$INITRAMFS_FAST" | cut -f1) initramfs"

#
# 6. Install to runtime directory
#
echo "[6/6] Installing runtime..."
mkdir -p "$RUNTIME_DIR"
cp -f "$KERNEL" "$RUNTIME_DIR/vmlinuz-virt"
cp -f "$INITRAMFS_FAST" "$RUNTIME_DIR/initramfs-virt-fast"

cat > "$RUNTIME_DIR/manifest.json" <<EOF
{
    "kernel": "vmlinuz-virt",
    "initrd": "initramfs-virt-fast",
    "cmdline": "quiet console=ttyAMA0",
    "rpcPort": $RPC_PORT
}
EOF

echo "=== Runtime installed to $RUNTIME_DIR ==="
