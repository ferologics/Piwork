.gitignore
```
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example
vite.config.js.timestamp-*
vite.config.ts.timestamp-*

tmp/

```

AGENTS.md
```
# AGENTS.md — Piwork

## Project Goal

Cowork-style UI on top of **pi** using **Tauri**. File-scoped tasks, sandboxed VM execution.

## Stack

- **Tauri 2** + **SvelteKit** + **pnpm**
- **Tailwind 4 + shadcn-svelte**
- **Vitest** (unit), Playwright deferred

## Commands

```bash
mise run check              # format + lint + compile + test
mise run tauri-dev          # run app
mise run runtime-build      # build VM runtime pack
mise run runtime-build-auth # rebuild with auth baked in
mise run runtime-clean      # clean runtime artifacts
```

## Architecture

### How it works

1. **QEMU VM** boots Alpine Linux (~1s) with kernel + initramfs
2. **Init script** (`runtime/init.sh`) mounts 9p shares, starts taskd
3. **taskd** (`runtime/taskd.js`) listens on TCP 19384, spawns one pi process per task
4. **Tauri host** connects to taskd via port-forwarded TCP, sends RPC commands
5. **Frontend** (`runtimeService.ts`) orchestrates VM lifecycle and task switching

### Key files

| File                                        | What                                                           |
| ------------------------------------------- | -------------------------------------------------------------- |
| `mise-tasks/runtime-build`                  | Downloads Alpine + Node.js, builds initramfs, installs runtime |
| `runtime/init.sh`                           | VM init script (mounts, networking, starts taskd)              |
| `runtime/taskd.js`                          | Guest process supervisor — per-task pi processes, RPC routing  |
| `src-tauri/src/vm.rs`                       | QEMU process management (spawn, ready detection, stop)         |
| `src-tauri/src/lib.rs`                      | Tauri commands (VM, tasks, auth, preview, test server)         |
| `src/lib/services/runtimeService.ts`        | Frontend runtime orchestration                                 |
| `src/lib/components/layout/MainView.svelte` | Main UI component                                              |

### 9p mounts (host → VM)

| Mount     | Guest path       | Purpose                |
| --------- | ---------------- | ---------------------- |
| workdir   | `/mnt/workdir`   | User's working folder  |
| taskstate | `/mnt/taskstate` | Per-task session files |
| authstate | `/mnt/authstate` | Host auth profiles     |

### Auth (current state)

Working: bake credentials at build time, or write to `app_data/auth/<profile>/auth.json` (mounted into VM).
Aspirational: OAuth `/login` flow through VM — unclear if it works through NAT.
Settings UI: exists but is overbuilt (multi-profile) and mostly unused for MVP.

## AI Testing Harness

Primitives in `mise-tasks/test-*` for automated testing:

```bash
mise run test-start / test-stop          # app lifecycle
mise run test-prompt "hello"             # send prompt, wait for response
mise run test-screenshot name            # capture to tmp/dev/name.png
mise run test-dump-state                 # log task/session/message state
mise run test-set-folder /path           # one-time bind working folder for active task
mise run test-set-task <id>              # switch active task
mise run test-create-task "Title" [folder]
mise run test-delete-tasks
mise run test-auth-list / test-auth-set-key / test-auth-delete / test-auth-import-pi
mise run test-set-auth-profile <name>    # switch auth profile + restart
mise run test-send-login                 # trigger /login UI flow
mise run test-open-preview <task> <path> # open file preview
mise run test-check-permissions          # verify screenshot capture works
```

### Rules

- **Primitives only** — no monolithic E2E scripts. Compose primitives ad-hoc.
- **Evidence for claims** — always capture: `test-dump-state` + `test-screenshot` + relevant logs
- **Wait explicitly** — for async transitions, poll/wait; don't rely on fixed sleeps
- **Clean up** — always `test-stop` after testing
- Test server (port 19385) is debug-only (`#[cfg(debug_assertions)]`), redacts secrets in logs.

## Docs

- `docs/` — see `docs/README.md` for index
- `docs/research/` — Cowork observations, sandbox strategy, UI sketches

## Conventions

- 4-space indentation
- Use mise tasks, not direct pnpm/cargo
- Keep configs sorted
- Pre-alpha policy: breaking changes are acceptable; do not add migration/fallback/compat shims unless explicitly requested

```

README.md
```
# Piwork

Cowork‑style, normie‑first UI on top of **pi**, built with **Tauri**.

## Status

Working prototype with VM-based sandbox. See `AGENTS.md` for architecture details.

## Stack

- Tauri 2
- SvelteKit
- pnpm
- Tailwind 4 + shadcn‑svelte
- mise (task runner)

## Development

```bash
mise run setup
mise run tauri-dev
```

```bash
mise run check
```

```bash
mise run test
```

```bash
mise run test-vite
mise run test-rust
```

## AI Harness (debug/dev)

File-based harness tasks live in `mise-tasks/`:

```bash
mise run test-start
mise run test-create-task "Title" /path/to/folder
mise run test-set-task <task-id>
mise run test-set-auth-profile <profile>  # waits until profile is applied (invalid names normalize to default)
mise run test-send-login                 # trigger /login via UI path
mise run test-auth-list [profile]
mise run test-auth-set-key <provider> <key> [profile]
mise run test-auth-delete <provider> [profile]
mise run test-auth-import-pi [profile]
mise run test-open-preview <task-id> <relative-path>
mise run test-dump-state
mise run test-screenshot name
mise run test-check-permissions   # quick preflight for screenshot visibility
mise run test-stop
```

Scope enforcement suite:

```bash
./scripts/harness/path-i-lite-negative.sh
```

### Cleanup

```bash
mise run clean        # remove build artifacts
mise run clean-deep   # remove build artifacts + node_modules
mise run reset        # clean-deep + setup
```

### Rust build cache

Rust builds use **sccache** via `.cargo/config.toml`.

## Assets

- `assets/logo.svg` is the source for app icons.
- Regenerate with `mise run icons`.

## Docs

- `AGENTS.md` - AI-focused project context and architecture
- `TODO.md` - roadmap and task tracking
- `docs/README.md` - docs index + source-of-truth pointers
- `docs/runtime-taskd-plan.md` - runtime rollout status and active execution track
- `docs/runtime-taskd-rpc-spec.md` - taskd RPC contract
- `docs/pi-integration.md` - host↔VM↔taskd integration overview
- `docs/runtime-pack.md` - runtime pack + VM boot model
- `docs/auth-flow.md` - authentication flow
- `docs/permissions-model.md` - folder access model
- `docs/task-artifact-contract.md` - working-folder immutability + outputs/uploads contract
- `docs/research/` - Cowork observations and runtime intel

```

TODO.md
```
# TODO

> Execution sequencing for cleanup work lives in `docs/cleanup-execution-plan.md` (final plan).

## Now: Foundation cleanup

- [x] **Kill v1 runtime** — remove `PIWORK_RUNTIME_V2_TASKD` flag, v1 code paths in runtimeService (`handleTaskSwitchV1`, `handleFolderChangeV1`, `ensureTaskSessionReady`), v1 `nc -l` loop in init script, `RuntimeMode` type. taskd is the only runtime.
- [x] **Rename v2_taskd → runtime** — drop "v2" prefix everywhere (types, logs, flags, docs)
- [x] **Extract init script** — move the heredoc out of `mise-tasks/runtime-build` into `runtime/init.sh`
- [x] **Fix context pollution** — infrastructure bash commands (grep mount check, mkdir, session writes) go through pi's RPC and pollute the agent's conversation. Add `system_bash` to taskd that bypasses pi sessions, or do checks in taskd before spawning pi.
- [x] **Simplify auth/settings** — strip Settings modal to: show current auth status + "Import from pi" button. Kill multi-profile UI. For MVP: baked auth or `~/.pi/agent/auth.json` import.
- [x] **Lock working folder after first bind** — `workingFolder` supports one-time bind (`null -> path`), then becomes immutable for that task; use a new task for a different folder.
- [x] **Define task artifact persistence contract** — documented in `docs/task-artifact-contract.md` (`outputs` writable, `uploads` read-only, Scratchpad aggregates both).
- [x] **Implement artifact contract in runtime/UI** — enforce one-time folder bind, surface Scratchpad from `outputs` + `uploads`, and apply uploads read-only policy.
- [ ] **Untangle auth state from runtime artifacts** — keep auth storage purpose clear; avoid mixing credentials with unrelated pi/session artifacts.
- [ ] **Fix sendLogin optimistic log** — logs `[info] Sent /login` even if not connected
- [x] **Fix opener permission path** — added `opener:allow-open-path` capability so `Open in Finder` is authorized.
- [x] **Fix right-panel error isolation** — Working-folder action errors are now scoped to the Working folder card.
- [x] **Fix first `/mnt/workdir` write reliability (race mitigation)** — task-bound folder changes now mark `taskSwitching` before validation, and prompt send is blocked until runtime is ready.
- [ ] **Add harness regression for working-folder writes** — set folder → write file immediately → assert host path has file.
- [ ] **Add harness check for open-folder action** — validate Working-folder header icon opens Finder path successfully.
- [ ] **Inject minimal FS runtime hint into prompts** — include working-folder host path + `/mnt/workdir` alias + scratchpad path, and refresh when folder is bound later (not just at startup).
- [ ] **Fix dev cwd chip staleness on task reopen** — top-bar runtime cwd can remain at `/mnt/taskstate/.../outputs` even after task runtime moves to `/mnt/workdir`.
- [ ] **Delete remaining slop** — review docs for stale references to v1, v2 flags, sync protocol, smoke suites
- [ ] **Dev watch scope** — avoid restarting `tauri dev` for non-runtime docs/content edits (e.g. Markdown), keep hot reload scoped to relevant source/config files.
- [x] **Roadmap sync hygiene** — synced `docs/ui-roadmap.md` with current `TODO.md` execution state (2026-02-06).

## Next: Make it usable

- [ ] **Model picker realism (no fake fallback)** — stop hardcoding fallback model lists in runtime/UI; only show models the runtime actually reports.
- [ ] **Model availability empty/error state** — if no models are available, show a clear empty/error state and disable picker actions.
- [ ] **Model scope toggle in Settings** — add `Preferred only` (default shortlist we define) vs `All available` filtering for model picker results.
- [ ] **Persist model selection to task metadata** — write picker changes back to `taskStore.model` so switching/reopening tasks restores model intent.
- [ ] **Finish auth profile cull for MVP** — remove remaining multi-profile runtime/test plumbing and standardize on the default profile path.
- [ ] **Markdown rendering** — render agent responses (bold, lists, code blocks). Biggest UX gap.
- [ ] **Tool call display** — collapsible "Created a file ›", "Ran command ›" in message stream
- [x] **Right panel IA pass** — replace “Downloads” with “Working folder” card semantics (dynamic title = folder basename when set), clear empty states, and open-in-Finder affordance.
- [x] **Move Working-folder open action to header** — icon-only action is now in card header (left of chevron), body button removed.
- [x] **Scratchpad continuity** — keep Scratchpad visible for every task and aggregate artifacts from both `outputs` and `uploads`.
- [x] **Artifact explorer parity** — make file listing/preview behavior consistent across working-folder and no-folder tasks, including uploads read-only behavior.
- [x] **Auto-refresh artifact panels** — Scratchpad now refreshes on `tool_execution_end` / `turn_end` / `agent_end` events (manual refresh still available).
- [x] **Working-folder file visibility** — Working-folder card now lists files and updates from runtime events.
- [ ] **Context panel usefulness** — surface active connectors/tools and task-referenced files, not just static copy.

## Later: Production

- [ ] **Auth end-to-end** — test OAuth `/login` flow, decide if it actually works through VM NAT
- [ ] **Multi-task runtime behavior** — define expected behavior for switching between active tasks without losing running session state (foreground/background semantics, status visibility, resume behavior).
- [ ] **Runtime download** — first-run pack download for non-dev users
- [ ] **Bundle pi** — include pi in runtime pack instead of copying from global npm
- [ ] **Onboarding** — first-run experience that doesn't require `mise run runtime-build`

## Later: Polish

- [ ] **Doc cleanup** — consolidate stale docs, kill anything that doesn't match reality
- [ ] **Code cleanup** — deep pass, remove slop, consistent patterns
- [ ] **Task title editing** — editable at top of conversation
- [ ] **Empty state polish** — shuffleable task categories like Cowork
- [ ] **Progress model v2 (non-P0)** — experiment with Cowork-style step/milestone summaries inferred from task/tool activity, with clear confidence/limitations.

## Someday

- [ ] Connectors (Calendar, Slack, Google Drive, Notion)
- [ ] Clipboard + attachments (images/files with MIME-aware previews)
- [ ] Multi-folder tasks
- [ ] Cross-platform (Linux/Windows)
- [ ] MITM network proxy
- [ ] Canvas/rich artifact viewer
- [ ] qcow2 rootfs (lower RAM)
- [ ] Gate G2 — Gondolin vs deeper sandbox hardening (research only)

## Testing

- Harness primitives: `test-start`, `test-prompt`, `test-screenshot`, `test-set-folder`, `test-set-task`, `test-create-task`, `test-delete-tasks`, `test-dump-state`, `test-stop`, `test-open-preview`, `test-auth-*`, `test-send-login`, `test-set-auth-profile`, `test-check-permissions`
- Scope enforcement: `scripts/harness/path-i-lite-negative.sh`
- Rule: primitives only, no monolithic E2E scripts

```

biome.json
```
{
    "$schema": "https://biomejs.dev/schemas/2.3.14/schema.json",
    "formatter": {
        "indentStyle": "space",
        "indentWidth": 4,
        "lineWidth": 120
    },
    "linter": {
        "enabled": false
    },
    "css": {
        "parser": {
            "tailwindDirectives": true
        }
    }
}

```

components.json
```
{
    "$schema": "https://shadcn-svelte.com/schema.json",
    "tailwind": {
        "css": "src/app.css",
        "baseColor": "slate"
    },
    "aliases": {
        "components": "$lib/components",
        "utils": "$lib/utils",
        "ui": "$lib/ui",
        "hooks": "$lib/hooks",
        "lib": "$lib"
    },
    "typescript": true,
    "registry": "https://shadcn-svelte.com/registry"
}

```

dprint.json
```
{
    "plugins": ["https://plugins.dprint.dev/markdown-0.17.8.wasm"],
    "markdown": {
        "lineWidth": 100
    },
    "includes": ["**/*.{md,mdx}"],
    "excludes": ["**/node_modules/**", "**/.svelte-kit/**", "**/build/**", "**/package/**"]
}

```

mise.toml
```
[tasks.build]
description = "Build the frontend"
run = "pnpm exec vite build"

[tasks.check]
description = "Format, lint, typecheck, test"
run = "mise run format && mise run lint && mise run compile && mise run test"

[tasks.clean]
description = "Remove build artifacts"
run = "rm -rf .svelte-kit build dist package coverage src-tauri/target target node_modules/.vite"

[tasks.clean-deep]
description = "Remove build artifacts + node_modules"
run = "mise run clean && rm -rf node_modules"

[tasks.compile]
description = "Typecheck (svelte-check + cargo check)"
run = "pnpm exec svelte-kit sync && pnpm exec svelte-check --tsconfig ./tsconfig.json && cargo check --manifest-path src-tauri/Cargo.toml"

[tasks.dev]
description = "Run Vite dev server"
run = "pnpm exec vite dev"

[tasks.format]
description = "Format code (Biome + dprint + rustfmt)"
run = "pnpm exec biome format --write src src-tauri/tauri.conf.json src-tauri/capabilities/default.json package.json components.json svelte.config.js vite.config.js tailwind.config.ts tsconfig.json biome.json dprint.json && dprint fmt && cargo fmt --manifest-path src-tauri/Cargo.toml"

[tasks.icons]
description = "Regenerate app icons from assets/logo.svg"
run = "pnpm exec tauri icon assets/logo.svg --output src-tauri/icons"

[tasks.lint]
description = "Lint code (oxlint + clippy)"
run = "pnpm exec oxlint --tsconfig tsconfig.json src && cargo clippy --manifest-path src-tauri/Cargo.toml -- -D warnings"

[tasks.preview]
description = "Preview the build"
run = "pnpm exec vite preview"

[tasks.reset]
description = "Deep clean + setup"
run = "mise run clean-deep && mise run setup"

[tasks.runtime-clean]
description = "Remove runtime artifacts"
run = "rm -rf tmp/boot tmp/runtime-* tmp/initramfs-* tmp/apk-cache \"$HOME/Library/Application Support/com.pi.work/runtime\""

[tasks.setup]
description = "Install dependencies"
run = "pnpm install"

[tasks.tauri-build]
description = "Build the Tauri app"
run = "pnpm exec tauri build"

[tasks.tauri-dev]
description = "Run the Tauri app"
depends = ["runtime-build"]
run = "pnpm exec tauri dev"

[tasks.test]
description = "Run all tests"
run = "mise run test-vite && mise run test-rust"

[tasks.test-rust]
description = "Run Rust tests"
run = "cargo test --manifest-path src-tauri/Cargo.toml"

[tasks.test-vite]
description = "Run frontend tests"
run = "pnpm exec vitest run"

```

package.json
```
{
    "name": "piwork",
    "version": "0.1.0",
    "description": "",
    "type": "module",
    "scripts": {
        "build": "mise run build",
        "check": "mise run check",
        "compile": "mise run compile",
        "dev": "mise run dev",
        "format": "mise run format",
        "lint": "mise run lint",
        "preview": "mise run preview",
        "setup": "mise run setup",
        "tauri:build": "mise run tauri-build",
        "tauri:dev": "mise run tauri-dev",
        "test": "mise run test"
    },
    "license": "MIT",
    "dependencies": {
        "@tauri-apps/api": "^2",
        "@tauri-apps/plugin-dialog": "^2.6.0",
        "@tauri-apps/plugin-opener": "^2"
    },
    "devDependencies": {
        "@biomejs/biome": "^2.3.14",
        "@lucide/svelte": "^0.563.1",
        "@sveltejs/adapter-static": "^3.0.6",
        "@sveltejs/kit": "^2.9.0",
        "@sveltejs/vite-plugin-svelte": "^5.0.0",
        "@tailwindcss/vite": "^4.0.0",
        "@tauri-apps/cli": "^2",
        "@testing-library/jest-dom": "^6.6.0",
        "@testing-library/svelte": "^4.2.3",
        "@testing-library/user-event": "^14.6.1",
        "clsx": "^2.1.1",
        "jsdom": "^25.0.1",
        "oxlint": "^1.43.0",
        "svelte": "^5.0.0",
        "svelte-check": "^4.0.0",
        "tailwind-merge": "^3.4.0",
        "tailwind-variants": "^3.2.2",
        "tailwindcss": "^4.0.0",
        "tw-animate-css": "^1.4.0",
        "typescript": "~5.6.2",
        "vite": "^6.0.3",
        "vitest": "^2.1.8"
    }
}

```

runtime/init.sh
```
#!/bin/sh
export PATH=/usr/local/bin:/usr/bin:/bin:/sbin
export LD_LIBRARY_PATH=/usr/lib
export NODE_PATH=/opt/pi/node_modules
export PI_PACKAGE_DIR=/opt/pi
RPC_PORT=19384
WORKDIR=/mnt/workdir
TASK_STATE_DIR=/mnt/taskstate
AUTH_STATE_DIR=/mnt/authstate
TASK_STATE_MOUNTED=0
AUTH_STATE_MOUNTED=0
SESSIONS_ROOT=""
TASKS_ROOT=""
INITIAL_TASK_ID=""
AUTH_PROFILE="default"

wait_for_taskd_port() {
    PORT_HEX=$(printf '%04X' "$RPC_PORT")
    ATTEMPT=0

    while [ "$ATTEMPT" -lt 50 ]; do
        if grep -qi ":$PORT_HEX " /proc/net/tcp 2>/dev/null; then
            return 0
        fi

        sleep 0.1
        ATTEMPT=$((ATTEMPT + 1))
    done

    return 1
}

mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs dev /dev
mount -t tmpfs tmpfs /run

modprobe virtio_pci 2>/dev/null || true
modprobe virtio_net 2>/dev/null || true
modprobe netfs 2>/dev/null || true
modprobe 9pnet 2>/dev/null || true
modprobe 9pnet_virtio 2>/dev/null || true
modprobe 9p 2>/dev/null || true

if ! grep -q $'\t9p$' /proc/filesystems 2>/dev/null; then
    KVER=$(uname -r)
    MODROOT="/usr/lib/modules/$KVER/kernel"
    insmod "$MODROOT/fs/netfs/netfs.ko" 2>/dev/null || true
    insmod "$MODROOT/net/9p/9pnet.ko" 2>/dev/null || true
    insmod "$MODROOT/net/9p/9pnet_virtio.ko" 2>/dev/null || true
    insmod "$MODROOT/fs/9p/9p.ko" 2>/dev/null || true
fi

for arg in $(cat /proc/cmdline); do
    case "$arg" in
        piwork.sessions_root=*)
            SESSIONS_ROOT="${arg#piwork.sessions_root=}"
            ;;
        piwork.task_id=*)
            INITIAL_TASK_ID="${arg#piwork.task_id=}"
            ;;
        piwork.auth_profile=*)
            AUTH_PROFILE="${arg#piwork.auth_profile=}"
            ;;
    esac
done

ip link set eth0 up
udhcpc -i eth0 -q -n -t 3 -T 1

# QEMU user-mode networking provides DNS at 10.0.2.3
echo "nameserver 10.0.2.3" > /etc/resolv.conf

# Mount working folder if available (9p virtio share)
mkdir -p "$WORKDIR"
if mount -t 9p -o trans=virtio,version=9p2000.L workdir "$WORKDIR"; then
    echo "Mounted working folder at $WORKDIR"
    export PI_WORKING_DIR="$WORKDIR"
    export PIWORK_WORKSPACE_ROOT="$WORKDIR"
    cd "$WORKDIR"
else
    echo "No working folder mounted"
fi

# Mount task state folder if available (9p virtio share)
mkdir -p "$TASK_STATE_DIR"
if mount -t 9p -o trans=virtio,version=9p2000.L taskstate "$TASK_STATE_DIR"; then
    TASK_STATE_MOUNTED=1
    echo "Mounted task state at $TASK_STATE_DIR"
else
    echo "No task state mounted"
fi

# Mount auth state folder if available (9p virtio share)
mkdir -p "$AUTH_STATE_DIR"
if mount -t 9p -o trans=virtio,version=9p2000.L authstate "$AUTH_STATE_DIR"; then
    AUTH_STATE_MOUNTED=1
    echo "Mounted auth state at $AUTH_STATE_DIR"
else
    echo "No auth state mounted"
fi

if [ -z "$SESSIONS_ROOT" ]; then
    if [ "$TASK_STATE_MOUNTED" = "1" ]; then
        SESSIONS_ROOT="$TASK_STATE_DIR/sessions"
    else
        SESSIONS_ROOT="/sessions"
    fi
fi

TASKS_ROOT="${SESSIONS_ROOT%/*}"
if [ -z "$TASKS_ROOT" ]; then
    TASKS_ROOT="/"
fi

if [ "$AUTH_STATE_MOUNTED" = "1" ]; then
    PROFILE_DIR="$AUTH_STATE_DIR/$AUTH_PROFILE"
    if [ -f "$PROFILE_DIR/auth.json" ]; then
        export PI_CODING_AGENT_DIR="$PROFILE_DIR"
        echo "Using mounted auth profile: $AUTH_PROFILE"
    elif [ -f "$AUTH_STATE_DIR/default/auth.json" ]; then
        export PI_CODING_AGENT_DIR="$AUTH_STATE_DIR/default"
        echo "Using mounted auth profile: default"
    fi
fi

if [ -z "${PI_CODING_AGENT_DIR:-}" ] && [ -f /opt/pi-agent/auth.json ]; then
    export PI_CODING_AGENT_DIR=/opt/pi-agent
    echo "Using baked auth at /opt/pi-agent"
fi

[ -f /opt/pi-agent/env.sh ] && . /opt/pi-agent/env.sh

if [ -x /usr/bin/node ] && [ -f /opt/pi/dist/cli.js ] && [ -f /opt/piwork/taskd.js ]; then
    mkdir -p "$SESSIONS_ROOT" "$TASKS_ROOT"
    export PIWORK_RPC_PORT="$RPC_PORT"
    export PIWORK_PI_CLI=/opt/pi/dist/cli.js
    export PIWORK_TASKD_SESSIONS_ROOT="$SESSIONS_ROOT"
    export PIWORK_TASKD_TASKS_ROOT="$TASKS_ROOT"
    [ -n "$INITIAL_TASK_ID" ] && export PIWORK_INITIAL_TASK_ID="$INITIAL_TASK_ID"

    echo "Runtime: taskd"
    echo "Taskd sessions root: $SESSIONS_ROOT"
    echo "Taskd tasks root: $TASKS_ROOT"

    /usr/bin/node /opt/piwork/taskd.js 2>&1 &

    if wait_for_taskd_port; then
        echo "READY"
    else
        echo "ERROR: taskd RPC port did not become ready"
    fi
else
    echo "ERROR: taskd runtime dependencies missing"
fi

exec /bin/sh -i

```

runtime/taskd.js
```
#!/usr/bin/env node
"use strict";

const crypto = require("crypto");
const fs = require("fs");
const net = require("net");
const path = require("path");
const readline = require("readline");
const { spawn } = require("child_process");

const RPC_PORT = Number.parseInt(process.env.PIWORK_RPC_PORT || "19384", 10);
const NODE_BIN = process.env.PIWORK_NODE_BIN || "/usr/bin/node";
const PI_CLI = process.env.PIWORK_PI_CLI || "/opt/pi/dist/cli.js";
const SESSIONS_ROOT = process.env.PIWORK_TASKD_SESSIONS_ROOT || "/sessions";
const TASKS_ROOT = process.env.PIWORK_TASKD_TASKS_ROOT || path.dirname(SESSIONS_ROOT);
const WORKSPACE_ROOT = process.env.PIWORK_WORKSPACE_ROOT || "";
const INITIAL_TASK_ID = process.env.PIWORK_INITIAL_TASK_ID || "";
const DEFAULT_PROVIDER = process.env.PIWORK_DEFAULT_PROVIDER || "anthropic";
const DEFAULT_MODEL = process.env.PIWORK_DEFAULT_MODEL || "claude-opus-4-5";
const DEFAULT_THINKING_LEVEL = process.env.PIWORK_DEFAULT_THINKING || "high";
const LEGACY_TASK_ID = "__legacy__";
const CHILD_COMMAND_TIMEOUT_MS = 10_000;
const SYSTEM_BASH_TIMEOUT_MS = 10_000;
const STOP_GRACE_PERIOD_MS = 1_200;

const FALLBACK_MODELS = [
    {
        id: "claude-opus-4-5",
        name: "Opus 4.5",
        provider: "anthropic",
    },
    {
        id: "gpt-5.2-codex",
        name: "GPT 5.2",
        provider: "openai-codex",
    },
    {
        id: "gemini-3-pro-preview",
        name: "Gemini 3 Pro",
        provider: "google-gemini-cli",
    },
];

const IDEMPOTENT_REQUESTS = new Set(["create_or_open_task", "switch_task", "stop_task"]);

const tasks = new Map();
const requestCache = new Map();

let activeTaskId = null;
let hostSocket = null;

let defaults = {
    provider: DEFAULT_PROVIDER,
    model: DEFAULT_MODEL,
    thinkingLevel: DEFAULT_THINKING_LEVEL,
};

let workspaceRootReal = undefined;

function log(message) {
    console.log(`[taskd] ${message}`);
}

function randomId(prefix) {
    return `${prefix}_${crypto.randomUUID().replaceAll("-", "")}`;
}

function isRecord(value) {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}

function validateTaskId(taskId) {
    return (
        typeof taskId === "string" &&
        taskId.length > 0 &&
        !taskId.includes("/") &&
        !taskId.includes("\\") &&
        !taskId.includes("..")
    );
}

function createWorkspacePolicyError(message, details = {}) {
    const error = new Error(message);
    error.code = "WORKSPACE_POLICY_VIOLATION";
    error.details = details;
    return error;
}

function normalizeRelativeWorkingFolder(value) {
    if (value === null || value === undefined) {
        return null;
    }

    if (typeof value !== "string") {
        throw createWorkspacePolicyError("workingFolderRelative must be a string", {});
    }

    const trimmed = value.trim();
    if (trimmed.length === 0 || trimmed === ".") {
        return "";
    }

    if (trimmed.includes("\0") || trimmed.includes("\\") || trimmed.startsWith("/")) {
        throw createWorkspacePolicyError("workingFolderRelative is invalid", {
            reason: "invalid_path_format",
        });
    }

    const normalized = path.posix.normalize(trimmed);
    if (normalized === ".." || normalized.startsWith("../") || normalized.startsWith("/")) {
        throw createWorkspacePolicyError("workingFolderRelative escapes workspace root", {
            reason: "path_escape",
        });
    }

    return normalized === "." ? "" : normalized;
}

function isPathWithin(root, candidate) {
    const relative = path.relative(root, candidate);
    return relative === "" || (!relative.startsWith("..") && !path.isAbsolute(relative));
}

function ensureNoSymlinkComponents(root, candidate) {
    const relative = path.relative(root, candidate);
    if (!relative || relative === ".") {
        return;
    }

    let current = root;
    for (const segment of relative.split(path.sep)) {
        if (!segment || segment === ".") {
            continue;
        }

        current = path.join(current, segment);
        const stat = fs.lstatSync(current);
        if (stat.isSymbolicLink()) {
            throw createWorkspacePolicyError("working folder path must not include symlink components", {
                path: current,
            });
        }
    }
}

function getWorkspaceRootReal() {
    if (workspaceRootReal !== undefined) {
        return workspaceRootReal;
    }

    if (!WORKSPACE_ROOT) {
        workspaceRootReal = null;
        return workspaceRootReal;
    }

    try {
        const stat = fs.lstatSync(WORKSPACE_ROOT);
        if (stat.isSymbolicLink()) {
            throw createWorkspacePolicyError("workspace root must not be a symlink", {
                path: WORKSPACE_ROOT,
            });
        }

        const resolved = fs.realpathSync(WORKSPACE_ROOT);
        const resolvedStat = fs.statSync(resolved);
        if (!resolvedStat.isDirectory()) {
            throw createWorkspacePolicyError("workspace root must be a directory", {
                path: resolved,
            });
        }

        workspaceRootReal = resolved;
    } catch (error) {
        log(`workspace root unavailable (${WORKSPACE_ROOT}): ${String(error)}`);
        workspaceRootReal = null;
    }

    return workspaceRootReal;
}

function resolveTaskCwd(task) {
    const relativePath = normalizeRelativeWorkingFolder(task.requestedWorkingFolderRelative);
    task.requestedWorkingFolderRelative = relativePath;

    if (relativePath === null) {
        return task.workDir;
    }

    const workspaceRoot = getWorkspaceRootReal();
    if (!workspaceRoot) {
        log(`task ${task.taskId} has scoped folder but workspace root is unavailable; falling back to ${task.workDir}`);
        return task.workDir;
    }

    const relativeOsPath = relativePath.split("/").join(path.sep);
    const candidate = relativeOsPath.length > 0 ? path.join(workspaceRoot, relativeOsPath) : workspaceRoot;

    let candidateReal;
    try {
        candidateReal = fs.realpathSync(candidate);
    } catch {
        throw createWorkspacePolicyError("working folder does not exist in workspace root", {
            relativePath,
        });
    }

    if (!isPathWithin(workspaceRoot, candidateReal)) {
        throw createWorkspacePolicyError("working folder escapes workspace root", {
            relativePath,
        });
    }

    const stat = fs.statSync(candidateReal);
    if (!stat.isDirectory()) {
        throw createWorkspacePolicyError("working folder must be a directory", {
            relativePath,
        });
    }

    ensureNoSymlinkComponents(workspaceRoot, candidateReal);
    return candidateReal;
}

function normalizePayload(raw) {
    if (!isRecord(raw)) {
        return {};
    }

    if (isRecord(raw.payload)) {
        return { ...raw.payload };
    }

    const payload = {};

    if (typeof raw.taskId === "string") {
        payload.taskId = raw.taskId;
    }
    if (typeof raw.message === "string") {
        payload.message = raw.message;
    }
    if (typeof raw.promptId === "string") {
        payload.promptId = raw.promptId;
    }
    if (typeof raw.provider === "string") {
        payload.provider = raw.provider;
    }
    if (typeof raw.model === "string") {
        payload.model = raw.model;
    }
    if (typeof raw.modelId === "string") {
        payload.model = raw.modelId;
    }
    if (typeof raw.thinkingLevel === "string") {
        payload.thinkingLevel = raw.thinkingLevel;
    }
    if (typeof raw.workingFolder === "string") {
        payload.workingFolder = raw.workingFolder;
    }
    if (typeof raw.workingFolderRelative === "string") {
        payload.workingFolderRelative = raw.workingFolderRelative;
    }

    return payload;
}

function requestFingerprint(request) {
    return JSON.stringify({
        type: request.type,
        payload: request.payload,
    });
}

function writeJson(payload) {
    if (!hostSocket || hostSocket.destroyed || !hostSocket.writable) {
        return;
    }

    hostSocket.write(`${JSON.stringify(payload)}\n`);
}

function emitEvent(event, taskId, payload = {}) {
    writeJson({
        type: "event",
        event,
        timestamp: new Date().toISOString(),
        taskId,
        payload,
    });
}

function cacheIdempotentResponse(request, response) {
    if (!request.id || !IDEMPOTENT_REQUESTS.has(request.type)) {
        return;
    }

    requestCache.set(request.id, {
        fingerprint: requestFingerprint(request),
        response,
    });
}

function maybeHandleDuplicateIdempotentRequest(request) {
    if (!request.id || !IDEMPOTENT_REQUESTS.has(request.type)) {
        return false;
    }

    const cached = requestCache.get(request.id);
    if (!cached) {
        return false;
    }

    if (cached.fingerprint !== requestFingerprint(request)) {
        const response = {
            id: request.id,
            ok: false,
            error: {
                code: "INVALID_REQUEST",
                message: "Duplicate request id with different payload",
                retryable: false,
                details: {},
            },
        };
        writeJson(response);
        return true;
    }

    writeJson(cached.response);
    return true;
}

function sendV2Success(request, result) {
    const response = {
        id: request.id || null,
        ok: true,
        result,
    };

    cacheIdempotentResponse(request, response);
    writeJson(response);
    return response;
}

function sendV2Error(request, code, message, retryable = false, details = {}) {
    const response = {
        id: request.id || null,
        ok: false,
        error: {
            code,
            message,
            retryable,
            details,
        },
    };

    cacheIdempotentResponse(request, response);
    writeJson(response);
    return response;
}

function sendLegacyResponse(command, success, data, error, id) {
    const response = {
        type: "response",
        command,
        success,
    };

    if (typeof id === "string") {
        response.id = id;
    }

    if (success) {
        response.data = data ?? {};
    } else {
        response.error = error || "Unknown error";
    }

    writeJson(response);
}

function buildTask(taskId, options = {}) {
    const sessionDir = path.join(SESSIONS_ROOT, taskId);
    const sessionFile = path.join(sessionDir, "session.json");
    const taskDir = path.join(TASKS_ROOT, taskId);
    const outputsDir = path.join(taskDir, "outputs");
    const uploadsDir = path.join(taskDir, "uploads");

    return {
        taskId,
        state: "missing",
        provider: typeof options.provider === "string" ? options.provider : defaults.provider,
        model: typeof options.model === "string" ? options.model : defaults.model,
        thinkingLevel:
            typeof options.thinkingLevel === "string" ? options.thinkingLevel : defaults.thinkingLevel,
        requestedWorkingFolder:
            typeof options.workingFolder === "string" ? options.workingFolder : null,
        requestedWorkingFolderRelative:
            typeof options.workingFolderRelative === "string" ? options.workingFolderRelative : null,
        sessionFile,
        taskDir,
        outputsDir,
        uploadsDir,
        workDir: outputsDir,
        currentCwd: outputsDir,
        child: null,
        pendingChildRequests: new Map(),
        stopping: false,
        promptInFlight: false,
        promptCommandId: null,
    };
}

function serializeTask(task) {
    return {
        taskId: task.taskId,
        state: task.state,
        sessionFile: task.sessionFile,
        taskDir: task.taskDir,
        outputsDir: task.outputsDir,
        uploadsDir: task.uploadsDir,
        workDir: task.workDir,
        currentCwd: task.currentCwd,
        workingFolderRelative: task.requestedWorkingFolderRelative,
    };
}

function updateTaskConfig(task, options = {}) {
    if (typeof options.provider === "string") {
        task.provider = options.provider;
    }
    if (typeof options.model === "string") {
        task.model = options.model;
    }
    if (typeof options.thinkingLevel === "string") {
        task.thinkingLevel = options.thinkingLevel;
    }
    if (Object.prototype.hasOwnProperty.call(options, "workingFolder")) {
        task.requestedWorkingFolder = typeof options.workingFolder === "string" ? options.workingFolder : null;
    }
    if (Object.prototype.hasOwnProperty.call(options, "workingFolderRelative")) {
        task.requestedWorkingFolderRelative =
            typeof options.workingFolderRelative === "string" ? options.workingFolderRelative : null;
    }
}

function rejectPendingChildRequests(task, reason) {
    for (const [id, pending] of task.pendingChildRequests) {
        clearTimeout(pending.timeout);
        pending.reject(new Error(reason));
        task.pendingChildRequests.delete(id);
    }
}

function extractChunkFromPayload(payload) {
    if (!isRecord(payload)) {
        return null;
    }

    if (payload.type === "tool_execution_update" && typeof payload.output === "string") {
        return payload.output;
    }

    if (payload.type !== "message_update") {
        return null;
    }

    const event = payload.assistantMessageEvent;
    if (!isRecord(event) || typeof event.type !== "string") {
        return null;
    }

    if (
        (event.type === "text_delta" ||
            event.type === "thinking_delta" ||
            event.type === "toolcall_delta") &&
        typeof event.delta === "string"
    ) {
        return event.delta;
    }

    return null;
}

function forwardChildPayload(task, payload) {
    if (task.taskId === activeTaskId) {
        writeJson(payload);
    }

    const chunk = extractChunkFromPayload(payload);
    if (chunk && chunk.length > 0) {
        emitEvent("agent_output", task.taskId, { chunk });
    }

    if (payload.type === "agent_end") {
        task.promptInFlight = false;
        task.promptCommandId = null;

        const usage = isRecord(payload.usage) ? payload.usage : undefined;
        emitEvent("agent_end", task.taskId, usage ? { usage } : {});
    }

    if (payload.type === "response" && task.promptCommandId && payload.id === task.promptCommandId) {
        if (payload.success === false) {
            task.promptInFlight = false;
            task.promptCommandId = null;
            emitEvent("task_error", task.taskId, {
                code: "INTERNAL_ERROR",
                message: typeof payload.error === "string" ? payload.error : "prompt rejected",
            });
        }
    }
}

function handleChildOutputLine(task, line) {
    const trimmed = line.trim();
    if (!trimmed) {
        return;
    }

    let payload;
    try {
        payload = JSON.parse(trimmed);
    } catch {
        log(`task ${task.taskId} emitted non-JSON line: ${trimmed}`);
        return;
    }

    if (payload.type === "response" && typeof payload.id === "string") {
        const pending = task.pendingChildRequests.get(payload.id);
        if (pending) {
            clearTimeout(pending.timeout);
            task.pendingChildRequests.delete(payload.id);
            pending.resolve(payload);
            return;
        }
    }

    forwardChildPayload(task, payload);
}

function handleChildExit(task, code, signal) {
    const reason = `pi exited (code=${code ?? "null"}, signal=${signal ?? "null"})`;

    rejectPendingChildRequests(task, reason);

    task.child = null;
    task.promptInFlight = false;
    task.promptCommandId = null;

    if (task.stopping) {
        task.stopping = false;
        task.state = "stopped";
        return;
    }

    task.state = "errored";

    if (activeTaskId === task.taskId) {
        activeTaskId = null;
    }

    emitEvent("task_error", task.taskId, {
        code: "PI_PROCESS_DEAD",
        message: reason,
    });
}

async function spawnTaskProcess(task) {
    if (task.child && !task.child.killed) {
        return;
    }

    fs.mkdirSync(path.dirname(task.sessionFile), { recursive: true });
    fs.mkdirSync(task.taskDir, { recursive: true });
    fs.mkdirSync(task.outputsDir, { recursive: true });
    fs.mkdirSync(task.uploadsDir, { recursive: true });

    try {
        fs.chmodSync(task.outputsDir, 0o755);
        fs.chmodSync(task.uploadsDir, 0o555);
    } catch {
        // Best-effort permissions for 9p mounts.
    }

    const taskCwd = resolveTaskCwd(task);
    const args = [PI_CLI, "--mode", "rpc", "--session", task.sessionFile];

    const child = spawn(NODE_BIN, args, {
        cwd: taskCwd,
        env: {
            ...process.env,
            PI_WORKING_DIR: taskCwd,
        },
        stdio: ["pipe", "pipe", "pipe"],
    });

    task.child = child;
    task.currentCwd = taskCwd;
    task.stopping = false;
    task.promptInFlight = false;
    task.promptCommandId = null;

    const stdout = readline.createInterface({
        input: child.stdout,
        crlfDelay: Infinity,
    });

    stdout.on("line", (line) => {
        handleChildOutputLine(task, line);
    });

    child.stderr.on("data", (chunk) => {
        const text = chunk.toString().trim();
        if (text.length > 0) {
            log(`task ${task.taskId} stderr: ${text}`);
        }
    });

    child.on("exit", (code, signal) => {
        handleChildExit(task, code, signal);
    });

    await new Promise((resolve, reject) => {
        const onError = (error) => {
            child.off("spawn", onSpawn);
            reject(error);
        };

        const onSpawn = () => {
            child.off("error", onError);
            resolve();
        };

        child.once("error", onError);
        child.once("spawn", onSpawn);
    });

    task.state = "ready";

    if (task.provider && task.model) {
        void sendToTask(task, {
            type: "set_model",
            provider: task.provider,
            modelId: task.model,
        }).catch((error) => {
            log(`task ${task.taskId} set_model failed: ${String(error)}`);
        });
    }
}

async function stopTaskProcess(task) {
    if (!task.child || task.child.killed) {
        task.child = null;
        task.state = "stopped";
        task.promptInFlight = false;
        task.promptCommandId = null;
        return;
    }

    const child = task.child;
    task.stopping = true;

    await new Promise((resolve) => {
        let settled = false;

        const settle = () => {
            if (settled) {
                return;
            }
            settled = true;
            resolve();
        };

        const timer = setTimeout(() => {
            child.kill("SIGKILL");
            settle();
        }, STOP_GRACE_PERIOD_MS);

        child.once("exit", () => {
            clearTimeout(timer);
            settle();
        });

        child.kill("SIGTERM");
    });

    task.child = null;
    task.state = "stopped";
    task.promptInFlight = false;
    task.promptCommandId = null;
}

function sendToTask(task, command, timeoutMs = CHILD_COMMAND_TIMEOUT_MS) {
    if (!task.child || !task.child.stdin || task.child.stdin.destroyed) {
        return Promise.reject(new Error("task process unavailable"));
    }

    const id = typeof command.id === "string" ? command.id : randomId("child");
    const payload = { ...command, id };

    return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
            task.pendingChildRequests.delete(id);
            reject(new Error(`Task command timed out: ${payload.type}`));
        }, timeoutMs);

        task.pendingChildRequests.set(id, { resolve, reject, timeout });

        task.child.stdin.write(`${JSON.stringify(payload)}\n`, (error) => {
            if (!error) {
                return;
            }

            clearTimeout(timeout);
            task.pendingChildRequests.delete(id);
            reject(error);
        });
    });
}

async function createOrOpenTaskInternal(taskId, options) {
    let task = tasks.get(taskId);
    let mode = "created";

    if (!task) {
        task = buildTask(taskId, options);
        tasks.set(taskId, task);
    } else {
        updateTaskConfig(task, options);

        if (task.state === "ready" || task.state === "idle" || task.state === "active") {
            const error = new Error("task already open");
            error.code = "TASK_NOT_READY";
            throw error;
        }

        mode = task.state === "errored" ? "recovered" : "resumed";
    }

    await spawnTaskProcess(task);

    if (task.state !== "active") {
        task.state = "ready";
    }

    return {
        task,
        mode,
    };
}

function switchTaskInternal(taskId, emitEvents = true) {
    const target = tasks.get(taskId);
    if (!target) {
        const error = new Error("task not found");
        error.code = "TASK_NOT_FOUND";
        throw error;
    }

    if (!["ready", "idle", "active"].includes(target.state)) {
        const error = new Error("task is not ready");
        error.code = "TASK_NOT_READY";
        throw error;
    }

    if (emitEvents) {
        emitEvent("task_switch_started", taskId, {});
    }

    if (activeTaskId && activeTaskId !== taskId) {
        const previous = tasks.get(activeTaskId);
        if (previous && previous.state === "active") {
            previous.state = "idle";
        }
    }

    activeTaskId = taskId;
    target.state = "active";

    if (emitEvents) {
        emitEvent("task_ready", taskId, {});
    }
}

async function ensureLegacyActiveTask() {
    const preferredTaskId = validateTaskId(INITIAL_TASK_ID) ? INITIAL_TASK_ID : LEGACY_TASK_ID;

    if (!tasks.has(preferredTaskId)) {
        await createOrOpenTaskInternal(preferredTaskId, defaults);
    }

    const task = tasks.get(preferredTaskId);
    if (!task) {
        throw new Error("failed to create legacy task");
    }

    if (task.state === "stopped" || task.state === "errored" || task.state === "missing") {
        await createOrOpenTaskInternal(preferredTaskId, defaults);
    }

    switchTaskInternal(preferredTaskId, false);
    return tasks.get(preferredTaskId);
}

async function startPromptOnActiveTask(message) {
    if (typeof message !== "string" || message.trim().length === 0) {
        const error = new Error("message is required");
        error.code = "INVALID_REQUEST";
        throw error;
    }

    let task = activeTaskId ? tasks.get(activeTaskId) : null;

    if (!task) {
        task = await ensureLegacyActiveTask();
    }

    if (!task || task.state !== "active") {
        const error = new Error("no active task");
        error.code = "TASK_NOT_READY";
        throw error;
    }

    if (task.promptInFlight) {
        const error = new Error("prompt already running for active task");
        error.code = "TASK_NOT_READY";
        throw error;
    }

    const commandId = randomId("prompt");
    task.promptInFlight = true;
    task.promptCommandId = commandId;

    await sendToTask(task, {
        id: commandId,
        type: "prompt",
        message,
    }).catch((error) => {
        task.promptInFlight = false;
        task.promptCommandId = null;
        throw error;
    });

    return task;
}

function inspectDirectory(targetPath) {
    try {
        const stats = fs.statSync(targetPath);
        return stats.isDirectory() ? "directory" : "not_directory";
    } catch {
        return "missing";
    }
}

function getActiveTaskCwd() {
    const activeTask = activeTaskId ? tasks.get(activeTaskId) : null;
    if (!activeTask || typeof activeTask.currentCwd !== "string" || activeTask.currentCwd.length === 0) {
        return null;
    }

    if (inspectDirectory(activeTask.currentCwd) !== "directory") {
        return null;
    }

    return activeTask.currentCwd;
}

function resolveSystemBashCwd(rawCwd) {
    if (rawCwd === null || rawCwd === undefined) {
        return { cwd: getActiveTaskCwd() };
    }

    if (typeof rawCwd !== "string") {
        return { error: "cwd must be a string" };
    }

    const trimmed = rawCwd.trim();
    if (trimmed.length === 0) {
        return { cwd: null };
    }

    const activeTaskCwd = getActiveTaskCwd();
    const baseCwd = activeTaskCwd || process.cwd();
    const resolved = path.isAbsolute(trimmed) ? path.resolve(trimmed) : path.resolve(baseCwd, trimmed);
    const directoryState = inspectDirectory(resolved);

    if (directoryState === "not_directory") {
        return { error: "cwd must be a directory" };
    }

    if (directoryState === "missing") {
        return { error: "cwd does not exist" };
    }

    return { cwd: resolved };
}

function readSystemBashString(request, keys) {
    for (const source of [request.payload, request.raw]) {
        if (!isRecord(source)) {
            continue;
        }

        for (const key of keys) {
            const value = source[key];
            if (typeof value === "string") {
                return value;
            }
        }
    }

    return null;
}

function parseSystemBashRequest(request) {
    const command = readSystemBashString(request, ["command"]) || "";
    if (!command.trim()) {
        return { error: "command is required" };
    }

    const requestedCwd = readSystemBashString(request, ["cwd", "workingDirectory"]);
    const cwdResult = resolveSystemBashCwd(requestedCwd);
    if (cwdResult.error) {
        return { error: cwdResult.error };
    }

    return {
        command,
        cwd: cwdResult.cwd,
    };
}

async function runSystemBash(command, cwd = null) {
    return await new Promise((resolve) => {
        const child = spawn("/bin/sh", ["-lc", command], {
            cwd: cwd || undefined,
            stdio: ["ignore", "pipe", "pipe"],
        });

        let output = "";
        let timedOut = false;
        let settled = false;

        const finish = (result) => {
            if (settled) {
                return;
            }

            settled = true;
            resolve(result);
        };

        const timeout = setTimeout(() => {
            timedOut = true;
            child.kill("SIGKILL");
        }, SYSTEM_BASH_TIMEOUT_MS);

        child.stdout.on("data", (chunk) => {
            output += chunk.toString();
        });

        child.stderr.on("data", (chunk) => {
            output += chunk.toString();
        });

        child.on("error", (error) => {
            clearTimeout(timeout);
            finish({
                output: `${output}${String(error)}`,
                exitCode: 1,
                timedOut: false,
            });
        });

        child.on("close", (code) => {
            clearTimeout(timeout);
            finish({
                output,
                exitCode: timedOut ? 124 : typeof code === "number" ? code : 1,
                timedOut,
            });
        });
    });
}

function parseRequest(raw) {
    if (!isRecord(raw) || typeof raw.type !== "string") {
        return null;
    }

    const hasPayloadField = Object.prototype.hasOwnProperty.call(raw, "payload");

    return {
        id: typeof raw.id === "string" ? raw.id : null,
        type: raw.type,
        payload: normalizePayload(raw),
        raw,
        hasPayloadField,
    };
}

function pickTaskNotReadyRetryable(code) {
    return code === "TASK_NOT_READY";
}

async function handleV2CreateOrOpenTask(request) {
    const taskId = typeof request.payload.taskId === "string" ? request.payload.taskId : null;

    if (!validateTaskId(taskId)) {
        return sendV2Error(request, "INVALID_REQUEST", "taskId is required", false, {});
    }

    try {
        const { task, mode } = await createOrOpenTaskInternal(taskId, request.payload);
        return sendV2Success(request, {
            taskId: task.taskId,
            state: task.state,
            mode,
        });
    } catch (error) {
        const code = typeof error?.code === "string" ? error.code : "INTERNAL_ERROR";
        const message = error instanceof Error ? error.message : String(error);
        const details = isRecord(error?.details) ? error.details : {};
        return sendV2Error(request, code, message, pickTaskNotReadyRetryable(code), details);
    }
}

function handleV2SwitchTask(request) {
    const taskId = typeof request.payload.taskId === "string" ? request.payload.taskId : null;

    if (!validateTaskId(taskId)) {
        return sendV2Error(request, "INVALID_REQUEST", "taskId is required", false, {});
    }

    try {
        const task = tasks.get(taskId);
        if (!task) {
            return sendV2Error(request, "TASK_NOT_FOUND", "task not found", false, {});
        }

        if (!["ready", "idle", "active"].includes(task.state)) {
            return sendV2Error(request, "TASK_NOT_READY", "task is not ready", true, {});
        }

        const response = sendV2Success(request, {
            status: "switching",
            taskId,
        });

        switchTaskInternal(taskId, true);
        return response;
    } catch (error) {
        const code = typeof error?.code === "string" ? error.code : "INTERNAL_ERROR";
        const message = error instanceof Error ? error.message : String(error);
        return sendV2Error(request, code, message, pickTaskNotReadyRetryable(code), {});
    }
}

async function handleV2Prompt(request) {
    const message = typeof request.payload.message === "string" ? request.payload.message : null;
    const promptId = typeof request.payload.promptId === "string" ? request.payload.promptId : randomId("prompt");

    if (!message) {
        return sendV2Error(request, "INVALID_REQUEST", "message is required", false, {});
    }

    const task = activeTaskId ? tasks.get(activeTaskId) : null;
    if (!task || task.state !== "active") {
        return sendV2Error(request, "TASK_NOT_READY", "no active task", true, {});
    }

    const response = sendV2Success(request, {
        accepted: true,
        taskId: task.taskId,
        promptId,
    });

    startPromptOnActiveTask(message).catch((error) => {
        const messageText = error instanceof Error ? error.message : String(error);
        emitEvent("task_error", task.taskId, {
            code: "INTERNAL_ERROR",
            message: messageText,
        });
    });

    return response;
}

function handleV2GetState(request) {
    const payload = {
        activeTaskId,
        tasks: Array.from(tasks.values()).map(serializeTask),
    };

    return sendV2Success(request, payload);
}

async function handleV2SystemBash(request) {
    const parsed = parseSystemBashRequest(request);
    if (parsed.error) {
        return sendV2Error(request, "INVALID_REQUEST", parsed.error, false, {});
    }

    const result = await runSystemBash(parsed.command, parsed.cwd);
    return sendV2Success(request, {
        output: result.output,
        exitCode: result.exitCode,
        timedOut: result.timedOut,
        cwd: parsed.cwd,
    });
}

async function handleV2StopTask(request) {
    const taskId = typeof request.payload.taskId === "string" ? request.payload.taskId : null;

    if (!validateTaskId(taskId)) {
        return sendV2Error(request, "INVALID_REQUEST", "taskId is required", false, {});
    }

    const task = tasks.get(taskId);
    if (!task) {
        return sendV2Error(request, "TASK_NOT_FOUND", "task not found", false, {});
    }

    if (!["ready", "active", "idle", "errored", "stopped"].includes(task.state)) {
        return sendV2Error(request, "TASK_NOT_READY", "task cannot be stopped", true, {});
    }

    try {
        await stopTaskProcess(task);

        if (activeTaskId === taskId) {
            activeTaskId = null;
        }

        task.state = "stopped";
        emitEvent("task_stopped", taskId, {});

        return sendV2Success(request, {
            taskId,
            state: "stopped",
        });
    } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        return sendV2Error(request, "INTERNAL_ERROR", message, false, {});
    }
}

async function handleV2Request(request) {
    if (!request.id) {
        return sendV2Error(request, "INVALID_REQUEST", "id is required", false, {});
    }

    if (maybeHandleDuplicateIdempotentRequest(request)) {
        return;
    }

    switch (request.type) {
        case "create_or_open_task":
            await handleV2CreateOrOpenTask(request);
            return;
        case "switch_task":
            handleV2SwitchTask(request);
            return;
        case "prompt":
            await handleV2Prompt(request);
            return;
        case "get_state":
            handleV2GetState(request);
            return;
        case "system_bash":
            await handleV2SystemBash(request);
            return;
        case "stop_task":
            await handleV2StopTask(request);
            return;
        default:
            sendV2Error(request, "INVALID_REQUEST", `Unknown request type: ${request.type}`, false, {});
    }
}

function legacyStatePayload() {
    const activeTask = activeTaskId ? tasks.get(activeTaskId) : null;

    return {
        model: {
            id: activeTask?.model || defaults.model,
            name: activeTask?.model || defaults.model,
            provider: activeTask?.provider || defaults.provider,
        },
        sessionName: activeTaskId,
        sessionId: activeTaskId,
        isStreaming: Boolean(activeTask?.promptInFlight),
        activeTaskId,
        tasks: Array.from(tasks.values()).map(serializeTask),
    };
}

async function handleLegacyGetState(request) {
    sendLegacyResponse("get_state", true, legacyStatePayload(), null, request.id || undefined);
}

async function handleLegacyGetAvailableModels(request) {
    sendLegacyResponse(
        "get_available_models",
        true,
        {
            models: FALLBACK_MODELS,
        },
        null,
        request.id || undefined,
    );
}

async function handleLegacySetModel(request) {
    const provider = typeof request.payload.provider === "string" ? request.payload.provider : defaults.provider;
    const model =
        typeof request.payload.model === "string"
            ? request.payload.model
            : typeof request.raw.modelId === "string"
              ? request.raw.modelId
              : defaults.model;

    defaults = {
        ...defaults,
        provider,
        model,
    };

    if (activeTaskId) {
        const activeTask = tasks.get(activeTaskId);
        if (activeTask) {
            activeTask.provider = provider;
            activeTask.model = model;
            if (activeTask.child) {
                void sendToTask(activeTask, {
                    type: "set_model",
                    provider,
                    modelId: model,
                }).catch((error) => {
                    log(`legacy set_model passthrough failed: ${String(error)}`);
                });
            }
        }
    }

    sendLegacyResponse(
        "set_model",
        true,
        {
            id: model,
            name: model,
            provider,
        },
        null,
        request.id || undefined,
    );
}

async function handleLegacyPrompt(request) {
    const message = typeof request.payload.message === "string" ? request.payload.message : null;

    if (!message) {
        sendLegacyResponse("prompt", false, null, "message is required", request.id || undefined);
        return;
    }

    try {
        const task = await startPromptOnActiveTask(message);
        sendLegacyResponse(
            "prompt",
            true,
            {
                accepted: true,
                taskId: task.taskId,
            },
            null,
            request.id || undefined,
        );
    } catch (error) {
        const messageText = error instanceof Error ? error.message : String(error);
        sendLegacyResponse("prompt", false, null, messageText, request.id || undefined);
    }
}

async function handleLegacyExtensionUiResponse(request) {
    if (!activeTaskId) {
        sendLegacyResponse(
            "extension_ui_response",
            false,
            null,
            "No active task",
            request.id || undefined,
        );
        return;
    }

    const task = tasks.get(activeTaskId);
    if (!task || !task.child || task.child.stdin.destroyed) {
        sendLegacyResponse(
            "extension_ui_response",
            false,
            null,
            "No active task process",
            request.id || undefined,
        );
        return;
    }

    task.child.stdin.write(`${JSON.stringify(request.raw)}\n`);
    sendLegacyResponse("extension_ui_response", true, {}, null, request.id || undefined);
}

async function handleLegacySystemBash(request, commandName) {
    const parsed = parseSystemBashRequest(request);
    if (parsed.error) {
        sendLegacyResponse(commandName, false, null, parsed.error, request.id || undefined);
        return;
    }

    const result = await runSystemBash(parsed.command, parsed.cwd);
    sendLegacyResponse(
        commandName,
        true,
        {
            output: result.output,
            exitCode: result.exitCode,
            timedOut: result.timedOut,
            cwd: parsed.cwd,
        },
        null,
        request.id || undefined,
    );
}

async function handleLegacySwitchSession(request) {
    sendLegacyResponse(
        "switch_session",
        false,
        null,
        "switch_session is unsupported in taskd mode",
        request.id || undefined,
    );
}

async function handleLegacyRequest(request) {
    switch (request.type) {
        case "get_state":
            await handleLegacyGetState(request);
            return;
        case "get_available_models":
            await handleLegacyGetAvailableModels(request);
            return;
        case "set_model":
            await handleLegacySetModel(request);
            return;
        case "prompt":
            await handleLegacyPrompt(request);
            return;
        case "extension_ui_response":
            await handleLegacyExtensionUiResponse(request);
            return;
        case "bash":
            await handleLegacySystemBash(request, "bash");
            return;
        case "system_bash":
            await handleLegacySystemBash(request, "system_bash");
            return;
        case "switch_session":
            await handleLegacySwitchSession(request);
            return;
        default:
            sendLegacyResponse(request.type, false, null, `Unknown command: ${request.type}`, request.id || undefined);
    }
}

function isV2Request(request) {
    if (request.hasPayloadField) {
        return true;
    }

    return ["create_or_open_task", "switch_task", "stop_task", "system_bash"].includes(request.type);
}

async function handleRawHostLine(line) {
    const trimmed = line.trim();
    if (!trimmed) {
        return;
    }

    let raw;
    try {
        raw = JSON.parse(trimmed);
    } catch {
        writeJson({
            ok: false,
            error: {
                code: "INVALID_REQUEST",
                message: "Invalid JSON",
                retryable: false,
                details: {},
            },
        });
        return;
    }

    const request = parseRequest(raw);
    if (!request) {
        writeJson({
            ok: false,
            error: {
                code: "INVALID_REQUEST",
                message: "Request must include string type",
                retryable: false,
                details: {},
            },
        });
        return;
    }

    if (isV2Request(request)) {
        await handleV2Request(request);
        return;
    }

    await handleLegacyRequest(request);
}

async function bootstrapInitialTask() {
    if (!validateTaskId(INITIAL_TASK_ID)) {
        return;
    }

    try {
        await createOrOpenTaskInternal(INITIAL_TASK_ID, defaults);
        switchTaskInternal(INITIAL_TASK_ID, false);
        log(`Bootstrapped initial task ${INITIAL_TASK_ID}`);
    } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        log(`Failed to bootstrap initial task ${INITIAL_TASK_ID}: ${message}`);
    }
}

function startServer() {
    const server = net.createServer((socket) => {
        if (hostSocket && hostSocket !== socket) {
            hostSocket.destroy();
        }

        hostSocket = socket;
        log("Host connected");

        const reader = readline.createInterface({
            input: socket,
            crlfDelay: Infinity,
        });

        reader.on("line", (line) => {
            void handleRawHostLine(line);
        });

        socket.on("close", () => {
            if (hostSocket === socket) {
                hostSocket = null;
            }
            log("Host disconnected");
        });

        socket.on("error", (error) => {
            log(`Host socket error: ${String(error)}`);
        });
    });

    server.on("error", (error) => {
        log(`Server error: ${String(error)}`);
    });

    server.listen(RPC_PORT, "0.0.0.0", () => {
        log(`Listening on ${RPC_PORT}`);
    });
}

async function main() {
    fs.mkdirSync(SESSIONS_ROOT, { recursive: true });
    fs.mkdirSync(TASKS_ROOT, { recursive: true });
    log(`Sessions root: ${SESSIONS_ROOT}`);
    log(`Tasks root: ${TASKS_ROOT}`);

    await bootstrapInitialTask();
    startServer();
}

void main();

```

rustfmt.toml
```
# Rust formatting config
edition = "2021"
tab_spaces = 4
max_width = 120
use_small_heuristics = "Default"

```

scripts/harness/path-i-lite-negative.sh
```
#!/usr/bin/env bash
set -euo pipefail

ROOT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")/../.." && pwd)
LOG_FILE="$ROOT_DIR/tmp/dev/piwork.log"
SCREENSHOT_NAME="${1:-path-i-lite-negative-suite}"
SUFFIX=$(date +%s)

WORKSPACE_ROOT="$ROOT_DIR/tmp/path-i-lite/workspace-$SUFFIX"
TASK_A_DIR="$WORKSPACE_ROOT/task-a"
TASK_B_DIR="$WORKSPACE_ROOT/task-b"

cleanup() {
    mise run test-stop >/dev/null 2>&1 || true
}
trap cleanup EXIT

mkdir -p "$TASK_A_DIR" "$TASK_B_DIR"
printf "alpha-secret-%s\n" "$SUFFIX" > "$TASK_A_DIR/secret-a.txt"
printf "beta-note-%s\n" "$SUFFIX" > "$TASK_B_DIR/public-b.txt"
ln -sfn ../task-a/secret-a.txt "$TASK_B_DIR/link-to-a.txt"

echo "[path-i-lite] checking screenshot permission"
if ! mise run test-check-permissions; then
    echo "[path-i-lite] screenshot preflight failed"
    exit 1
fi

echo "[path-i-lite] starting app with scoped workspace root"
PIWORK_WORKSPACE_ROOT="$WORKSPACE_ROOT" mise run test-start >/dev/null

mise run test-delete-tasks >/dev/null
sleep 1

TITLE_A="I2 Task A $SUFFIX"
TITLE_B="I2 Task B $SUFFIX"

mise run test-create-task "$TITLE_A" "$TASK_A_DIR" >/dev/null
sleep 1
mise run test-create-task "$TITLE_B" "$TASK_B_DIR" >/dev/null
sleep 1

TASKS_DIR="$HOME/Library/Application Support/com.pi.work/tasks"

TASK_A_ID=$(python - "$TASKS_DIR" "$TITLE_A" <<'PY'
import json
import pathlib
import sys

root = pathlib.Path(sys.argv[1])
title = sys.argv[2]
for task_file in root.glob("*/task.json"):
    try:
        data = json.loads(task_file.read_text())
    except Exception:
        continue
    if data.get("title") == title:
        print(data.get("id", ""))
        break
PY
)

TASK_B_ID=$(python - "$TASKS_DIR" "$TITLE_B" <<'PY'
import json
import pathlib
import sys

root = pathlib.Path(sys.argv[1])
title = sys.argv[2]
for task_file in root.glob("*/task.json"):
    try:
        data = json.loads(task_file.read_text())
    except Exception:
        continue
    if data.get("title") == title:
        print(data.get("id", ""))
        break
PY
)

if [[ -z "$TASK_A_ID" || -z "$TASK_B_ID" ]]; then
    echo "[path-i-lite] failed to resolve task ids"
    exit 1
fi

mise run test-set-task "$TASK_B_ID" >/dev/null
sleep 1

echo "[path-i-lite] check 1/4: traversal read blocked"
TRAVERSAL_RESULT=$(printf '{"cmd":"preview_read","taskId":"%s","relativePath":"../task-a/secret-a.txt"}\n' "$TASK_B_ID" | nc -w 2 localhost 19385)
if [[ "$TRAVERSAL_RESULT" != *"ERR: Invalid relative path component"* && "$TRAVERSAL_RESULT" != *"ERR: relativePath must not traverse parent directories"* ]]; then
    echo "[path-i-lite] unexpected traversal result: $TRAVERSAL_RESULT"
    exit 1
fi

echo "[path-i-lite] check 2/4: symlink read blocked"
SYMLINK_RESULT=$(printf '{"cmd":"preview_read","taskId":"%s","relativePath":"link-to-a.txt"}\n' "$TASK_B_ID" | nc -w 2 localhost 19385)
if [[ "$SYMLINK_RESULT" != *"ERR: Symlink previews are not allowed"* ]]; then
    echo "[path-i-lite] unexpected symlink result: $SYMLINK_RESULT"
    exit 1
fi

echo "[path-i-lite] check 3/4: direct task file read still works"
OWN_RESULT=$(printf '{"cmd":"preview_read","taskId":"%s","relativePath":"public-b.txt"}\n' "$TASK_B_ID" | nc -w 2 localhost 19385)
if [[ "$OWN_RESULT" != *"beta-note-$SUFFIX"* ]]; then
    echo "[path-i-lite] failed own file read check"
    exit 1
fi

echo "[path-i-lite] check 4/4: guest rejects workingFolderRelative escape"
RPC_REQ_ID="path_i_lite_escape_$SUFFIX"
printf '{"id":"%s","type":"create_or_open_task","payload":{"taskId":"bad-scope-%s","provider":"anthropic","model":"claude-opus-4-5","thinkingLevel":"high","workingFolderRelative":"../escape"}}\n' "$RPC_REQ_ID" "$SUFFIX" | nc -w 2 localhost 19385 >/dev/null

ESCAPE_BLOCKED=0
for _ in $(seq 1 20); do
    if rg -q "$RPC_REQ_ID" "$LOG_FILE" && rg -q "$RPC_REQ_ID.*WORKSPACE_POLICY_VIOLATION" "$LOG_FILE"; then
        ESCAPE_BLOCKED=1
        break
    fi
    sleep 0.5
done

if [[ "$ESCAPE_BLOCKED" -ne 1 ]]; then
    echo "[path-i-lite] missing WORKSPACE_POLICY_VIOLATION evidence for $RPC_REQ_ID"
    exit 1
fi

mise run test-open-preview "$TASK_B_ID" "public-b.txt" >/dev/null
sleep 1
mise run test-dump-state >/dev/null
mise run test-screenshot "$SCREENSHOT_NAME" >/dev/null

echo "[path-i-lite] PASS"
echo "[path-i-lite] task_a=$TASK_A_ID task_b=$TASK_B_ID"
echo "[path-i-lite] screenshot=$ROOT_DIR/tmp/dev/$SCREENSHOT_NAME.png"
echo "[path-i-lite] log=$LOG_FILE"

```

scripts/mitm-clean.sh
```
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
ROOT_DIR=$(cd "$SCRIPT_DIR/.." && pwd)
TMP_DIR=${TMP_DIR:-$ROOT_DIR/tmp}

rm -f "$TMP_DIR/piwork-netdev.sock" \
    "$TMP_DIR/mitm-netdev.log" \
    "$TMP_DIR/mitm-qemu.log" \
    "$TMP_DIR/mitm-boot.log"

if [[ "${CLEAN_ISO:-0}" == "1" ]]; then
    rm -f "$TMP_DIR/alpine-virt-3.23.3-aarch64.iso"
    rm -rf "$TMP_DIR/boot" "$TMP_DIR/alpine-kernel.cmdline" "$TMP_DIR/initramfs-fast"
fi

```

scripts/mitm-netdev-host.mjs
```
#!/usr/bin/env node
import fs from "node:fs";
import net from "node:net";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(scriptDir, "..");
const tmpDir = process.env.TMP_DIR ?? path.join(rootDir, "tmp");

fs.mkdirSync(tmpDir, { recursive: true });

const socketPath = process.env.NETDEV_SOCKET ?? process.argv[2] ?? path.join(tmpDir, "piwork-netdev.sock");
const waitSeconds = Number(process.env.WAIT_FOR_SOCKET ?? 10);
const maxFrameSize = Number(process.env.MAX_FRAME_SIZE ?? 65535);
const hostIp = process.env.HOST_IP ?? "192.168.100.1";
const hostMac = process.env.HOST_MAC ?? "02:50:00:00:00:01";
const logFrames = process.env.LOG_FRAMES === "1";
const allowedDomains = new Set(
    (process.env.ALLOWED_DOMAINS ?? "example.com")
        .split(",")
        .map((domain) => domain.trim().toLowerCase())
        .filter(Boolean),
);
const dnsResponseIp = process.env.DNS_RESPONSE_IP ?? hostIp;

const hostIpBytes = ipToBytes(hostIp);
const hostMacBytes = macToBytes(hostMac);
const dnsResponseIpBytes = ipToBytes(dnsResponseIp);
const httpBody = "piwork mitm ok\n";
const httpResponse = Buffer.from(
    "HTTP/1.1 200 OK\r\n" +
        "Content-Type: text/plain\r\n" +
        `Content-Length: ${Buffer.byteLength(httpBody)}\r\n` +
        "Connection: close\r\n" +
        "\r\n" +
        httpBody,
);

const connections = new Map();

await waitForSocket(socketPath, waitSeconds);

const client = net.createConnection(socketPath);
let pending = Buffer.alloc(0);

client.on("connect", () => {
    console.log(`Connected to ${socketPath}`);
    console.log(`Host IP ${hostIp}, MAC ${hostMac}`);
});

client.on("error", (error) => {
    console.error("Socket error:", error.message);
    process.exit(1);
});

client.on("data", (chunk) => {
    pending = Buffer.concat([pending, chunk]);
    pending = drainFrames(pending);
});

function drainFrames(buffer) {
    let offset = 0;

    while (buffer.length - offset >= 4) {
        const frameLength = buffer.readUInt32BE(offset);

        if (frameLength > maxFrameSize) {
            console.error(`Frame length ${frameLength} exceeds max ${maxFrameSize}. Resetting buffer.`);
            return Buffer.alloc(0);
        }

        if (buffer.length - offset < 4 + frameLength) {
            break;
        }

        const frame = buffer.subarray(offset + 4, offset + 4 + frameLength);
        handleFrame(frame);
        offset += 4 + frameLength;
    }

    return buffer.subarray(offset);
}

function handleFrame(frame) {
    if (frame.length < 14) {
        return;
    }

    const dest = frame.subarray(0, 6);
    const source = frame.subarray(6, 12);
    const etherType = frame.readUInt16BE(12);

    if (logFrames) {
        logFrame(frame);
    }

    if (etherType === 0x0806) {
        handleArp(frame, source);
        return;
    }

    if (etherType === 0x0800) {
        handleIpv4(frame, dest, source);
    }
}

function handleArp(frame) {
    if (frame.length < 42) {
        return;
    }

    const arpOffset = 14;
    const oper = frame.readUInt16BE(arpOffset + 6);
    const senderMac = frame.subarray(arpOffset + 8, arpOffset + 14);
    const senderIp = frame.subarray(arpOffset + 14, arpOffset + 18);
    const targetIp = frame.subarray(arpOffset + 24, arpOffset + 28);

    if (oper !== 1) {
        return;
    }

    if (!targetIp.equals(hostIpBytes)) {
        return;
    }

    const reply = buildArpReply(senderMac, senderIp);
    sendFrame(reply);
    console.log(`ARP reply -> ${formatIp(senderIp)}`);
}

function handleIpv4(frame, _destMac, sourceMac) {
    const ipOffset = 14;
    if (frame.length < ipOffset + 20) {
        return;
    }

    const versionIhl = frame[ipOffset];
    const ihl = (versionIhl & 0x0f) * 4;
    if (ihl < 20 || frame.length < ipOffset + ihl) {
        return;
    }

    const protocol = frame[ipOffset + 9];
    const sourceIp = frame.subarray(ipOffset + 12, ipOffset + 16);
    const destIp = frame.subarray(ipOffset + 16, ipOffset + 20);
    const totalLength = frame.readUInt16BE(ipOffset + 2);

    if (protocol === 17) {
        handleUdp(frame, sourceMac, sourceIp, destIp, ipOffset, ihl, totalLength);
        return;
    }

    if (protocol === 6) {
        handleTcp(frame, sourceMac, sourceIp, destIp, ipOffset, ihl, totalLength);
        return;
    }

    if (!destIp.equals(hostIpBytes)) {
        return;
    }

    if (protocol !== 1) {
        return;
    }

    const icmpOffset = ipOffset + ihl;
    if (frame.length < icmpOffset + 8) {
        return;
    }

    const icmpType = frame[icmpOffset];
    if (icmpType !== 8) {
        return;
    }

    const payloadEnd = Math.min(ipOffset + totalLength, frame.length);
    const icmpPayload = Buffer.from(frame.subarray(icmpOffset, payloadEnd));
    icmpPayload[0] = 0;
    icmpPayload[2] = 0;
    icmpPayload[3] = 0;
    const icmpChecksum = computeChecksum(icmpPayload);
    icmpPayload.writeUInt16BE(icmpChecksum, 2);

    const ipHeader = Buffer.from(frame.subarray(ipOffset, ipOffset + ihl));
    ipHeader.writeUInt8(64, 8);
    ipHeader.writeUInt16BE(ihl + icmpPayload.length, 2);
    hostIpBytes.copy(ipHeader, 12);
    sourceIp.copy(ipHeader, 16);
    ipHeader.writeUInt16BE(0, 10);
    const ipChecksum = computeChecksum(ipHeader);
    ipHeader.writeUInt16BE(ipChecksum, 10);

    const ethernet = Buffer.alloc(14);
    sourceMac.copy(ethernet, 0);
    hostMacBytes.copy(ethernet, 6);
    ethernet.writeUInt16BE(0x0800, 12);

    const reply = Buffer.concat([ethernet, ipHeader, icmpPayload]);
    sendFrame(reply);
    console.log(`ICMP echo reply -> ${formatIp(sourceIp)}`);
}

function handleUdp(frame, sourceMac, sourceIp, destIp, ipOffset, ihl, totalLength) {
    const udpOffset = ipOffset + ihl;
    if (frame.length < udpOffset + 8) {
        return;
    }

    const sourcePort = frame.readUInt16BE(udpOffset);
    const destPort = frame.readUInt16BE(udpOffset + 2);
    const length = frame.readUInt16BE(udpOffset + 4);
    const payloadStart = udpOffset + 8;
    const payloadEnd = Math.min(payloadStart + length - 8, ipOffset + totalLength, frame.length);

    if (payloadEnd <= payloadStart) {
        return;
    }

    if (destPort === 67) {
        if (!destIp.equals(hostIpBytes) && !isBroadcastIp(destIp)) {
            return;
        }
        const payload = frame.subarray(payloadStart, payloadEnd);
        handleDhcp(payload, sourceMac, sourceIp, destIp, sourcePort, destPort);
        return;
    }

    if (destPort === 53) {
        if (!destIp.equals(hostIpBytes) && !isBroadcastIp(destIp)) {
            return;
        }
        const payload = frame.subarray(payloadStart, payloadEnd);
        handleDns(payload, sourceMac, sourceIp, sourcePort);
    }
}

function handleTcp(frame, sourceMac, sourceIp, destIp, ipOffset, ihl, totalLength) {
    if (!destIp.equals(hostIpBytes)) {
        return;
    }

    const tcpOffset = ipOffset + ihl;
    if (frame.length < tcpOffset + 20) {
        return;
    }

    const sourcePort = frame.readUInt16BE(tcpOffset);
    const destPort = frame.readUInt16BE(tcpOffset + 2);
    const seq = frame.readUInt32BE(tcpOffset + 4);
    const ackSeq = frame.readUInt32BE(tcpOffset + 8);
    const flags = frame[tcpOffset + 13];
    const dataOffset = (frame[tcpOffset + 12] >> 4) * 4;
    const isFin = (flags & 0x01) !== 0;
    const payloadStart = tcpOffset + dataOffset;
    const payloadEnd = Math.min(ipOffset + totalLength, frame.length);
    const payload = payloadEnd > payloadStart ? frame.subarray(payloadStart, payloadEnd) : Buffer.alloc(0);

    if (destPort !== 80) {
        return;
    }

    const key = `${formatIp(sourceIp)}:${sourcePort}`;
    let conn = connections.get(key);

    if (!conn) {
        conn = {
            clientMac: sourceMac,
            clientIp: Buffer.from(sourceIp),
            clientPort: sourcePort,
            serverSeq: 1,
            established: false,
            finSent: false,
        };
        connections.set(key, conn);
    }

    if (flags & 0x04) {
        connections.delete(key);
        return;
    }

    if ((flags & 0x02) && !(flags & 0x10)) {
        const ack = seq + 1;
        sendTcpSegment({
            conn,
            flags: 0x12,
            seq: conn.serverSeq,
            ack,
            payload: Buffer.alloc(0),
        });
        conn.serverSeq += 1;
        return;
    }

    if (isFin) {
        const ack = seq + 1;
        sendTcpSegment({
            conn,
            flags: 0x10,
            seq: conn.serverSeq,
            ack,
            payload: Buffer.alloc(0),
        });
        connections.delete(key);
        return;
    }

    if (conn.finSent && (flags & 0x10) && ackSeq === conn.serverSeq) {
        connections.delete(key);
        return;
    }

    if (flags & 0x10) {
        conn.established = true;
    }

    if (!conn.established || payload.length === 0) {
        return;
    }

    const responsePayload = httpResponse;
    const ack = seq + payload.length;

    sendTcpSegment({
        conn,
        flags: 0x19,
        seq: conn.serverSeq,
        ack,
        payload: responsePayload,
    });

    conn.serverSeq += responsePayload.length + 1;
    conn.finSent = true;
    conn.lastAck = ackSeq;
    console.log(`HTTP response -> ${key}`);
}

function handleDhcp(payload, sourceMac, _sourceIp, _destIp) {
    if (payload.length < 240) {
        return;
    }

    const op = payload[0];
    const hlen = payload[2];
    const xid = payload.readUInt32BE(4);
    const flags = payload.readUInt16BE(10);

    if (op !== 1 || hlen !== 6) {
        return;
    }

    const cookie = payload.readUInt32BE(236);
    if (cookie !== 0x63825363) {
        return;
    }

    const options = parseDhcpOptions(payload.subarray(240));
    const messageType = options.messageType;
    const requestedIp = options.requestedIp;

    if (!messageType) {
        return;
    }

    const offerIp = ipToBytes("192.168.100.2");

    if (messageType === 1) {
        const reply = buildDhcpReply({
            messageType: 2,
            xid,
            flags,
            clientMac: sourceMac,
            yiaddr: offerIp,
        });
        sendDhcpFrame(reply, sourceMac);
        console.log("DHCP offer -> 192.168.100.2");
        return;
    }

    if (messageType === 3) {
        if (requestedIp && !requestedIp.equals(offerIp)) {
            console.log(`DHCP request for ${formatIp(requestedIp)} ignored`);
            return;
        }

        const reply = buildDhcpReply({
            messageType: 5,
            xid,
            flags,
            clientMac: sourceMac,
            yiaddr: offerIp,
        });
        sendDhcpFrame(reply, sourceMac);
        console.log("DHCP ack -> 192.168.100.2");
    }
}

function handleDns(payload, sourceMac, sourceIp, sourcePort) {
    const query = parseDnsQuery(payload);
    if (!query) {
        return;
    }

    const domain = query.name.toLowerCase();
    const isAllowed = allowedDomains.has(domain);

    if (!isAllowed) {
        const response = buildDnsResponse(query, { rcode: 3 });
        sendDnsFrame(response, sourceMac, sourceIp, sourcePort);
        console.log(`DNS blocked -> ${domain}`);
        return;
    }

    if (query.qtype !== 1 || query.qclass !== 1) {
        const response = buildDnsResponse(query, { rcode: 0 });
        sendDnsFrame(response, sourceMac, sourceIp, sourcePort);
        console.log(`DNS no-answer -> ${domain}`);
        return;
    }

    const response = buildDnsResponse(query, { rcode: 0, answerIp: dnsResponseIpBytes });
    sendDnsFrame(response, sourceMac, sourceIp, sourcePort);
    console.log(`DNS allow -> ${domain} (${dnsResponseIp})`);
}

function parseDnsQuery(payload) {
    if (payload.length < 12) {
        return null;
    }

    const id = payload.readUInt16BE(0);
    const flags = payload.readUInt16BE(2);
    const qdcount = payload.readUInt16BE(4);

    if (qdcount < 1) {
        return null;
    }

    let offset = 12;
    const labels = [];

    while (offset < payload.length) {
        const length = payload[offset];
        if (length === 0) {
            offset += 1;
            break;
        }
        if ((length & 0xc0) !== 0) {
            return null;
        }
        offset += 1;
        if (offset + length > payload.length) {
            return null;
        }
        labels.push(payload.subarray(offset, offset + length).toString("ascii"));
        offset += length;
    }

    if (offset + 4 > payload.length) {
        return null;
    }

    const qtype = payload.readUInt16BE(offset);
    const qclass = payload.readUInt16BE(offset + 2);
    offset += 4;

    const question = payload.subarray(12, offset);

    return {
        id,
        rd: (flags & 0x0100) !== 0,
        name: labels.join("."),
        qtype,
        qclass,
        question,
    };
}

function buildDnsResponse(query, { rcode, answerIp }) {
    const flags = 0x8000 | (query.rd ? 0x0100 : 0) | (rcode & 0x000f);
    const header = Buffer.alloc(12);
    header.writeUInt16BE(query.id, 0);
    header.writeUInt16BE(flags, 2);
    header.writeUInt16BE(1, 4);
    header.writeUInt16BE(answerIp ? 1 : 0, 6);
    header.writeUInt16BE(0, 8);
    header.writeUInt16BE(0, 10);

    if (!answerIp) {
        return Buffer.concat([header, query.question]);
    }

    const answer = Buffer.alloc(16);
    answer.writeUInt16BE(0xc00c, 0);
    answer.writeUInt16BE(1, 2);
    answer.writeUInt16BE(1, 4);
    answer.writeUInt32BE(60, 6);
    answer.writeUInt16BE(4, 10);
    answerIp.copy(answer, 12);

    return Buffer.concat([header, query.question, answer]);
}

function sendDnsFrame(payload, clientMac, clientIp, clientPort) {
    const udpLength = 8 + payload.length;
    const ipLength = 20 + udpLength;

    const udpHeader = Buffer.alloc(8);
    udpHeader.writeUInt16BE(53, 0);
    udpHeader.writeUInt16BE(clientPort, 2);
    udpHeader.writeUInt16BE(udpLength, 4);
    udpHeader.writeUInt16BE(0, 6);

    const ipHeader = Buffer.alloc(20);
    ipHeader.writeUInt8(0x45, 0);
    ipHeader.writeUInt8(0, 1);
    ipHeader.writeUInt16BE(ipLength, 2);
    ipHeader.writeUInt16BE(0, 4);
    ipHeader.writeUInt16BE(0, 6);
    ipHeader.writeUInt8(64, 8);
    ipHeader.writeUInt8(17, 9);
    hostIpBytes.copy(ipHeader, 12);
    clientIp.copy(ipHeader, 16);
    ipHeader.writeUInt16BE(0, 10);
    const ipChecksum = computeChecksum(ipHeader);
    ipHeader.writeUInt16BE(ipChecksum, 10);

    const ethernet = Buffer.alloc(14);
    clientMac.copy(ethernet, 0);
    hostMacBytes.copy(ethernet, 6);
    ethernet.writeUInt16BE(0x0800, 12);

    const frame = Buffer.concat([ethernet, ipHeader, udpHeader, payload]);
    sendFrame(frame);
}

function parseDhcpOptions(buffer) {
    let offset = 0;
    let messageType;
    let requestedIp;

    while (offset < buffer.length) {
        const code = buffer[offset++];
        if (code === 0) {
            continue;
        }
        if (code === 255) {
            break;
        }
        if (offset >= buffer.length) {
            break;
        }
        const length = buffer[offset++];
        if (offset + length > buffer.length) {
            break;
        }
        const value = buffer.subarray(offset, offset + length);
        offset += length;

        if (code === 53 && length === 1) {
            messageType = value[0];
        } else if (code === 50 && length === 4) {
            requestedIp = Buffer.from(value);
        }
    }

    return { messageType, requestedIp };
}

function buildDhcpReply({ messageType, xid, flags, clientMac, yiaddr }) {
    const bootp = Buffer.alloc(236, 0);
    bootp[0] = 2;
    bootp[1] = 1;
    bootp[2] = 6;
    bootp[3] = 0;
    bootp.writeUInt32BE(xid, 4);
    bootp.writeUInt16BE(0, 8);
    bootp.writeUInt16BE(flags, 10);
    bootp.writeUInt32BE(0, 12);
    yiaddr.copy(bootp, 16);
    hostIpBytes.copy(bootp, 20);
    bootp.writeUInt32BE(0, 24);
    clientMac.copy(bootp, 28);

    const options = buildDhcpOptions(messageType);
    const cookie = Buffer.from([0x63, 0x82, 0x53, 0x63]);
    return Buffer.concat([bootp, cookie, options]);
}

function buildDhcpOptions(messageType) {
    const lease = 3600;
    const options = [];

    options.push(Buffer.from([53, 1, messageType]));
    options.push(Buffer.from([54, 4, ...hostIpBytes]));
    options.push(Buffer.from([51, 4, (lease >> 24) & 0xff, (lease >> 16) & 0xff, (lease >> 8) & 0xff, lease & 0xff]));
    options.push(Buffer.from([1, 4, 255, 255, 255, 0]));
    options.push(Buffer.from([3, 4, ...hostIpBytes]));
    options.push(Buffer.from([6, 4, ...hostIpBytes]));
    options.push(Buffer.from([255]));

    return Buffer.concat(options);
}

function sendDhcpFrame(payload, clientMac) {
    const udpPayloadLength = payload.length;
    const udpLength = 8 + udpPayloadLength;
    const ipLength = 20 + udpLength;

    const udpHeader = Buffer.alloc(8);
    udpHeader.writeUInt16BE(67, 0);
    udpHeader.writeUInt16BE(68, 2);
    udpHeader.writeUInt16BE(udpLength, 4);
    udpHeader.writeUInt16BE(0, 6);

    const ipHeader = Buffer.alloc(20);
    ipHeader.writeUInt8(0x45, 0);
    ipHeader.writeUInt8(0, 1);
    ipHeader.writeUInt16BE(ipLength, 2);
    ipHeader.writeUInt16BE(0, 4);
    ipHeader.writeUInt16BE(0, 6);
    ipHeader.writeUInt8(64, 8);
    ipHeader.writeUInt8(17, 9);
    hostIpBytes.copy(ipHeader, 12);
    ipHeader.writeUInt32BE(0xffffffff, 16);
    ipHeader.writeUInt16BE(0, 10);
    const ipChecksum = computeChecksum(ipHeader);
    ipHeader.writeUInt16BE(ipChecksum, 10);

    const ethernet = Buffer.alloc(14);
    Buffer.from([0xff, 0xff, 0xff, 0xff, 0xff, 0xff]).copy(ethernet, 0);
    hostMacBytes.copy(ethernet, 6);
    ethernet.writeUInt16BE(0x0800, 12);

    const frame = Buffer.concat([ethernet, ipHeader, udpHeader, payload]);
    sendFrame(frame);
}

function buildArpReply(senderMac, senderIp) {
    const frame = Buffer.alloc(14 + 28);
    senderMac.copy(frame, 0);
    hostMacBytes.copy(frame, 6);
    frame.writeUInt16BE(0x0806, 12);

    const arpOffset = 14;
    frame.writeUInt16BE(1, arpOffset);
    frame.writeUInt16BE(0x0800, arpOffset + 2);
    frame.writeUInt8(6, arpOffset + 4);
    frame.writeUInt8(4, arpOffset + 5);
    frame.writeUInt16BE(2, arpOffset + 6);
    hostMacBytes.copy(frame, arpOffset + 8);
    hostIpBytes.copy(frame, arpOffset + 14);
    senderMac.copy(frame, arpOffset + 18);
    senderIp.copy(frame, arpOffset + 24);

    return frame;
}

function sendFrame(frame) {
    const header = Buffer.alloc(4);
    header.writeUInt32BE(frame.length, 0);
    client.write(Buffer.concat([header, frame]));
}

function sendTcpSegment({ conn, flags, seq, ack, payload }) {
    const tcpHeader = Buffer.alloc(20);
    tcpHeader.writeUInt16BE(80, 0);
    tcpHeader.writeUInt16BE(conn.clientPort, 2);
    tcpHeader.writeUInt32BE(seq, 4);
    tcpHeader.writeUInt32BE(ack, 8);
    tcpHeader.writeUInt8(0x50, 12);
    tcpHeader.writeUInt8(flags, 13);
    tcpHeader.writeUInt16BE(4096, 14);
    tcpHeader.writeUInt16BE(0, 16);
    tcpHeader.writeUInt16BE(0, 18);

    const tcpSegment = Buffer.concat([tcpHeader, payload]);
    const tcpChecksum = computeTcpChecksum(hostIpBytes, conn.clientIp, tcpSegment);
    tcpSegment.writeUInt16BE(tcpChecksum, 16);

    const ipHeader = Buffer.alloc(20);
    ipHeader.writeUInt8(0x45, 0);
    ipHeader.writeUInt8(0, 1);
    ipHeader.writeUInt16BE(20 + tcpSegment.length, 2);
    ipHeader.writeUInt16BE(0, 4);
    ipHeader.writeUInt16BE(0, 6);
    ipHeader.writeUInt8(64, 8);
    ipHeader.writeUInt8(6, 9);
    hostIpBytes.copy(ipHeader, 12);
    conn.clientIp.copy(ipHeader, 16);
    ipHeader.writeUInt16BE(0, 10);
    const ipChecksum = computeChecksum(ipHeader);
    ipHeader.writeUInt16BE(ipChecksum, 10);

    const ethernet = Buffer.alloc(14);
    conn.clientMac.copy(ethernet, 0);
    hostMacBytes.copy(ethernet, 6);
    ethernet.writeUInt16BE(0x0800, 12);

    const frameOut = Buffer.concat([ethernet, ipHeader, tcpSegment]);
    sendFrame(frameOut);
}

function computeChecksum(buffer) {
    let sum = 0;

    for (let i = 0; i < buffer.length; i += 2) {
        let word = buffer[i] << 8;
        if (i + 1 < buffer.length) {
            word |= buffer[i + 1];
        }
        sum += word;
        while (sum > 0xffff) {
            sum = (sum & 0xffff) + (sum >> 16);
        }
    }

    return (~sum) & 0xffff;
}

function computeTcpChecksum(sourceIp, destIp, tcpSegment) {
    const pseudo = Buffer.alloc(12);
    sourceIp.copy(pseudo, 0);
    destIp.copy(pseudo, 4);
    pseudo.writeUInt8(0, 8);
    pseudo.writeUInt8(6, 9);
    pseudo.writeUInt16BE(tcpSegment.length, 10);

    const combined = Buffer.concat([pseudo, tcpSegment]);
    return computeChecksum(combined);
}

function logFrame(frame) {
    const dest = formatMac(frame.subarray(0, 6));
    const source = formatMac(frame.subarray(6, 12));
    const etherType = frame.readUInt16BE(12);
    const typeLabel = etherType === 0x0800 ? "ipv4" : etherType === 0x0806 ? "arp" : "other";

    console.log(`Frame (${frame.length} bytes) ${typeLabel}`);
    console.log(`  dst=${dest} src=${source} type=0x${etherType.toString(16)}`);
}

function formatMac(buffer) {
    return [...buffer].map((byte) => byte.toString(16).padStart(2, "0")).join(":");
}

function formatIp(buffer) {
    return [...buffer].join(".");
}

function ipToBytes(ip) {
    return Buffer.from(ip.split(".").map((part) => Number(part)));
}

function macToBytes(mac) {
    return Buffer.from(mac.split(":").map((part) => Number.parseInt(part, 16)));
}

function isBroadcastIp(buffer) {
    return buffer.length === 4 && buffer[0] === 255 && buffer[1] === 255 && buffer[2] === 255 && buffer[3] === 255;
}

async function waitForSocket(socketFile, seconds) {
    if (fs.existsSync(socketFile)) {
        return;
    }

    if (seconds <= 0) {
        console.error(`Socket not found: ${socketFile}`);
        process.exit(1);
    }

    console.log(`Waiting for socket: ${socketFile}`);

    const deadline = Date.now() + seconds * 1000;

    while (Date.now() < deadline) {
        if (fs.existsSync(socketFile)) {
            return;
        }
        await new Promise((resolve) => setTimeout(resolve, 200));
    }

    console.error(`Socket not found after ${seconds}s: ${socketFile}`);
    process.exit(1);
}

```

scripts/mitm-netdev-sniff.mjs
```
#!/usr/bin/env node
import fs from "node:fs";
import net from "node:net";
import path from "node:path";
import process from "node:process";
import { fileURLToPath } from "node:url";

const scriptDir = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(scriptDir, "..");
const tmpDir = process.env.TMP_DIR ?? path.join(rootDir, "tmp");

fs.mkdirSync(tmpDir, { recursive: true });

const socketPath = process.env.NETDEV_SOCKET ?? process.argv[2] ?? path.join(tmpDir, "piwork-netdev.sock");
const waitSeconds = Number(process.env.WAIT_FOR_SOCKET ?? 10);
const maxFrameSize = Number(process.env.MAX_FRAME_SIZE ?? 65535);

await waitForSocket(socketPath, waitSeconds);

const client = net.createConnection(socketPath);
let pending = Buffer.alloc(0);

client.on("connect", () => {
    console.log(`Connected to ${socketPath}`);
});

client.on("error", (error) => {
    console.error("Socket error:", error.message);
    process.exit(1);
});

client.on("data", (chunk) => {
    pending = Buffer.concat([pending, chunk]);
    pending = drainFrames(pending);
});

function drainFrames(buffer) {
    let offset = 0;

    while (buffer.length - offset >= 4) {
        const frameLength = buffer.readUInt32BE(offset);

        if (frameLength > maxFrameSize) {
            console.error(`Frame length ${frameLength} exceeds max ${maxFrameSize}. Resetting buffer.`);
            return Buffer.alloc(0);
        }

        if (buffer.length - offset < 4 + frameLength) {
            break;
        }

        const frame = buffer.subarray(offset + 4, offset + 4 + frameLength);
        logFrame(frame);
        offset += 4 + frameLength;
    }

    return buffer.subarray(offset);
}

function logFrame(frame) {
    if (frame.length < 14) {
        console.log(`Frame (${frame.length} bytes):`, frame.toString("hex"));
        return;
    }

    const dest = formatMac(frame.subarray(0, 6));
    const source = formatMac(frame.subarray(6, 12));
    const etherType = frame.readUInt16BE(12);

    const typeLabel = etherType === 0x0800 ? "ipv4" : etherType === 0x0806 ? "arp" : "other";

    console.log(`Frame (${frame.length} bytes) ${typeLabel}`);
    console.log(`  dst=${dest} src=${source} type=0x${etherType.toString(16)}`);

    if (etherType === 0x0800 && frame.length >= 34) {
        const ipHeaderOffset = 14;
        const ipHeaderLength = (frame[ipHeaderOffset] & 0x0f) * 4;
        const protocol = frame[ipHeaderOffset + 9];
        const sourceIp = formatIp(frame.subarray(ipHeaderOffset + 12, ipHeaderOffset + 16));
        const destIp = formatIp(frame.subarray(ipHeaderOffset + 16, ipHeaderOffset + 20));

        console.log(`  ip ${sourceIp} -> ${destIp} proto=${protocol}`);

        if (protocol === 6 && frame.length >= ipHeaderOffset + ipHeaderLength + 4) {
            const tcpOffset = ipHeaderOffset + ipHeaderLength;
            const sourcePort = frame.readUInt16BE(tcpOffset);
            const destPort = frame.readUInt16BE(tcpOffset + 2);

            console.log(`  tcp ${sourcePort} -> ${destPort}`);
        }
    }
}

function formatMac(buffer) {
    return [...buffer].map((byte) => byte.toString(16).padStart(2, "0")).join(":");
}

function formatIp(buffer) {
    return [...buffer].join(".");
}

async function waitForSocket(socketFile, seconds) {
    if (fs.existsSync(socketFile)) {
        return;
    }

    if (seconds <= 0) {
        console.error(`Socket not found: ${socketFile}`);
        process.exit(1);
    }

    console.log(`Waiting for socket: ${socketFile}`);

    const deadline = Date.now() + seconds * 1000;

    while (Date.now() < deadline) {
        if (fs.existsSync(socketFile)) {
            return;
        }
        await new Promise((resolve) => setTimeout(resolve, 200));
    }

    console.error(`Socket not found after ${seconds}s: ${socketFile}`);
    process.exit(1);
}

```

scripts/run-mitm-qemu.sh
```
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
ROOT_DIR=$(cd "$SCRIPT_DIR/.." && pwd)
TMP_DIR=${TMP_DIR:-$ROOT_DIR/tmp}
ALPINE_ISO=${ALPINE_ISO:-$TMP_DIR/alpine-virt-3.23.3-aarch64.iso}
NETDEV_SOCKET=${NETDEV_SOCKET:-$TMP_DIR/piwork-netdev.sock}
EFI_BIOS=${EFI_BIOS:-/opt/homebrew/share/qemu/edk2-aarch64-code.fd}
KERNEL_IMAGE=${ALPINE_KERNEL:-$TMP_DIR/boot/vmlinuz-virt}
INITRD_IMAGE=${ALPINE_INITRD:-$TMP_DIR/boot/initramfs-virt}
INITRD_FAST=${ALPINE_INITRD_FAST:-$TMP_DIR/boot/initramfs-virt-fast}
KERNEL_CMDLINE_FILE=${KERNEL_CMDLINE_FILE:-$TMP_DIR/alpine-kernel.cmdline}
KERNEL_CMDLINE=${KERNEL_CMDLINE:-"modules=loop,squashfs,sd-mod,usb-storage quiet console=ttyAMA0"}

mkdir -p "$TMP_DIR"

if [[ -z "$ALPINE_ISO" ]]; then
    echo "Set ALPINE_ISO to an Alpine aarch64 ISO path." >&2
    echo "Example: export ALPINE_ISO=$TMP_DIR/alpine-virt-3.23.3-aarch64.iso" >&2
    exit 1
fi

if [[ ! -f "$ALPINE_ISO" ]]; then
    echo "ISO not found: $ALPINE_ISO" >&2
    exit 1
fi

if [[ ! -f "$EFI_BIOS" ]]; then
    echo "UEFI firmware not found: $EFI_BIOS" >&2
    exit 1
fi

cleanup() {
    rm -f "$NETDEV_SOCKET"
}

trap cleanup EXIT

rm -f "$NETDEV_SOCKET"

if [[ -f "$KERNEL_CMDLINE_FILE" ]]; then
    KERNEL_CMDLINE=$(cat "$KERNEL_CMDLINE_FILE")
fi

if [[ -f "$KERNEL_IMAGE" && -f "$INITRD_FAST" ]]; then
    INITRD_IMAGE="$INITRD_FAST"
fi

if [[ -f "$KERNEL_IMAGE" && -f "$INITRD_IMAGE" ]]; then
    qemu-system-aarch64 \
        -machine virt,accel=hvf \
        -cpu host \
        -smp 2 \
        -m 1024 \
        -nographic \
        -kernel "$KERNEL_IMAGE" \
        -initrd "$INITRD_IMAGE" \
        -append "$KERNEL_CMDLINE" \
        -cdrom "$ALPINE_ISO" \
        -device virtio-net-pci,netdev=net0,mac=52:54:00:12:34:56 \
        -netdev stream,id=net0,server=on,addr.type=unix,addr.path="$NETDEV_SOCKET" \
        -serial mon:stdio
    exit 0
fi

qemu-system-aarch64 \
    -machine virt,accel=hvf \
    -cpu host \
    -smp 2 \
    -m 1024 \
    -nographic \
    -bios "$EFI_BIOS" \
    -cdrom "$ALPINE_ISO" \
    -device virtio-net-pci,netdev=net0,mac=52:54:00:12:34:56 \
    -netdev stream,id=net0,server=on,addr.type=unix,addr.path="$NETDEV_SOCKET" \
    -serial mon:stdio

```

scripts/run-mitm-spike.sh
```
#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
ROOT_DIR=$(cd "$SCRIPT_DIR/.." && pwd)
TMP_DIR=${TMP_DIR:-$ROOT_DIR/tmp}
ALPINE_ISO=${ALPINE_ISO:-$TMP_DIR/alpine-virt-3.23.3-aarch64.iso}
NETDEV_SOCKET=${NETDEV_SOCKET:-$TMP_DIR/piwork-netdev.sock}
HOST_LOG=${HOST_LOG:-$TMP_DIR/mitm-netdev.log}
QEMU_LOG=${QEMU_LOG:-$TMP_DIR/mitm-qemu.log}
BOOT_LOG=${BOOT_LOG:-$TMP_DIR/mitm-boot.log}

mkdir -p "$TMP_DIR"

if [[ ! -f "$ALPINE_ISO" ]]; then
    echo "ISO not found: $ALPINE_ISO" >&2
    echo "Download to tmp/ first (see docs/network-mitm-spike.md)." >&2
    exit 1
fi

"$SCRIPT_DIR/prepare-alpine-kernel.sh"
"$SCRIPT_DIR/prepare-alpine-fastinit.sh"

cleanup() {
    if [[ -n "${HOST_PID:-}" ]]; then
        kill "$HOST_PID" 2>/dev/null || true
    fi
}

trap cleanup EXIT

NETDEV_SOCKET="$NETDEV_SOCKET" \
    HOST_IP=192.168.100.1 \
    HOST_MAC=02:50:00:00:00:01 \
    ALLOWED_DOMAINS=example.com \
    DNS_RESPONSE_IP=192.168.100.1 \
    node "$SCRIPT_DIR/mitm-netdev-host.mjs" > "$HOST_LOG" 2>&1 &
HOST_PID=$!

TMP_DIR="$TMP_DIR" NETDEV_SOCKET="$NETDEV_SOCKET" expect <<EOF > "$BOOT_LOG"
set timeout 120
log_user 0
set start [clock milliseconds]
log_file -a $QEMU_LOG
spawn $SCRIPT_DIR/run-mitm-qemu.sh
expect {
    -re "READY" {
        set end [clock milliseconds]
        set delta [expr {\$end - \$start}]
        send_user "BOOT_MS=\$delta\n"
    }
    timeout {
        send_user "BOOT_TIMEOUT\n"
        exit 1
    }
}
expect -re "#"
send "nslookup example.com\r"
expect -re "#"
send "wget -qO- -T 5 -t 1 http://example.com\r"
expect -re "#"
send "ping -c 1 192.168.100.1\r"
expect -re "#"
send "poweroff\r"
expect eof
EOF

if [[ -f "$BOOT_LOG" ]]; then
    cat "$BOOT_LOG"
fi

```

scripts/windowlist.swift
```
// Finds Piwork window ID without stealing focus
// Outputs the main window (largest) ID

import Cocoa

let options = CGWindowListOption(arrayLiteral: .excludeDesktopElements)
guard let windowList = CGWindowListCopyWindowInfo(options, kCGNullWindowID) as? [[String: Any]] else {
    exit(1)
}

var bestWindow: (id: Int, area: Int) = (0, 0)

for window in windowList {
    guard let ownerName = window[kCGWindowOwnerName as String] as? String,
          let windowNumber = window[kCGWindowNumber as String] as? Int,
          ownerName.lowercased() == "piwork",
          let bounds = window[kCGWindowBounds as String] as? [String: Any],
          let width = bounds["Width"] as? Int,
          let height = bounds["Height"] as? Int else {
        continue
    }
    
    let area = width * height
    if area > bestWindow.area {
        bestWindow = (windowNumber, area)
    }
}

if bestWindow.id != 0 {
    print(bestWindow.id)
    exit(0)
}

exit(1)

```

src-tauri/Cargo.toml
```
[package]
name = "piwork"
version = "0.1.0"
description = "A Tauri App"
authors = ["you"]
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
# The `_lib` suffix may seem redundant but it is necessary
# to make the lib name unique and wouldn't conflict with the bin name.
# This seems to be only an issue on Windows, see https://github.com/rust-lang/cargo/issues/8519
name = "piwork_lib"
crate-type = ["staticlib", "cdylib", "rlib"]

[build-dependencies]
tauri-build = { version = "2", features = [] }

[dependencies]
tauri = { version = "2", features = [] }
tauri-plugin-opener = "2"
serde = { version = "1", features = ["derive"] }
base64 = "0.22"
serde_json = "1"
tauri-plugin-dialog = "2.6.0"


```

src-tauri/build.rs
```
fn main() {
    tauri_build::build();
}

```

src-tauri/capabilities/default.json
```
{
    "$schema": "../gen/schemas/desktop-schema.json",
    "identifier": "default",
    "description": "Capability for the main window",
    "windows": ["main"],
    "permissions": ["core:default", "dialog:default", "opener:default", "opener:allow-open-path"]
}

```

src-tauri/src/auth_store.rs
```
use serde::Serialize;
use serde_json::{Map, Value};
use std::path::Path;

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct AuthStoreEntry {
    pub provider: String,
    pub entry_type: String,
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct AuthStoreSummary {
    pub path: String,
    pub entries: Vec<AuthStoreEntry>,
}

pub fn summary(path: &Path) -> Result<AuthStoreSummary, String> {
    let map = read_map(path)?;
    let mut entries: Vec<AuthStoreEntry> = map
        .into_iter()
        .map(|(provider, value)| AuthStoreEntry {
            provider,
            entry_type: entry_type(&value),
        })
        .collect();

    entries.sort_by(|a, b| a.provider.cmp(&b.provider));

    Ok(AuthStoreSummary {
        path: path.to_string_lossy().to_string(),
        entries,
    })
}

pub fn set_api_key(path: &Path, provider: &str, key: &str) -> Result<(), String> {
    if provider.trim().is_empty() {
        return Err("Provider is required".to_string());
    }

    if key.trim().is_empty() {
        return Err("API key is required".to_string());
    }

    let mut map = read_map(path)?;
    map.insert(provider.to_string(), serde_json::json!({"type": "api_key", "key": key}));

    write_map(path, map)
}

pub fn delete_provider(path: &Path, provider: &str) -> Result<(), String> {
    let mut map = read_map(path)?;
    map.remove(provider);

    write_map(path, map)
}

pub fn import_from_path(dest_path: &Path, source_path: &Path) -> Result<(), String> {
    if !source_path.exists() {
        return Err(format!("Auth file not found at {}", source_path.display()));
    }

    let source_map = read_map(source_path)?;
    if source_map.is_empty() {
        return Err("Source auth file is empty".to_string());
    }

    let mut dest_map = read_map(dest_path)?;
    dest_map.extend(source_map);

    write_map(dest_path, dest_map)
}

fn read_map(path: &Path) -> Result<Map<String, Value>, String> {
    if !path.exists() {
        return Ok(Map::new());
    }

    let content = std::fs::read_to_string(path).map_err(|error| error.to_string())?;
    let value: Value = serde_json::from_str(&content).map_err(|error| error.to_string())?;

    match value {
        Value::Object(map) => Ok(map),
        _ => Err("auth.json must be a JSON object".to_string()),
    }
}

fn write_map(path: &Path, map: Map<String, Value>) -> Result<(), String> {
    let parent = path.parent().ok_or_else(|| "Invalid auth path".to_string())?;
    std::fs::create_dir_all(parent).map_err(|error| error.to_string())?;

    if map.is_empty() {
        if path.exists() {
            std::fs::remove_file(path).map_err(|error| error.to_string())?;
        }
        return Ok(());
    }

    let content = serde_json::to_string_pretty(&Value::Object(map)).map_err(|error| error.to_string())?;
    std::fs::write(path, content).map_err(|error| error.to_string())?;

    set_permissions(path);

    Ok(())
}

fn entry_type(value: &Value) -> String {
    value
        .get("type")
        .and_then(|value| value.as_str())
        .unwrap_or("unknown")
        .to_string()
}

fn set_permissions(path: &Path) {
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let permissions = std::fs::Permissions::from_mode(0o600);
        let _ = std::fs::set_permissions(path, permissions);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::time::{SystemTime, UNIX_EPOCH};

    static TEMP_COUNTER: AtomicUsize = AtomicUsize::new(0);

    fn temp_path() -> PathBuf {
        let suffix = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos();
        let counter = TEMP_COUNTER.fetch_add(1, Ordering::Relaxed);
        let dir = std::env::temp_dir().join(format!("piwork-auth-store-{suffix}-{counter}"));
        dir.join("auth.json")
    }

    #[test]
    fn set_and_list_entries() {
        let path = temp_path();

        set_api_key(&path, "anthropic", "test-key").expect("set");
        let summary = summary(&path).expect("summary");

        assert_eq!(summary.entries.len(), 1);
        assert_eq!(summary.entries[0].provider, "anthropic");
        assert_eq!(summary.entries[0].entry_type, "api_key");

        std::fs::remove_dir_all(path.parent().unwrap()).ok();
    }

    #[test]
    fn delete_entry_removes_file() {
        let path = temp_path();

        set_api_key(&path, "openai", "test-key").expect("set");
        delete_provider(&path, "openai").expect("delete");

        let summary = summary(&path).expect("summary");
        assert!(summary.entries.is_empty());
        assert!(!path.exists());

        std::fs::remove_dir_all(path.parent().unwrap()).ok();
    }

    #[test]
    fn import_merges_entries() {
        let source = temp_path();
        let dest = temp_path();

        set_api_key(&source, "anthropic", "source-key").expect("set source");
        set_api_key(&dest, "openai", "dest-key").expect("set dest");

        import_from_path(&dest, &source).expect("import");

        let summary = summary(&dest).expect("summary");
        assert_eq!(summary.entries.len(), 2);

        std::fs::remove_dir_all(source.parent().unwrap()).ok();
        std::fs::remove_dir_all(dest.parent().unwrap()).ok();
    }
}

```

src-tauri/src/lib.rs
```
use base64::{engine::general_purpose::STANDARD as BASE64_STANDARD, Engine as _};
use std::io::{BufRead, BufReader, Write};
use std::net::TcpListener;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::time::UNIX_EPOCH;
use tauri::{Emitter, Manager};

mod auth_store;
mod task_store;
mod vm;

const RUNTIME_MANIFEST: &str = "manifest.json";
const RUNTIME_ENV_VAR: &str = "PIWORK_RUNTIME_DIR";
const WORKSPACE_ROOT_ENV_VAR: &str = "PIWORK_WORKSPACE_ROOT";
const AUTH_PROFILE_DEFAULT: &str = "default";

#[derive(Debug, serde::Serialize)]
#[serde(rename_all = "snake_case")]
enum RuntimeState {
    Ready,
    Missing,
}

#[derive(serde::Serialize)]
#[serde(rename_all = "camelCase")]
struct RuntimeStatus {
    status: RuntimeState,
    runtime_dir: String,
    manifest_path: String,
    qemu_available: bool,
    qemu_path: Option<String>,
    accel_available: Option<bool>,
}

#[derive(serde::Serialize)]
#[serde(rename_all = "camelCase")]
struct WorkingFolderValidation {
    folder: String,
    workspace_root: String,
    relative_path: String,
}

#[derive(serde::Serialize)]
#[serde(rename_all = "camelCase")]
struct PreviewFileEntry {
    path: String,
    size: u64,
    modified_at: u64,
}

#[derive(serde::Serialize)]
#[serde(rename_all = "camelCase")]
struct PreviewListResponse {
    root: String,
    files: Vec<PreviewFileEntry>,
    truncated: bool,
}

#[derive(serde::Serialize)]
#[serde(rename_all = "camelCase")]
struct PreviewReadResponse {
    path: String,
    mime_type: String,
    encoding: String,
    content: String,
    truncated: bool,
    size: u64,
}

#[derive(serde::Serialize)]
#[serde(rename_all = "camelCase")]
struct ArtifactFileEntry {
    source: String,
    path: String,
    size: u64,
    modified_at: u64,
    read_only: bool,
}

#[derive(serde::Serialize)]
#[serde(rename_all = "camelCase")]
struct ArtifactListResponse {
    files: Vec<ArtifactFileEntry>,
    truncated: bool,
}

#[tauri::command]
fn dev_log(source: &str, message: &str) {
    eprintln!("[{source}] {message}");
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn runtime_status(app: tauri::AppHandle) -> Result<RuntimeStatus, String> {
    eprintln!("[rust] runtime_status called");
    let runtime_dir = runtime_dir(&app)?;
    std::fs::create_dir_all(&runtime_dir).map_err(|error| error.to_string())?;

    let manifest_path = runtime_dir.join(RUNTIME_MANIFEST);
    let status = if manifest_path.exists() {
        RuntimeState::Ready
    } else {
        RuntimeState::Missing
    };

    let qemu_path = find_qemu_binary(&runtime_dir, &manifest_path);
    let qemu_available = qemu_path.is_some();
    let accel_available = check_accel_available();
    eprintln!("[rust] runtime_status returning status={status:?}");

    Ok(RuntimeStatus {
        status,
        runtime_dir: runtime_dir.to_string_lossy().to_string(),
        manifest_path: manifest_path.to_string_lossy().to_string(),
        qemu_available,
        qemu_path: qemu_path.map(|path| path.to_string_lossy().to_string()),
        accel_available,
    })
}

fn find_qemu_binary(runtime_dir: &Path, manifest_path: &Path) -> Option<PathBuf> {
    if manifest_path.exists() {
        if let Ok(content) = std::fs::read_to_string(manifest_path) {
            if let Ok(manifest) = serde_json::from_str::<vm::RuntimeManifest>(&content) {
                if let Some(qemu) = manifest.qemu {
                    let candidate = runtime_dir.join(qemu);
                    if candidate.is_file() {
                        return Some(candidate);
                    }
                }
            }
        }
    }

    vm::find_in_path("qemu-system-aarch64")
}

fn check_accel_available() -> Option<bool> {
    if cfg!(target_os = "macos") {
        let output = Command::new("sysctl").arg("-n").arg("kern.hv_support").output().ok()?;
        let value = String::from_utf8_lossy(&output.stdout).trim().to_string();
        return Some(value == "1");
    }

    None
}

fn canonicalize_directory(path: &Path, label: &str) -> Result<PathBuf, String> {
    let metadata = std::fs::symlink_metadata(path).map_err(|error| format!("{label} not found: {error}"))?;
    if metadata.file_type().is_symlink() {
        return Err(format!("{label} must not be a symlink"));
    }

    let canonical = std::fs::canonicalize(path).map_err(|error| format!("Failed to resolve {label}: {error}"))?;
    let canonical_metadata =
        std::fs::metadata(&canonical).map_err(|error| format!("Failed to stat {label}: {error}"))?;

    if !canonical_metadata.is_dir() {
        return Err(format!("{label} must be a directory"));
    }

    Ok(canonical)
}

fn resolve_workspace_root_from_env() -> Result<Option<PathBuf>, String> {
    let Ok(raw_root) = std::env::var(WORKSPACE_ROOT_ENV_VAR) else {
        return Ok(None);
    };

    let trimmed = raw_root.trim();
    if trimmed.is_empty() {
        return Ok(None);
    }

    let canonical = canonicalize_directory(Path::new(trimmed), "workspace root")?;
    Ok(Some(canonical))
}

fn relative_path_string(root: &Path, candidate: &Path) -> Result<String, String> {
    let relative = candidate
        .strip_prefix(root)
        .map_err(|_| "Working folder is outside workspace root".to_string())?;

    let parts: Vec<String> = relative
        .components()
        .filter_map(|component| match component {
            std::path::Component::Normal(value) => Some(value.to_string_lossy().to_string()),
            _ => None,
        })
        .collect();

    Ok(parts.join("/"))
}

#[tauri::command]
fn runtime_workspace_root() -> Result<Option<String>, String> {
    let root = resolve_workspace_root_from_env()?;
    Ok(root.map(|path| path.to_string_lossy().to_string()))
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn runtime_validate_working_folder(
    folder: String,
    workspace_root: Option<String>,
) -> Result<WorkingFolderValidation, String> {
    let trimmed_folder = folder.trim();
    if trimmed_folder.is_empty() {
        return Err("Working folder is required".to_string());
    }

    let canonical_folder = canonicalize_directory(Path::new(trimmed_folder), "working folder")?;

    let canonical_root = if let Some(root) = workspace_root.as_deref() {
        let trimmed_root = root.trim();
        if trimmed_root.is_empty() {
            canonical_folder.clone()
        } else {
            canonicalize_directory(Path::new(trimmed_root), "workspace root")?
        }
    } else if let Some(env_root) = resolve_workspace_root_from_env()? {
        env_root
    } else {
        canonical_folder.clone()
    };

    if !canonical_folder.starts_with(&canonical_root) {
        return Err("Working folder must be within workspace root".to_string());
    }

    let relative_path = relative_path_string(&canonical_root, &canonical_folder)?;

    Ok(WorkingFolderValidation {
        folder: canonical_folder.to_string_lossy().to_string(),
        workspace_root: canonical_root.to_string_lossy().to_string(),
        relative_path,
    })
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn open_path_in_finder(path: String) -> Result<(), String> {
    let trimmed = path.trim();
    if trimmed.is_empty() {
        return Err("Path is required".to_string());
    }

    let target = Path::new(trimmed);
    if !target.exists() {
        return Err(format!("Path does not exist: {trimmed}"));
    }

    #[cfg(target_os = "macos")]
    {
        let status = Command::new("open")
            .arg(target)
            .status()
            .map_err(|error| format!("Failed to open path in Finder: {error}"))?;

        if !status.success() {
            return Err(format!("Finder failed to open path: {trimmed}"));
        }

        return Ok(());
    }

    #[cfg(target_os = "linux")]
    {
        let status = Command::new("xdg-open")
            .arg(target)
            .status()
            .map_err(|error| format!("Failed to open path: {error}"))?;

        if !status.success() {
            return Err(format!("Failed to open path: {trimmed}"));
        }

        return Ok(());
    }

    #[cfg(target_os = "windows")]
    {
        let status = Command::new("cmd")
            .args(["/C", "start", "", trimmed])
            .status()
            .map_err(|error| format!("Failed to open path: {error}"))?;

        if !status.success() {
            return Err(format!("Failed to open path: {trimmed}"));
        }

        return Ok(());
    }

    #[allow(unreachable_code)]
    Err("Open in file explorer is not supported on this platform".to_string())
}

fn resolve_task_preview_root(app: &tauri::AppHandle, task_id: &str) -> Result<PathBuf, String> {
    if !is_valid_task_id(task_id) {
        return Err("Invalid task id".to_string());
    }

    let tasks_path = tasks_dir(app)?;
    let task = task_store::load_task(&tasks_path, task_id)?.ok_or_else(|| "Task not found".to_string())?;

    if let Some(working_folder) = task.working_folder {
        let validated = runtime_validate_working_folder(working_folder, None)?;
        return Ok(PathBuf::from(validated.folder));
    }

    task_store::ensure_task_artifact_dirs(&tasks_path, task_id)?;
    Ok(task_store::task_outputs_dir(&tasks_path, task_id))
}

fn resolve_task_artifact_dirs(app: &tauri::AppHandle, task_id: &str) -> Result<(PathBuf, PathBuf), String> {
    if !is_valid_task_id(task_id) {
        return Err("Invalid task id".to_string());
    }

    let tasks_path = tasks_dir(app)?;
    task_store::load_task(&tasks_path, task_id)?.ok_or_else(|| "Task not found".to_string())?;
    task_store::ensure_task_artifact_dirs(&tasks_path, task_id)?;

    Ok((
        task_store::task_outputs_dir(&tasks_path, task_id),
        task_store::task_uploads_dir(&tasks_path, task_id),
    ))
}

#[derive(Clone, Copy)]
enum ArtifactSource {
    Outputs,
    Uploads,
}

impl ArtifactSource {
    fn parse(raw: &str) -> Result<Self, String> {
        match raw {
            "outputs" => Ok(Self::Outputs),
            "uploads" => Ok(Self::Uploads),
            _ => Err("source must be either 'outputs' or 'uploads'".to_string()),
        }
    }

    fn as_str(self) -> &'static str {
        match self {
            Self::Outputs => "outputs",
            Self::Uploads => "uploads",
        }
    }

    fn read_only(self) -> bool {
        matches!(self, Self::Uploads)
    }
}

fn normalize_preview_relative_path(relative_path: &str) -> Result<PathBuf, String> {
    let trimmed = relative_path.trim();
    if trimmed.is_empty() {
        return Err("relativePath is required".to_string());
    }

    if trimmed.contains('\0') || trimmed.contains('\\') {
        return Err("Invalid relativePath".to_string());
    }

    let path = Path::new(trimmed);
    if path.is_absolute() {
        return Err("relativePath must be relative".to_string());
    }

    let mut normalized = PathBuf::new();
    for component in path.components() {
        match component {
            std::path::Component::Normal(segment) => normalized.push(segment),
            std::path::Component::CurDir => {}
            std::path::Component::ParentDir => {
                return Err("relativePath must not traverse parent directories".to_string())
            }
            std::path::Component::RootDir | std::path::Component::Prefix(_) => {
                return Err("Invalid relativePath".to_string())
            }
        }
    }

    if normalized.as_os_str().is_empty() {
        return Err("relativePath is required".to_string());
    }

    Ok(normalized)
}

fn path_within_root(root: &Path, candidate: &Path) -> bool {
    candidate.strip_prefix(root).is_ok()
}

fn collect_regular_files(root: &Path, max_files: usize, max_depth: usize) -> (Vec<PreviewFileEntry>, bool) {
    if !root.is_dir() {
        return (Vec::new(), false);
    }

    let mut files: Vec<PreviewFileEntry> = Vec::new();
    let mut stack: Vec<(PathBuf, usize)> = vec![(root.to_path_buf(), 0)];
    let mut truncated = false;

    while let Some((dir, depth)) = stack.pop() {
        let Ok(entries) = std::fs::read_dir(&dir) else {
            continue;
        };

        for entry in entries.flatten() {
            let path = entry.path();
            let Ok(metadata) = std::fs::symlink_metadata(&path) else {
                continue;
            };

            if metadata.file_type().is_symlink() {
                continue;
            }

            if metadata.is_dir() {
                if depth < max_depth {
                    stack.push((path, depth + 1));
                }
                continue;
            }

            if !metadata.is_file() {
                continue;
            }

            let Ok(relative) = path.strip_prefix(root) else {
                continue;
            };

            let relative_str = relative
                .components()
                .filter_map(|component| match component {
                    std::path::Component::Normal(value) => Some(value.to_string_lossy().to_string()),
                    _ => None,
                })
                .collect::<Vec<String>>()
                .join("/");

            if relative_str.is_empty() {
                continue;
            }

            let modified_at = metadata
                .modified()
                .ok()
                .and_then(|value| value.duration_since(UNIX_EPOCH).ok())
                .map_or(0, |value| value.as_secs());

            files.push(PreviewFileEntry {
                path: relative_str,
                size: metadata.len(),
                modified_at,
            });

            if files.len() >= max_files {
                truncated = true;
                break;
            }
        }

        if truncated {
            break;
        }
    }

    files.sort_by(|a, b| a.path.cmp(&b.path));
    (files, truncated)
}

fn detect_mime_type(path: &Path) -> &'static str {
    match path
        .extension()
        .and_then(|value| value.to_str())
        .map(str::to_ascii_lowercase)
    {
        Some(ext)
            if [
                "md", "txt", "rs", "ts", "tsx", "js", "jsx", "toml", "yaml", "yml", "css", "svelte", "sh",
            ]
            .contains(&ext.as_str()) =>
        {
            "text/plain"
        }
        Some(ext) if ext == "json" => "application/json",
        Some(ext) if ext == "csv" => "text/csv",
        Some(ext) if ext == "html" || ext == "htm" => "text/html",
        Some(ext) if ext == "png" => "image/png",
        Some(ext) if ext == "jpg" || ext == "jpeg" => "image/jpeg",
        Some(ext) if ext == "gif" => "image/gif",
        Some(ext) if ext == "webp" => "image/webp",
        Some(ext) if ext == "svg" => "image/svg+xml",
        _ => "application/octet-stream",
    }
}

fn is_probably_text(bytes: &[u8]) -> bool {
    if bytes.contains(&0) {
        return false;
    }

    std::str::from_utf8(bytes).is_ok()
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_preview_list(app: tauri::AppHandle, task_id: String) -> Result<PreviewListResponse, String> {
    const MAX_FILES: usize = 300;
    const MAX_DEPTH: usize = 6;

    let root = resolve_task_preview_root(&app, &task_id)?;
    let (files, truncated) = collect_regular_files(&root, MAX_FILES, MAX_DEPTH);

    Ok(PreviewListResponse {
        root: root.to_string_lossy().to_string(),
        files,
        truncated,
    })
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_preview_read(
    app: tauri::AppHandle,
    task_id: String,
    relative_path: String,
) -> Result<PreviewReadResponse, String> {
    const MAX_PREVIEW_BYTES: usize = 256 * 1024;

    let root = resolve_task_preview_root(&app, &task_id)?;
    let relative = normalize_preview_relative_path(&relative_path)?;
    let candidate = root.join(&relative);

    let metadata = std::fs::symlink_metadata(&candidate).map_err(|_| "File not found".to_string())?;
    if metadata.file_type().is_symlink() {
        return Err("Symlink previews are not allowed".to_string());
    }

    if !metadata.is_file() {
        return Err("Only regular files can be previewed".to_string());
    }

    let canonical = std::fs::canonicalize(&candidate).map_err(|_| "Failed to resolve file path".to_string())?;
    if !path_within_root(&root, &canonical) {
        return Err("File is outside task working folder".to_string());
    }

    let bytes = std::fs::read(&candidate).map_err(|error| error.to_string())?;
    let size = bytes.len() as u64;
    let truncated = bytes.len() > MAX_PREVIEW_BYTES;
    let preview_slice = if truncated {
        &bytes[..MAX_PREVIEW_BYTES]
    } else {
        bytes.as_slice()
    };

    let mime_type = detect_mime_type(&candidate).to_string();

    let (encoding, content) = if mime_type.starts_with("image/") {
        ("base64".to_string(), BASE64_STANDARD.encode(preview_slice))
    } else if is_probably_text(preview_slice) {
        (
            "utf8".to_string(),
            String::from_utf8(preview_slice.to_vec()).map_err(|_| "Invalid UTF-8 text".to_string())?,
        )
    } else {
        ("base64".to_string(), BASE64_STANDARD.encode(preview_slice))
    };

    Ok(PreviewReadResponse {
        path: relative
            .components()
            .filter_map(|component| match component {
                std::path::Component::Normal(value) => Some(value.to_string_lossy().to_string()),
                _ => None,
            })
            .collect::<Vec<String>>()
            .join("/"),
        mime_type,
        encoding,
        content,
        truncated,
        size,
    })
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_artifact_list(app: tauri::AppHandle, task_id: String) -> Result<ArtifactListResponse, String> {
    const MAX_FILES: usize = 300;
    const MAX_DEPTH: usize = 6;

    let (outputs_root, uploads_root) = resolve_task_artifact_dirs(&app, &task_id)?;
    let mut files: Vec<ArtifactFileEntry> = Vec::new();
    let mut truncated = false;

    for (source, root) in [
        (ArtifactSource::Outputs, outputs_root),
        (ArtifactSource::Uploads, uploads_root),
    ] {
        let remaining = MAX_FILES.saturating_sub(files.len());
        if remaining == 0 {
            truncated = true;
            break;
        }

        let (entries, source_truncated) = collect_regular_files(&root, remaining, MAX_DEPTH);
        files.extend(entries.into_iter().map(|entry| ArtifactFileEntry {
            source: source.as_str().to_string(),
            path: entry.path,
            size: entry.size,
            modified_at: entry.modified_at,
            read_only: source.read_only(),
        }));

        if source_truncated {
            truncated = true;
            break;
        }
    }

    files.sort_by(|a, b| a.path.cmp(&b.path).then(a.source.cmp(&b.source)));

    Ok(ArtifactListResponse { files, truncated })
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_artifact_read(
    app: tauri::AppHandle,
    task_id: String,
    source: String,
    relative_path: String,
) -> Result<PreviewReadResponse, String> {
    const MAX_PREVIEW_BYTES: usize = 256 * 1024;

    let source = ArtifactSource::parse(source.trim())?;
    let (outputs_root, uploads_root) = resolve_task_artifact_dirs(&app, &task_id)?;
    let root = match source {
        ArtifactSource::Outputs => outputs_root,
        ArtifactSource::Uploads => uploads_root,
    };

    let relative = normalize_preview_relative_path(&relative_path)?;
    let candidate = root.join(&relative);

    let metadata = std::fs::symlink_metadata(&candidate).map_err(|_| "File not found".to_string())?;
    if metadata.file_type().is_symlink() {
        return Err("Symlink previews are not allowed".to_string());
    }

    if !metadata.is_file() {
        return Err("Only regular files can be previewed".to_string());
    }

    let canonical = std::fs::canonicalize(&candidate).map_err(|_| "Failed to resolve file path".to_string())?;
    if !path_within_root(&root, &canonical) {
        return Err("File is outside task artifact root".to_string());
    }

    let bytes = std::fs::read(&candidate).map_err(|error| error.to_string())?;
    let size = bytes.len() as u64;
    let truncated = bytes.len() > MAX_PREVIEW_BYTES;
    let preview_slice = if truncated {
        &bytes[..MAX_PREVIEW_BYTES]
    } else {
        bytes.as_slice()
    };

    let mime_type = detect_mime_type(&candidate).to_string();

    let (encoding, content) = if mime_type.starts_with("image/") {
        ("base64".to_string(), BASE64_STANDARD.encode(preview_slice))
    } else if is_probably_text(preview_slice) {
        (
            "utf8".to_string(),
            String::from_utf8(preview_slice.to_vec()).map_err(|_| "Invalid UTF-8 text".to_string())?,
        )
    } else {
        ("base64".to_string(), BASE64_STANDARD.encode(preview_slice))
    };

    Ok(PreviewReadResponse {
        path: relative
            .components()
            .filter_map(|component| match component {
                std::path::Component::Normal(value) => Some(value.to_string_lossy().to_string()),
                _ => None,
            })
            .collect::<Vec<String>>()
            .join("/"),
        mime_type,
        encoding,
        content,
        truncated,
        size,
    })
}

fn runtime_dir(app: &tauri::AppHandle) -> Result<PathBuf, String> {
    if let Ok(override_dir) = std::env::var(RUNTIME_ENV_VAR) {
        return Ok(PathBuf::from(override_dir));
    }

    let base_dir = app.path().app_data_dir().map_err(|error| error.to_string())?;
    Ok(base_dir.join("runtime"))
}

fn tasks_dir(app: &tauri::AppHandle) -> Result<PathBuf, String> {
    let base_dir = app.path().app_data_dir().map_err(|error| error.to_string())?;
    Ok(base_dir.join("tasks"))
}

fn normalize_auth_profile_name(profile: Option<&str>) -> Result<String, String> {
    let candidate = profile
        .map(str::trim)
        .filter(|value| !value.is_empty())
        .unwrap_or(AUTH_PROFILE_DEFAULT);

    let is_safe = candidate
        .chars()
        .all(|ch| ch.is_ascii_alphanumeric() || ch == '.' || ch == '_' || ch == '-');

    if !is_safe || candidate.contains("..") {
        return Err("Invalid auth profile".to_string());
    }

    Ok(candidate.to_string())
}

fn auth_file(app: &tauri::AppHandle, profile: Option<&str>) -> Result<PathBuf, String> {
    let base_dir = app.path().app_data_dir().map_err(|error| error.to_string())?;
    let profile = normalize_auth_profile_name(profile)?;
    Ok(base_dir.join("auth").join(profile).join("auth.json"))
}

fn pi_auth_file(app: &tauri::AppHandle) -> Result<PathBuf, String> {
    let home_dir = app.path().home_dir().map_err(|error| error.to_string())?;
    Ok(home_dir.join(".pi").join("agent").join("auth.json"))
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn vm_status(state: tauri::State<vm::VmState>) -> vm::VmStatusResponse {
    vm::status(&state)
}

fn is_valid_task_id(task_id: &str) -> bool {
    !task_id.is_empty() && !task_id.contains('/') && !task_id.contains('\\') && !task_id.contains("..")
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn vm_start(
    app: tauri::AppHandle,
    state: tauri::State<vm::VmState>,
    working_folder: Option<String>,
    task_id: Option<String>,
    auth_profile: Option<String>,
) -> Result<vm::VmStatusResponse, String> {
    let runtime_dir = runtime_dir(&app)?;
    let folder_path = if let Some(workspace_root) = resolve_workspace_root_from_env()? {
        Some(workspace_root)
    } else {
        working_folder.as_ref().map(std::path::PathBuf::from)
    };

    if let Some(task_id) = task_id.as_deref() {
        if !is_valid_task_id(task_id) {
            return Err("Invalid task id".to_string());
        }
    }

    let selected_auth_profile = normalize_auth_profile_name(auth_profile.as_deref())?;

    let auth_state_path = app
        .path()
        .app_data_dir()
        .map_err(|error| error.to_string())?
        .join("auth");
    std::fs::create_dir_all(auth_state_path.join(&selected_auth_profile)).map_err(|error| error.to_string())?;

    let task_state_path = tasks_dir(&app)?;
    std::fs::create_dir_all(&task_state_path).map_err(|error| error.to_string())?;

    vm::start(
        &app,
        &state,
        &runtime_dir,
        folder_path.as_deref(),
        Some(task_state_path.as_path()),
        Some(auth_state_path.as_path()),
        task_id.as_deref(),
        Some(selected_auth_profile.as_str()),
    )
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn vm_stop(state: tauri::State<vm::VmState>) {
    vm::stop(&state);
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn rpc_send(state: tauri::State<vm::VmState>, message: String) -> Result<(), String> {
    vm::send(&state, &message)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_store_list(app: tauri::AppHandle) -> Result<Vec<task_store::TaskMetadata>, String> {
    let tasks_dir = tasks_dir(&app)?;
    task_store::list_tasks(&tasks_dir)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_store_upsert(app: tauri::AppHandle, task: task_store::TaskMetadata) -> Result<(), String> {
    let tasks_dir = tasks_dir(&app)?;
    task_store::upsert_task(&tasks_dir, &task)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_store_delete(app: tauri::AppHandle, task_id: String) -> Result<(), String> {
    let tasks_dir = tasks_dir(&app)?;
    task_store::delete_task(&tasks_dir, task_id)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_store_delete_all(app: tauri::AppHandle) -> Result<(), String> {
    let tasks_dir = tasks_dir(&app)?;
    task_store::delete_all_tasks(&tasks_dir)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_store_save_conversation(
    app: tauri::AppHandle,
    task_id: String,
    conversation_json: String,
) -> Result<(), String> {
    let tasks_dir = tasks_dir(&app)?;
    task_store::save_conversation(&tasks_dir, &task_id, &conversation_json)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn task_store_load_conversation(app: tauri::AppHandle, task_id: String) -> Result<Option<String>, String> {
    let tasks_dir = tasks_dir(&app)?;
    task_store::load_conversation(&tasks_dir, &task_id)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn auth_store_list(app: tauri::AppHandle, profile: Option<String>) -> Result<auth_store::AuthStoreSummary, String> {
    let auth_path = auth_file(&app, profile.as_deref())?;
    auth_store::summary(&auth_path)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn auth_store_set_api_key(
    app: tauri::AppHandle,
    provider: String,
    key: String,
    profile: Option<String>,
) -> Result<auth_store::AuthStoreSummary, String> {
    let auth_path = auth_file(&app, profile.as_deref())?;
    auth_store::set_api_key(&auth_path, &provider, &key)?;
    auth_store::summary(&auth_path)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn auth_store_delete(
    app: tauri::AppHandle,
    provider: String,
    profile: Option<String>,
) -> Result<auth_store::AuthStoreSummary, String> {
    let auth_path = auth_file(&app, profile.as_deref())?;
    auth_store::delete_provider(&auth_path, &provider)?;
    auth_store::summary(&auth_path)
}

#[tauri::command]
#[allow(clippy::needless_pass_by_value)]
fn auth_store_import_pi(
    app: tauri::AppHandle,
    profile: Option<String>,
) -> Result<auth_store::AuthStoreSummary, String> {
    let auth_path = auth_file(&app, profile.as_deref())?;
    let source_path = pi_auth_file(&app)?;
    auth_store::import_from_path(&auth_path, &source_path)?;
    auth_store::summary(&auth_path)
}

#[cfg(debug_assertions)]
fn sanitize_test_server_value(value: &serde_json::Value) -> serde_json::Value {
    match value {
        serde_json::Value::Object(map) => {
            let mut sanitized = serde_json::Map::new();

            for (key, inner) in map {
                let lower = key.to_ascii_lowercase();
                let is_sensitive = lower.contains("key")
                    || lower.contains("token")
                    || lower.contains("password")
                    || lower.contains("secret");

                if is_sensitive {
                    sanitized.insert(key.clone(), serde_json::Value::String("<redacted>".to_string()));
                } else {
                    sanitized.insert(key.clone(), sanitize_test_server_value(inner));
                }
            }

            serde_json::Value::Object(sanitized)
        }
        serde_json::Value::Array(values) => {
            serde_json::Value::Array(values.iter().map(sanitize_test_server_value).collect())
        }
        _ => value.clone(),
    }
}

/// Test server for automated testing (dev mode only)
/// Listens on port `19385` and accepts commands:
/// - `{"cmd":"prompt","message":"..."}` - triggers UI sendPrompt flow
/// - `{"cmd":"set_folder","folder":"/path"}` - sets working folder (one-time bind for active task)
/// - `{"cmd":"set_task","taskId":"..."}` - selects active task
/// - `{"cmd":"set_auth_profile","profile":"default"}` - switches auth profile and restarts runtime in UI
/// - `{"cmd":"send_login"}` - triggers UI /login flow
/// - `{"cmd":"auth_list","profile":"default"}` - returns auth store summary JSON
/// - `{"cmd":"auth_set_api_key","provider":"anthropic","key":"...","profile":"default"}` - writes API key to auth store
/// - `{"cmd":"auth_delete","provider":"anthropic","profile":"default"}` - deletes provider from auth store
/// - `{"cmd":"auth_import_pi","profile":"default"}` - imports ~/.pi/agent/auth.json into auth store
/// - `{"cmd":"create_task","title":"...","workingFolder":"/path"}` - creates task
/// - `{"cmd":"delete_all_tasks"}` - wipes all tasks
/// - `{"cmd":"dump_state"}` - logs UI state
/// - `{"cmd":"preview_list","taskId":"..."}` - returns preview file list JSON
/// - `{"cmd":"preview_read","taskId":"...","relativePath":"..."}` - returns preview file content JSON
/// - `{"cmd":"artifact_list","taskId":"..."}` - returns scratchpad artifact list JSON (`outputs` + `uploads`)
/// - `{"cmd":"artifact_read","taskId":"...","source":"outputs|uploads","relativePath":"..."}` - returns artifact file content JSON
/// - `{"cmd":"open_preview","taskId":"...","relativePath":"..."}` - opens preview pane in UI
/// - `{"cmd":"rpc",...}` - sends raw RPC to VM
#[cfg(debug_assertions)]
#[allow(clippy::too_many_lines)]
fn start_test_server(app_handle: tauri::AppHandle) {
    std::thread::spawn(move || {
        let listener = match TcpListener::bind("127.0.0.1:19385") {
            Ok(l) => l,
            Err(e) => {
                eprintln!("[test-server] failed to bind: {e}");
                return;
            }
        };
        eprintln!("[test-server] listening on 127.0.0.1:19385");

        for stream in listener.incoming() {
            let Ok(mut stream) = stream else { continue };
            let app = app_handle.clone();

            std::thread::spawn(move || {
                let reader = BufReader::new(stream.try_clone().unwrap());
                for line in reader.lines() {
                    let Ok(line) = line else { break };
                    if line.is_empty() {
                        continue;
                    }

                    // Parse command
                    let parsed: Result<serde_json::Value, _> = serde_json::from_str(&line);
                    let Ok(json) = parsed else {
                        let _ = stream.write_all(b"ERR: invalid JSON\n");
                        continue;
                    };

                    let sanitized = sanitize_test_server_value(&json);
                    eprintln!("[test-server] received: {sanitized}");

                    let cmd = json.get("cmd").and_then(|v| v.as_str()).unwrap_or("rpc");

                    match cmd {
                        "prompt" => {
                            // Emit event to frontend to trigger sendPrompt
                            let message = json.get("message").and_then(|v| v.as_str()).unwrap_or("");
                            eprintln!("[test-server] emitting test_prompt: {message}");
                            let _ = app.emit("test_prompt", message);
                            let _ = stream.write_all(b"OK\n");
                        }
                        "set_folder" => {
                            // Emit event to frontend to change working folder
                            let folder = json.get("folder").and_then(|v| v.as_str());
                            eprintln!("[test-server] emitting test_set_folder: {folder:?}");
                            let _ = app.emit("test_set_folder", folder);
                            let _ = stream.write_all(b"OK\n");
                        }
                        "set_task" => {
                            // Emit event to frontend to change active task
                            let task_id = json.get("taskId").and_then(|v| v.as_str());
                            eprintln!("[test-server] emitting test_set_task: {task_id:?}");
                            let _ = app.emit("test_set_task", task_id);
                            let _ = stream.write_all(b"OK\n");
                        }
                        "set_auth_profile" => {
                            // Emit event to frontend to switch auth profile + restart runtime
                            let profile = json.get("profile").and_then(|v| v.as_str());
                            eprintln!("[test-server] emitting test_set_auth_profile: {profile:?}");
                            let _ = app.emit("test_set_auth_profile", profile);
                            let _ = stream.write_all(b"OK\n");
                        }
                        "send_login" => {
                            // Emit event to frontend to trigger /login flow in UI
                            eprintln!("[test-server] emitting test_send_login");
                            let _ = app.emit("test_send_login", ());
                            let _ = stream.write_all(b"OK\n");
                        }
                        "auth_list" => {
                            let profile = json.get("profile").and_then(|v| v.as_str()).map(str::to_string);

                            match auth_store_list(app.clone(), profile) {
                                Ok(summary) => {
                                    let payload = serde_json::to_string(&summary).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "auth_set_api_key" => {
                            let provider = json.get("provider").and_then(|v| v.as_str()).unwrap_or("");
                            let key = json.get("key").and_then(|v| v.as_str()).unwrap_or("");
                            let profile = json.get("profile").and_then(|v| v.as_str()).map(str::to_string);

                            match auth_store_set_api_key(app.clone(), provider.to_string(), key.to_string(), profile) {
                                Ok(summary) => {
                                    let payload = serde_json::to_string(&summary).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "auth_delete" => {
                            let provider = json.get("provider").and_then(|v| v.as_str()).unwrap_or("");
                            let profile = json.get("profile").and_then(|v| v.as_str()).map(str::to_string);

                            match auth_store_delete(app.clone(), provider.to_string(), profile) {
                                Ok(summary) => {
                                    let payload = serde_json::to_string(&summary).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "auth_import_pi" => {
                            let profile = json.get("profile").and_then(|v| v.as_str()).map(str::to_string);

                            match auth_store_import_pi(app.clone(), profile) {
                                Ok(summary) => {
                                    let payload = serde_json::to_string(&summary).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "create_task" => {
                            // Emit event to frontend to create a new task
                            let title = json.get("title").and_then(|v| v.as_str());
                            let folder = json.get("workingFolder").and_then(|v| v.as_str());
                            eprintln!("[test-server] emitting test_create_task: {title:?}");
                            let payload = serde_json::json!({
                                "title": title,
                                "workingFolder": folder,
                            });
                            let _ = app.emit("test_create_task", payload);
                            let _ = stream.write_all(b"OK\n");
                        }
                        "delete_all_tasks" => {
                            // Emit event to frontend to wipe all tasks
                            eprintln!("[test-server] emitting test_delete_all_tasks");
                            let _ = app.emit("test_delete_all_tasks", ());
                            let _ = stream.write_all(b"OK\n");
                        }
                        "dump_state" => {
                            // Emit event to frontend to log current UI state
                            eprintln!("[test-server] emitting test_dump_state");
                            let _ = app.emit("test_dump_state", ());
                            let _ = stream.write_all(b"OK\n");
                        }
                        "preview_list" => {
                            let task_id = json.get("taskId").and_then(|v| v.as_str()).unwrap_or("");
                            match task_preview_list(app.clone(), task_id.to_string()) {
                                Ok(result) => {
                                    let payload = serde_json::to_string(&result).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "preview_read" => {
                            let task_id = json.get("taskId").and_then(|v| v.as_str()).unwrap_or("");
                            let relative_path = json.get("relativePath").and_then(|v| v.as_str()).unwrap_or("");

                            match task_preview_read(app.clone(), task_id.to_string(), relative_path.to_string()) {
                                Ok(result) => {
                                    let payload = serde_json::to_string(&result).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "artifact_list" => {
                            let task_id = json.get("taskId").and_then(|v| v.as_str()).unwrap_or("");
                            match task_artifact_list(app.clone(), task_id.to_string()) {
                                Ok(result) => {
                                    let payload = serde_json::to_string(&result).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "artifact_read" => {
                            let task_id = json.get("taskId").and_then(|v| v.as_str()).unwrap_or("");
                            let source = json.get("source").and_then(|v| v.as_str()).unwrap_or("");
                            let relative_path = json.get("relativePath").and_then(|v| v.as_str()).unwrap_or("");

                            match task_artifact_read(
                                app.clone(),
                                task_id.to_string(),
                                source.to_string(),
                                relative_path.to_string(),
                            ) {
                                Ok(result) => {
                                    let payload = serde_json::to_string(&result).unwrap_or_else(|_| "{}".to_string());
                                    let _ = stream.write_all(format!("{payload}\n").as_bytes());
                                }
                                Err(error) => {
                                    let _ = stream.write_all(format!("ERR: {error}\n").as_bytes());
                                }
                            }
                        }
                        "open_preview" => {
                            let task_id = json.get("taskId").and_then(|v| v.as_str()).unwrap_or("");
                            let relative_path = json.get("relativePath").and_then(|v| v.as_str()).unwrap_or("");

                            let payload = serde_json::json!({
                                "taskId": task_id,
                                "relativePath": relative_path,
                            });
                            let _ = app.emit("test_open_preview", payload);
                            let _ = stream.write_all(b"OK\n");
                        }
                        _ => {
                            // Direct RPC send (bypass UI)
                            let state: tauri::State<vm::VmState> = app.state();
                            match vm::send(&state, &line) {
                                Ok(()) => {
                                    let _ = stream.write_all(b"OK\n");
                                }
                                Err(e) => {
                                    let _ = stream.write_all(format!("ERR: {e}\n").as_bytes());
                                }
                            }
                        }
                    }
                }
            });
        }
    });
}

#[cfg_attr(mobile, tauri::mobile_entry_point)]
pub fn run() {
    tauri::Builder::default()
        .plugin(tauri_plugin_opener::init())
        .plugin(tauri_plugin_dialog::init())
        .manage(vm::VmState::default())
        .setup(|app| {
            #[cfg(debug_assertions)]
            start_test_server(app.handle().clone());
            Ok(())
        })
        .invoke_handler(tauri::generate_handler![
            dev_log,
            runtime_status,
            runtime_workspace_root,
            runtime_validate_working_folder,
            open_path_in_finder,
            task_store_list,
            task_store_upsert,
            task_store_delete,
            task_store_delete_all,
            task_store_save_conversation,
            task_store_load_conversation,
            task_preview_list,
            task_preview_read,
            task_artifact_list,
            task_artifact_read,
            auth_store_list,
            auth_store_set_api_key,
            auth_store_delete,
            auth_store_import_pi,
            vm_status,
            vm_start,
            vm_stop,
            rpc_send,
        ])
        .run(tauri::generate_context!())
        .expect("error while running tauri application");
}

#[cfg(all(test, debug_assertions))]
mod tests {
    use super::{normalize_auth_profile_name, sanitize_test_server_value};

    #[test]
    fn sanitize_redacts_sensitive_fields_recursively() {
        let payload = serde_json::json!({
            "cmd": "auth_set_api_key",
            "provider": "anthropic",
            "key": "secret-value",
            "nested": {
                "apiToken": "abc123",
                "list": [
                    { "password": "hunter2" },
                    { "safe": "value" }
                ]
            }
        });

        let sanitized = sanitize_test_server_value(&payload);

        assert_eq!(sanitized["provider"], "anthropic");
        assert_eq!(sanitized["key"], "<redacted>");
        assert_eq!(sanitized["nested"]["apiToken"], "<redacted>");
        assert_eq!(sanitized["nested"]["list"][0]["password"], "<redacted>");
        assert_eq!(sanitized["nested"]["list"][1]["safe"], "value");
    }

    #[test]
    fn sanitize_keeps_non_sensitive_structure() {
        let payload = serde_json::json!({
            "cmd": "preview_read",
            "taskId": "task-1",
            "relativePath": "src/main.ts"
        });

        let sanitized = sanitize_test_server_value(&payload);

        assert_eq!(sanitized, payload);
    }

    #[test]
    fn normalize_auth_profile_defaults_and_accepts_safe_values() {
        assert_eq!(normalize_auth_profile_name(None).unwrap(), "default");
        assert_eq!(normalize_auth_profile_name(Some("")).unwrap(), "default");
        assert_eq!(normalize_auth_profile_name(Some(" work ")).unwrap(), "work");
        assert_eq!(normalize_auth_profile_name(Some("work-1_2.3")).unwrap(), "work-1_2.3");
    }

    #[test]
    fn normalize_auth_profile_rejects_unsafe_values() {
        assert!(normalize_auth_profile_name(Some("../secret")).is_err());
        assert!(normalize_auth_profile_name(Some("work/profile")).is_err());
        assert!(normalize_auth_profile_name(Some("work\\profile")).is_err());
        assert!(normalize_auth_profile_name(Some("with space")).is_err());
    }
}

```

src-tauri/src/main.rs
```
// Prevents additional console window on Windows in release, DO NOT REMOVE!!
#![cfg_attr(not(debug_assertions), windows_subsystem = "windows")]

fn main() {
    piwork_lib::run();
}

```

src-tauri/src/task_store.rs
```
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};

#[derive(Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TaskMount {
    pub path: String,
    pub mode: String,
}

#[derive(Serialize, Deserialize, Clone)]
#[serde(rename_all = "camelCase")]
pub struct TaskMetadata {
    pub id: String,
    pub title: String,
    pub status: String,
    pub created_at: String,
    pub updated_at: String,
    pub session_file: Option<String>,
    pub working_folder: Option<String>,
    pub mounts: Option<Vec<TaskMount>>,
    pub model: Option<String>,
    pub thinking_level: Option<String>,
    pub connectors_enabled: Option<Vec<String>>,
}

pub const TASK_OUTPUTS_DIR: &str = "outputs";
pub const TASK_UPLOADS_DIR: &str = "uploads";

pub fn task_dir(tasks_dir: &Path, task_id: &str) -> PathBuf {
    tasks_dir.join(task_id)
}

pub fn task_outputs_dir(tasks_dir: &Path, task_id: &str) -> PathBuf {
    task_dir(tasks_dir, task_id).join(TASK_OUTPUTS_DIR)
}

pub fn task_uploads_dir(tasks_dir: &Path, task_id: &str) -> PathBuf {
    task_dir(tasks_dir, task_id).join(TASK_UPLOADS_DIR)
}

pub fn ensure_task_artifact_dirs(tasks_dir: &Path, task_id: &str) -> Result<(), String> {
    std::fs::create_dir_all(task_outputs_dir(tasks_dir, task_id)).map_err(|error| error.to_string())?;
    std::fs::create_dir_all(task_uploads_dir(tasks_dir, task_id)).map_err(|error| error.to_string())?;
    Ok(())
}

pub fn load_task(tasks_dir: &Path, task_id: &str) -> Result<Option<TaskMetadata>, String> {
    std::fs::create_dir_all(tasks_dir).map_err(|error| error.to_string())?;

    let task_path = tasks_dir.join(task_id).join("task.json");
    if !task_path.exists() {
        return Ok(None);
    }

    let content = std::fs::read_to_string(&task_path).map_err(|error| error.to_string())?;
    let task: TaskMetadata = serde_json::from_str(&content).map_err(|error| error.to_string())?;
    Ok(Some(task))
}

pub fn list_tasks(tasks_dir: &Path) -> Result<Vec<TaskMetadata>, String> {
    std::fs::create_dir_all(tasks_dir).map_err(|error| error.to_string())?;

    let mut tasks = Vec::new();

    for entry in std::fs::read_dir(tasks_dir).map_err(|error| error.to_string())? {
        let entry = entry.map_err(|error| error.to_string())?;
        let path = entry.path();
        if !path.is_dir() {
            continue;
        }

        let Some(task_id) = path.file_name().and_then(|value| value.to_str()) else {
            continue;
        };

        if let Some(task) = load_task(tasks_dir, task_id)? {
            tasks.push(task);
        }
    }

    tasks.sort_by(|a, b| b.updated_at.cmp(&a.updated_at));

    Ok(tasks)
}

pub fn upsert_task(tasks_dir: &Path, task: &TaskMetadata) -> Result<(), String> {
    std::fs::create_dir_all(tasks_dir).map_err(|error| error.to_string())?;

    let existing = load_task(tasks_dir, &task.id)?;
    if let Some(existing_task) = existing {
        if let Some(existing_folder) = existing_task.working_folder.as_deref() {
            if task.working_folder.as_deref() != Some(existing_folder) {
                return Err(
                    "workingFolder is immutable once set; create a new task to use a different folder".to_string(),
                );
            }
        }
    }

    let task_folder = task_dir(tasks_dir, &task.id);
    std::fs::create_dir_all(&task_folder).map_err(|error| error.to_string())?;
    ensure_task_artifact_dirs(tasks_dir, &task.id)?;

    let task_path = task_folder.join("task.json");
    let content = serde_json::to_string_pretty(task).map_err(|error| error.to_string())?;
    std::fs::write(&task_path, content).map_err(|error| error.to_string())?;

    Ok(())
}

pub fn delete_task(tasks_dir: &Path, task_id: String) -> Result<(), String> {
    let task_folder = tasks_dir.join(task_id);

    if task_folder.exists() {
        std::fs::remove_dir_all(task_folder).map_err(|error| error.to_string())?;
    }

    Ok(())
}

pub fn delete_all_tasks(tasks_dir: &Path) -> Result<(), String> {
    if !tasks_dir.exists() {
        return Ok(());
    }

    for entry in std::fs::read_dir(tasks_dir).map_err(|error| error.to_string())? {
        let entry = entry.map_err(|error| error.to_string())?;
        let path = entry.path();

        if path.is_dir() {
            std::fs::remove_dir_all(&path).map_err(|error| error.to_string())?;
        } else {
            std::fs::remove_file(&path).map_err(|error| error.to_string())?;
        }
    }

    Ok(())
}

pub fn save_conversation(tasks_dir: &Path, task_id: &str, conversation_json: &str) -> Result<(), String> {
    let task_folder = tasks_dir.join(task_id);
    if !task_folder.exists() {
        return Err(format!("Task folder does not exist: {task_id}"));
    }

    let conv_path = task_folder.join("conversation.json");
    std::fs::write(&conv_path, conversation_json).map_err(|e| e.to_string())?;
    Ok(())
}

pub fn load_conversation(tasks_dir: &Path, task_id: &str) -> Result<Option<String>, String> {
    let task_folder = tasks_dir.join(task_id);
    let conv_path = task_folder.join("conversation.json");

    if !conv_path.exists() {
        return Ok(None);
    }

    let content = std::fs::read_to_string(&conv_path).map_err(|e| e.to_string())?;
    Ok(Some(content))
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;
    use std::sync::atomic::{AtomicUsize, Ordering};
    use std::time::{SystemTime, UNIX_EPOCH};

    static TEMP_COUNTER: AtomicUsize = AtomicUsize::new(0);

    fn temp_dir() -> PathBuf {
        let suffix = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_nanos();
        let counter = TEMP_COUNTER.fetch_add(1, Ordering::Relaxed);
        std::env::temp_dir().join(format!("piwork-task-store-{suffix}-{counter}"))
    }

    fn sample_task(id: &str, updated_at: &str) -> TaskMetadata {
        TaskMetadata {
            id: id.to_string(),
            title: "Test".to_string(),
            status: "idle".to_string(),
            created_at: "2026-02-04T00:00:00Z".to_string(),
            updated_at: updated_at.to_string(),
            session_file: None,
            working_folder: None,
            mounts: None,
            model: None,
            thinking_level: None,
            connectors_enabled: None,
        }
    }

    fn sample_task_with_folder(id: &str, updated_at: &str, working_folder: Option<&str>) -> TaskMetadata {
        TaskMetadata {
            working_folder: working_folder.map(str::to_string),
            ..sample_task(id, updated_at)
        }
    }

    #[test]
    fn upsert_and_list() {
        let dir = temp_dir();
        let task = sample_task("task-1", "2026-02-04T00:00:01Z");

        upsert_task(&dir, &task).expect("upsert");
        let tasks = list_tasks(&dir).expect("list");

        assert_eq!(tasks.len(), 1);
        assert_eq!(tasks[0].id, "task-1");

        std::fs::remove_dir_all(&dir).ok();
    }

    #[test]
    fn upsert_creates_artifact_dirs() {
        let dir = temp_dir();
        let task = sample_task("task-1", "2026-02-04T00:00:01Z");

        upsert_task(&dir, &task).expect("upsert");

        assert!(task_outputs_dir(&dir, &task.id).is_dir());
        assert!(task_uploads_dir(&dir, &task.id).is_dir());

        std::fs::remove_dir_all(&dir).ok();
    }

    #[test]
    fn upsert_allows_first_working_folder_bind() {
        let dir = temp_dir();
        let initial = sample_task("task-1", "2026-02-04T00:00:01Z");
        let bound = sample_task_with_folder("task-1", "2026-02-04T00:00:02Z", Some("/tmp/work"));

        upsert_task(&dir, &initial).expect("upsert initial");
        upsert_task(&dir, &bound).expect("upsert bound");

        let loaded = load_task(&dir, "task-1").expect("load").expect("task exists");
        assert_eq!(loaded.working_folder.as_deref(), Some("/tmp/work"));

        std::fs::remove_dir_all(&dir).ok();
    }

    #[test]
    fn upsert_rejects_working_folder_change_after_bind() {
        let dir = temp_dir();
        let initial = sample_task_with_folder("task-1", "2026-02-04T00:00:01Z", Some("/tmp/work-a"));
        let changed = sample_task_with_folder("task-1", "2026-02-04T00:00:02Z", Some("/tmp/work-b"));

        upsert_task(&dir, &initial).expect("upsert initial");
        let error = upsert_task(&dir, &changed).expect_err("folder rebind should fail");

        assert!(error.contains("workingFolder is immutable"));

        std::fs::remove_dir_all(&dir).ok();
    }

    #[test]
    fn upsert_rejects_working_folder_clear_after_bind() {
        let dir = temp_dir();
        let initial = sample_task_with_folder("task-1", "2026-02-04T00:00:01Z", Some("/tmp/work-a"));
        let cleared = sample_task("task-1", "2026-02-04T00:00:02Z");

        upsert_task(&dir, &initial).expect("upsert initial");
        let error = upsert_task(&dir, &cleared).expect_err("folder clear should fail");

        assert!(error.contains("workingFolder is immutable"));

        std::fs::remove_dir_all(&dir).ok();
    }

    #[test]
    fn list_sorts_by_updated_at() {
        let dir = temp_dir();
        let older = sample_task("task-old", "2026-02-04T00:00:01Z");
        let newer = sample_task("task-new", "2026-02-04T00:00:02Z");

        upsert_task(&dir, &older).expect("upsert older");
        upsert_task(&dir, &newer).expect("upsert newer");

        let tasks = list_tasks(&dir).expect("list");
        assert_eq!(tasks[0].id, "task-new");
        assert_eq!(tasks[1].id, "task-old");

        std::fs::remove_dir_all(&dir).ok();
    }

    #[test]
    fn delete_task_removes_dir() {
        let dir = temp_dir();
        let task = sample_task("task-1", "2026-02-04T00:00:01Z");

        upsert_task(&dir, &task).expect("upsert");
        delete_task(&dir, "task-1".to_string()).expect("delete");

        let tasks = list_tasks(&dir).expect("list");
        assert!(tasks.is_empty());

        std::fs::remove_dir_all(&dir).ok();
    }

    #[test]
    fn delete_all_tasks_removes_dirs() {
        let dir = temp_dir();
        let task_one = sample_task("task-1", "2026-02-04T00:00:01Z");
        let task_two = sample_task("task-2", "2026-02-04T00:00:02Z");

        upsert_task(&dir, &task_one).expect("upsert one");
        upsert_task(&dir, &task_two).expect("upsert two");
        delete_all_tasks(&dir).expect("delete all");

        let tasks = list_tasks(&dir).expect("list");
        assert!(tasks.is_empty());

        std::fs::remove_dir_all(&dir).ok();
    }
}

```

src-tauri/src/vm.rs
```
use serde::{Deserialize, Serialize};
use std::fmt::Write as _;
use std::io::{BufRead, BufReader, Write};
use std::net::TcpStream;
use std::path::{Path, PathBuf};
use std::process::{Child, Command, Stdio};
use std::sync::{Arc, Mutex};
use std::thread;
use std::time::Duration;
use tauri::AppHandle;
use tauri::Emitter;
use tauri::Manager;

const RPC_PORT: u16 = 19384;

#[derive(Default)]
pub struct VmState {
    inner: Mutex<Option<VmInstance>>,
    status: Mutex<VmStatus>,
}

#[derive(Clone, Serialize, Default)]
#[serde(rename_all = "snake_case")]
pub enum VmStatus {
    Starting,
    Ready,
    #[default]
    Stopped,
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct VmStatusResponse {
    pub status: VmStatus,
    pub rpc_port: Option<u16>,
    pub log_path: Option<String>,
}

#[derive(Deserialize)]
#[serde(rename_all = "camelCase")]
pub struct RuntimeManifest {
    pub kernel: String,
    pub initrd: String,
    pub cmdline: Option<String>,
    pub qemu: Option<String>,
}

struct VmInstance {
    child: Child,
    log_path: PathBuf,
    rpc_writer: Arc<Mutex<Option<TcpStream>>>,
}

#[derive(Clone, Serialize)]
#[serde(rename_all = "camelCase")]
struct VmEvent {
    event: String,
    message: String,
}

fn emit_event(app: &AppHandle, event: &str, message: String) {
    let _ = app.emit(
        "vm_event",
        VmEvent {
            event: event.to_string(),
            message,
        },
    );
}

fn set_status(app: &AppHandle, status: VmStatus) {
    let state: tauri::State<VmState> = app.state();
    *state.status.lock().unwrap() = status;
}

fn mark_stopped(app: &AppHandle) {
    let state: tauri::State<VmState> = app.state();
    let instance = {
        let mut inner = state.inner.lock().unwrap();
        inner.take()
    };

    *state.status.lock().unwrap() = VmStatus::Stopped;

    if let Some(mut instance) = instance {
        instance.child.kill().ok();
        let _ = instance.child.wait();
    }
}

pub fn status(state: &VmState) -> VmStatusResponse {
    let status = state.status.lock().unwrap().clone();
    let inner = state.inner.lock().unwrap();
    let log_path = inner
        .as_ref()
        .map(|instance| instance.log_path.to_string_lossy().to_string());

    VmStatusResponse {
        status,
        rpc_port: Some(RPC_PORT),
        log_path,
    }
}

#[allow(clippy::too_many_arguments)]
pub fn start(
    app: &AppHandle,
    state: &VmState,
    runtime_dir: &Path,
    working_folder: Option<&Path>,
    task_state_dir: Option<&Path>,
    auth_state_dir: Option<&Path>,
    initial_task_id: Option<&str>,
    auth_profile: Option<&str>,
) -> Result<VmStatusResponse, String> {
    eprintln!("[rust:vm] start called");
    let mut inner = state.inner.lock().unwrap();
    if inner.is_some() {
        eprintln!("[rust:vm] already running");
        // Build response inline to avoid deadlock (we already hold inner lock)
        let status = state.status.lock().unwrap().clone();
        let log_path = inner
            .as_ref()
            .map(|instance| instance.log_path.to_string_lossy().to_string());
        return Ok(VmStatusResponse {
            status,
            rpc_port: Some(RPC_PORT),
            log_path,
        });
    }

    eprintln!("[rust:vm] loading manifest");
    let manifest = load_manifest(runtime_dir)?;

    let vm_dir = app.path().app_data_dir().map_err(|e| e.to_string())?.join("vm");
    std::fs::create_dir_all(&vm_dir).map_err(|e| e.to_string())?;
    let log_path = vm_dir.join("qemu.log");

    eprintln!("[rust:vm] spawning qemu");
    let child = spawn_qemu(
        &manifest,
        runtime_dir,
        &log_path,
        working_folder,
        task_state_dir,
        auth_state_dir,
        initial_task_id,
        auth_profile,
    )?;
    eprintln!("[rust:vm] qemu spawned");

    let rpc_writer: Arc<Mutex<Option<TcpStream>>> = Arc::new(Mutex::new(None));

    let instance = VmInstance {
        child,
        log_path: log_path.clone(),
        rpc_writer: rpc_writer.clone(),
    };

    *state.status.lock().unwrap() = VmStatus::Starting;
    *inner = Some(instance);
    drop(inner); // Release lock before spawning thread

    // Thread to wait for READY and then connect RPC
    let app_handle = app.clone();
    thread::spawn(move || {
        eprintln!("[rust:vm:rpc] waiting for READY signal...");

        // Wait for VM to boot by polling the log file for READY
        let ready = wait_for_ready(&log_path, Duration::from_secs(30));

        if !ready {
            eprintln!("[rust:vm:rpc] timeout waiting for READY");
            emit_event(&app_handle, "error", "Timeout waiting for VM to boot".to_string());
            mark_stopped(&app_handle);
            return;
        }

        eprintln!("[rust:vm:rpc] READY received, connecting to RPC port...");

        // Connect to RPC port first, then emit ready once writable RPC is available.
        match connect_rpc(RPC_PORT) {
            Ok(stream) => {
                eprintln!("[rust:vm:rpc] connected to TCP port {RPC_PORT}");
                if let Ok(clone) = stream.try_clone() {
                    *rpc_writer.lock().unwrap() = Some(clone);
                }

                set_status(&app_handle, VmStatus::Ready);
                emit_event(&app_handle, "ready", "READY".to_string());

                read_rpc_lines(&app_handle, stream);
            }
            Err(error) => {
                eprintln!("[rust:vm:rpc] TCP connection failed: {error}");
                emit_event(&app_handle, "error", format!("RPC connection failed: {error}"));
            }
        }

        mark_stopped(&app_handle);
    });

    Ok(status(state))
}

pub fn stop(state: &VmState) {
    let mut inner = state.inner.lock().unwrap();
    if let Some(mut instance) = inner.take() {
        instance.child.kill().ok();
        let _ = instance.child.wait();
    }

    *state.status.lock().unwrap() = VmStatus::Stopped;
}

pub fn send(state: &VmState, message: &str) -> Result<(), String> {
    let inner = state.inner.lock().unwrap();
    let Some(instance) = inner.as_ref() else {
        return Err("VM not running".to_string());
    };

    let mut guard = instance.rpc_writer.lock().unwrap();
    let Some(stream) = guard.as_mut() else {
        return Err("RPC not connected".to_string());
    };

    stream
        .write_all(format!("{message}\n").as_bytes())
        .map_err(|e| e.to_string())?;
    stream.flush().map_err(|e| e.to_string())?;

    Ok(())
}

fn load_manifest(runtime_dir: &Path) -> Result<RuntimeManifest, String> {
    let manifest_path = runtime_dir.join("manifest.json");
    let content = std::fs::read_to_string(&manifest_path).map_err(|e| e.to_string())?;
    let manifest: RuntimeManifest = serde_json::from_str(&content).map_err(|e| e.to_string())?;
    Ok(manifest)
}

fn attach_9p_mount(command: &mut Command, id: &str, mount_tag: &str, path: &Path, label: &str) {
    if !path.is_dir() {
        eprintln!("[rust:vm] {label} not found: {}", path.display());
        return;
    }

    eprintln!("[rust:vm] mounting {label}: {}", path.display());
    command
        .arg("-fsdev")
        .arg(format!("local,id={id},path={},security_model=none", path.display()))
        .arg("-device")
        .arg(format!("virtio-9p-pci,fsdev={id},mount_tag={mount_tag}"));
}

#[allow(clippy::too_many_arguments)]
fn spawn_qemu(
    manifest: &RuntimeManifest,
    runtime_dir: &Path,
    log_path: &Path,
    working_folder: Option<&Path>,
    task_state_dir: Option<&Path>,
    auth_state_dir: Option<&Path>,
    initial_task_id: Option<&str>,
    auth_profile: Option<&str>,
) -> Result<Child, String> {
    let qemu_binary = resolve_qemu_binary(manifest, runtime_dir)?;

    let kernel = runtime_dir.join(&manifest.kernel);
    if !kernel.is_file() {
        return Err(format!("Kernel not found: {}", kernel.display()));
    }

    let initrd = runtime_dir.join(&manifest.initrd);
    if !initrd.is_file() {
        return Err(format!("Initrd not found: {}", initrd.display()));
    }

    let base_cmdline = manifest.cmdline.as_deref().unwrap_or("quiet console=ttyAMA0");
    let mut cmdline = base_cmdline.to_string();

    if let Some(task_id) = initial_task_id {
        let _ = write!(&mut cmdline, " piwork.task_id={task_id}");
    }

    if let Some(profile) = auth_profile {
        let _ = write!(&mut cmdline, " piwork.auth_profile={profile}");
    }

    // Open log file for serial output
    let log_file = std::fs::File::create(log_path).map_err(|e| e.to_string())?;
    let log_out = log_file.try_clone().map_err(|e| e.to_string())?;
    let log_err = log_file.try_clone().map_err(|e| e.to_string())?;

    let mut command = Command::new(qemu_binary);
    command
        .arg("-machine")
        .arg("virt,accel=hvf")
        .arg("-cpu")
        .arg("host")
        .arg("-smp")
        .arg("2")
        .arg("-m")
        .arg("2048")
        .arg("-nographic")
        .arg("-kernel")
        .arg(&kernel)
        .arg("-initrd")
        .arg(&initrd)
        .arg("-append")
        .arg(cmdline)
        // Network with port forwarding for RPC
        .arg("-device")
        .arg("virtio-net-pci,netdev=net0,mac=52:54:00:12:34:56")
        .arg("-netdev")
        .arg(format!("user,id=net0,hostfwd=tcp:127.0.0.1:{RPC_PORT}-:{RPC_PORT}"));

    // Working folder mount via virtio-9p
    if let Some(folder) = working_folder {
        attach_9p_mount(&mut command, "workdir", "workdir", folder, "working folder");
    }

    // Task state mount via virtio-9p
    if let Some(task_state) = task_state_dir {
        attach_9p_mount(&mut command, "taskstate", "taskstate", task_state, "task state dir");
    }

    // Auth state mount via virtio-9p
    if let Some(auth_state) = auth_state_dir {
        attach_9p_mount(&mut command, "authstate", "authstate", auth_state, "auth state dir");
    }

    command
        // Serial console to file (we read this for READY)
        .arg("-serial")
        .arg(format!("file:{}", log_path.display()))
        .stdout(Stdio::from(log_out))
        .stderr(Stdio::from(log_err));

    command.spawn().map_err(|e| e.to_string())
}

fn resolve_qemu_binary(manifest: &RuntimeManifest, runtime_dir: &Path) -> Result<PathBuf, String> {
    if let Some(qemu) = &manifest.qemu {
        let candidate = runtime_dir.join(qemu);
        if candidate.is_file() {
            return Ok(candidate);
        }
        return Err(format!("QEMU binary not found at {}", candidate.display()));
    }

    find_in_path("qemu-system-aarch64").ok_or_else(|| "QEMU not found in PATH".to_string())
}

pub fn find_in_path(binary: &str) -> Option<PathBuf> {
    let path_var = std::env::var("PATH").ok()?;
    for entry in path_var.split(':') {
        let candidate = PathBuf::from(entry).join(binary);
        if candidate.is_file() {
            return Some(candidate);
        }
    }
    None
}

fn wait_for_ready(log_path: &Path, timeout: Duration) -> bool {
    let start = std::time::Instant::now();

    while start.elapsed() < timeout {
        if let Ok(content) = std::fs::read_to_string(log_path) {
            if content.contains("READY") {
                return true;
            }
        }
        thread::sleep(Duration::from_millis(100));
    }

    false
}

fn connect_rpc(port: u16) -> Result<TcpStream, String> {
    let addr = format!("127.0.0.1:{port}");
    let mut attempts = 0;

    loop {
        match TcpStream::connect(&addr) {
            Ok(stream) => return Ok(stream),
            Err(error) => {
                attempts += 1;
                if attempts > 50 {
                    return Err(error.to_string());
                }
                thread::sleep(Duration::from_millis(100));
            }
        }
    }
}

fn read_rpc_lines(app: &AppHandle, stream: TcpStream) {
    eprintln!("[rust:vm:rpc] starting to read RPC lines");
    let reader = BufReader::new(stream);

    for line in reader.lines().map_while(Result::ok) {
        let trimmed = line.trim();
        if !trimmed.is_empty() {
            eprintln!("[rust:vm:rpc] received: {trimmed:?}");
            emit_event(app, "rpc", trimmed.to_string());
        }
    }

    eprintln!("[rust:vm:rpc] RPC connection closed");
}

```

src-tauri/tauri.conf.json
```
{
    "$schema": "https://schema.tauri.app/config/2",
    "productName": "Piwork",
    "version": "0.1.0",
    "identifier": "com.pi.work",
    "build": {
        "beforeDevCommand": "mise run dev",
        "devUrl": "http://localhost:1420",
        "beforeBuildCommand": "mise run build",
        "frontendDist": "../build"
    },
    "app": {
        "windows": [
            {
                "title": "Piwork",
                "width": 1280,
                "height": 800
            }
        ],
        "security": {
            "csp": null
        }
    },
    "bundle": {
        "active": true,
        "targets": "all",
        "icon": ["icons/32x32.png", "icons/128x128.png", "icons/128x128@2x.png", "icons/icon.icns", "icons/icon.ico"]
    }
}

```

src/app.css
```
@import "tailwindcss";

@import "tw-animate-css";

@custom-variant dark (&:is(.dark *));

:root {
    --radius: 0.625rem;
    --background: oklch(1 0 0);
    --foreground: oklch(0.129 0.042 264.695);
    --card: oklch(1 0 0);
    --card-foreground: oklch(0.129 0.042 264.695);
    --popover: oklch(1 0 0);
    --popover-foreground: oklch(0.129 0.042 264.695);
    --primary: oklch(0.208 0.042 265.755);
    --primary-foreground: oklch(0.984 0.003 247.858);
    --secondary: oklch(0.968 0.007 247.896);
    --secondary-foreground: oklch(0.208 0.042 265.755);
    --muted: oklch(0.968 0.007 247.896);
    --muted-foreground: oklch(0.554 0.046 257.417);
    --accent: oklch(0.968 0.007 247.896);
    --accent-foreground: oklch(0.208 0.042 265.755);
    --destructive: oklch(0.577 0.245 27.325);
    --border: oklch(0.929 0.013 255.508);
    --input: oklch(0.929 0.013 255.508);
    --ring: oklch(0.704 0.04 256.788);
    --chart-1: oklch(0.646 0.222 41.116);
    --chart-2: oklch(0.6 0.118 184.704);
    --chart-3: oklch(0.398 0.07 227.392);
    --chart-4: oklch(0.828 0.189 84.429);
    --chart-5: oklch(0.769 0.188 70.08);
    --sidebar: oklch(0.984 0.003 247.858);
    --sidebar-foreground: oklch(0.129 0.042 264.695);
    --sidebar-primary: oklch(0.208 0.042 265.755);
    --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
    --sidebar-accent: oklch(0.968 0.007 247.896);
    --sidebar-accent-foreground: oklch(0.208 0.042 265.755);
    --sidebar-border: oklch(0.929 0.013 255.508);
    --sidebar-ring: oklch(0.704 0.04 256.788);
}

.dark {
    --background: oklch(0.129 0.042 264.695);
    --foreground: oklch(0.984 0.003 247.858);
    --card: oklch(0.208 0.042 265.755);
    --card-foreground: oklch(0.984 0.003 247.858);
    --popover: oklch(0.208 0.042 265.755);
    --popover-foreground: oklch(0.984 0.003 247.858);
    --primary: oklch(0.929 0.013 255.508);
    --primary-foreground: oklch(0.208 0.042 265.755);
    --secondary: oklch(0.279 0.041 260.031);
    --secondary-foreground: oklch(0.984 0.003 247.858);
    --muted: oklch(0.279 0.041 260.031);
    --muted-foreground: oklch(0.704 0.04 256.788);
    --accent: oklch(0.279 0.041 260.031);
    --accent-foreground: oklch(0.984 0.003 247.858);
    --destructive: oklch(0.704 0.191 22.216);
    --border: oklch(1 0 0 / 10%);
    --input: oklch(1 0 0 / 15%);
    --ring: oklch(0.551 0.027 264.364);
    --chart-1: oklch(0.488 0.243 264.376);
    --chart-2: oklch(0.696 0.17 162.48);
    --chart-3: oklch(0.769 0.188 70.08);
    --chart-4: oklch(0.627 0.265 303.9);
    --chart-5: oklch(0.645 0.246 16.439);
    --sidebar: oklch(0.208 0.042 265.755);
    --sidebar-foreground: oklch(0.984 0.003 247.858);
    --sidebar-primary: oklch(0.488 0.243 264.376);
    --sidebar-primary-foreground: oklch(0.984 0.003 247.858);
    --sidebar-accent: oklch(0.279 0.041 260.031);
    --sidebar-accent-foreground: oklch(0.984 0.003 247.858);
    --sidebar-border: oklch(1 0 0 / 10%);
    --sidebar-ring: oklch(0.551 0.027 264.364);
}

@theme inline {
    --radius-sm: calc(var(--radius) - 4px);
    --radius-md: calc(var(--radius) - 2px);
    --radius-lg: var(--radius);
    --radius-xl: calc(var(--radius) + 4px);
    --color-background: var(--background);
    --color-foreground: var(--foreground);
    --color-card: var(--card);
    --color-card-foreground: var(--card-foreground);
    --color-popover: var(--popover);
    --color-popover-foreground: var(--popover-foreground);
    --color-primary: var(--primary);
    --color-primary-foreground: var(--primary-foreground);
    --color-secondary: var(--secondary);
    --color-secondary-foreground: var(--secondary-foreground);
    --color-muted: var(--muted);
    --color-muted-foreground: var(--muted-foreground);
    --color-accent: var(--accent);
    --color-accent-foreground: var(--accent-foreground);
    --color-destructive: var(--destructive);
    --color-border: var(--border);
    --color-input: var(--input);
    --color-ring: var(--ring);
    --color-chart-1: var(--chart-1);
    --color-chart-2: var(--chart-2);
    --color-chart-3: var(--chart-3);
    --color-chart-4: var(--chart-4);
    --color-chart-5: var(--chart-5);
    --color-sidebar: var(--sidebar);
    --color-sidebar-foreground: var(--sidebar-foreground);
    --color-sidebar-primary: var(--sidebar-primary);
    --color-sidebar-primary-foreground: var(--sidebar-primary-foreground);
    --color-sidebar-accent: var(--sidebar-accent);
    --color-sidebar-accent-foreground: var(--sidebar-accent-foreground);
    --color-sidebar-border: var(--sidebar-border);
    --color-sidebar-ring: var(--sidebar-ring);
}

@layer base {
    * {
        @apply border-border outline-ring/50;
    }
    body {
        @apply bg-background text-foreground;
    }

    /* Scrollbar styling */
    ::-webkit-scrollbar {
        width: 12px;
        height: 12px;
    }
    ::-webkit-scrollbar-track {
        background: transparent;
        margin: 4px 0;
    }
    ::-webkit-scrollbar-thumb {
        background: var(--muted-foreground);
        border-radius: 6px;
        border: 2px solid transparent;
        background-clip: content-box;
    }
    ::-webkit-scrollbar-thumb:hover {
        background: var(--foreground);
        background-clip: content-box;
    }
}

```

src/app.html
```
<!doctype html>
<html lang="en" class="h-full overflow-hidden">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%sveltekit.assets%/favicon.ico" sizes="any" />
    <link rel="icon" type="image/png" href="%sveltekit.assets%/favicon.png" />
    <link rel="apple-touch-icon" href="%sveltekit.assets%/apple-touch-icon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Piwork</title>
    %sveltekit.head%
  </head>
  <body data-sveltekit-preload-data="hover" class="h-full overflow-hidden">
    <div style="display: contents">%sveltekit.body%</div>
  </body>
</html>

```

src/lib/components/ExtensionUiDialog.svelte
```
<script lang="ts">
export interface ExtensionUiRequest {
    id: string;
    method: string;
    title?: string;
    message?: string;
    options?: string[];
    placeholder?: string;
    prefill?: string;
}

interface Props {
    request: ExtensionUiRequest;
    sending: boolean;
    onconfirm: (confirmed: boolean) => void;
    onselect: (value: string) => void;
    onsubmit: (value: string) => void;
    oncancel: () => void;
}

let { request, sending, onconfirm, onselect, onsubmit, oncancel }: Props = $props();
let inputValue = $state("");

// Reset input when request changes
$effect(() => {
    inputValue = request.prefill ?? "";
});
</script>

<div class="mt-4 rounded-md border border-border bg-muted/30 p-3 text-xs text-muted-foreground">
    <div class="text-sm font-medium text-foreground">
        {request.title ?? "Action required"}
    </div>
    {#if request.message}
        <div class="mt-1">{request.message}</div>
    {/if}
    <div class="mt-2 text-[11px] text-muted-foreground">
        Method: {request.method}
    </div>
    
    {#if request.method === "confirm"}
        <div class="mt-3 flex gap-2">
            <button
                class="rounded-md bg-primary px-3 py-1 text-xs text-primary-foreground hover:bg-primary/90 disabled:opacity-60"
                onclick={() => onconfirm(true)}
                disabled={sending}
            >
                Confirm
            </button>
            <button
                class="rounded-md bg-secondary px-3 py-1 text-xs hover:bg-secondary/80 disabled:opacity-60"
                onclick={() => onconfirm(false)}
                disabled={sending}
            >
                Deny
            </button>
            <button
                class="rounded-md px-3 py-1 text-xs text-muted-foreground hover:bg-accent disabled:opacity-60"
                onclick={oncancel}
                disabled={sending}
            >
                Cancel
            </button>
        </div>
    {:else if request.method === "select"}
        <div class="mt-3 flex flex-wrap gap-2">
            {#each request.options ?? [] as option}
                <button
                    class="rounded-md bg-secondary px-3 py-1 text-xs hover:bg-secondary/80 disabled:opacity-60"
                    onclick={() => onselect(option)}
                    disabled={sending}
                >
                    {option}
                </button>
            {/each}
            <button
                class="rounded-md px-3 py-1 text-xs text-muted-foreground hover:bg-accent disabled:opacity-60"
                onclick={oncancel}
                disabled={sending}
            >
                Cancel
            </button>
        </div>
    {:else if request.method === "input"}
        <div class="mt-3 space-y-2">
            <input
                class="w-full rounded-md border border-border bg-background px-2 py-1 text-xs"
                placeholder={request.placeholder ?? "Enter a value"}
                bind:value={inputValue}
            />
            <div class="flex gap-2">
                <button
                    class="rounded-md bg-primary px-3 py-1 text-xs text-primary-foreground hover:bg-primary/90 disabled:opacity-60"
                    onclick={() => onsubmit(inputValue)}
                    disabled={sending}
                >
                    Submit
                </button>
                <button
                    class="rounded-md px-3 py-1 text-xs text-muted-foreground hover:bg-accent disabled:opacity-60"
                    onclick={oncancel}
                    disabled={sending}
                >
                    Cancel
                </button>
            </div>
        </div>
    {:else if request.method === "editor"}
        <div class="mt-3 space-y-2">
            <textarea
                class="w-full rounded-md border border-border bg-background px-2 py-1 text-xs"
                rows="4"
                bind:value={inputValue}
            ></textarea>
            <div class="flex gap-2">
                <button
                    class="rounded-md bg-primary px-3 py-1 text-xs text-primary-foreground hover:bg-primary/90 disabled:opacity-60"
                    onclick={() => onsubmit(inputValue)}
                    disabled={sending}
                >
                    Submit
                </button>
                <button
                    class="rounded-md px-3 py-1 text-xs text-muted-foreground hover:bg-accent disabled:opacity-60"
                    onclick={oncancel}
                    disabled={sending}
                >
                    Cancel
                </button>
            </div>
        </div>
    {:else}
        <div class="mt-3 flex gap-2">
            <button
                class="rounded-md bg-secondary px-3 py-1 text-xs hover:bg-secondary/80 disabled:opacity-60"
                onclick={oncancel}
                disabled={sending}
            >
                Dismiss
            </button>
        </div>
    {/if}
</div>

```

src/lib/components/FolderSelector.svelte
```
<script lang="ts">
import { onDestroy } from "svelte";
import { FolderOpen, ChevronDown, Plus } from "@lucide/svelte";
import { open } from "@tauri-apps/plugin-dialog";
import { taskStore } from "$lib/stores/taskStore";

interface Props {
    value: string | null;
    onchange: (folder: string | null) => void;
    disabled?: boolean;
    locked?: boolean;
}

let { value, onchange, disabled = false, locked = false }: Props = $props();

let isOpen = $state(false);
let recentFolders = $state<string[]>([]);

const LOCKED_TITLE = "Working folder is locked for this task. Create a new task to use a different folder.";

// Subscribe to recent folders
const unsubscribe = taskStore.recentFolders.subscribe((folders) => {
    recentFolders = folders;
});

onDestroy(() => {
    unsubscribe();
});

function formatFolderName(path: string): string {
    const parts = path.split("/");
    const name = parts[parts.length - 1] || parts[parts.length - 2] || path;
    const parent = parts[parts.length - 2];
    if (parent && parent !== name) {
        return `${parent}/${name}`;
    }
    return name;
}

function toggle() {
    if (disabled || locked) return;
    isOpen = !isOpen;
}

function close() {
    isOpen = false;
}

function selectFolder(folder: string) {
    onchange(folder);
    taskStore.addRecentFolder(folder);
    close();
}

async function chooseFolder() {
    if (disabled || locked) {
        return;
    }

    close();
    try {
        const selected = await open({
            directory: true,
            multiple: false,
            title: "Choose working folder",
        });
        if (selected && typeof selected === "string") {
            onchange(selected);
            taskStore.addRecentFolder(selected);
        }
    } catch (e) {
        console.error("Folder picker error:", e);
    }
}

// Close on click outside
function handleClickOutside(event: MouseEvent) {
    const target = event.target as HTMLElement;
    if (!target.closest(".folder-selector")) {
        close();
    }
}

$effect(() => {
    if (isOpen) {
        document.addEventListener("click", handleClickOutside);
        return () => document.removeEventListener("click", handleClickOutside);
    }
});
</script>

<div class="folder-selector relative">
    <button
        type="button"
        class="flex items-center gap-1.5 rounded-md px-2 py-1 text-sm hover:bg-accent disabled:opacity-50"
        onclick={toggle}
        title={locked ? LOCKED_TITLE : undefined}
        {disabled}
    >
        <FolderOpen class="h-4 w-4 text-muted-foreground" />
        <span class="max-w-40 truncate text-muted-foreground">
            {value ? formatFolderName(value) : "Work in a folder"}
        </span>
        <ChevronDown class="h-3 w-3 text-muted-foreground" />
    </button>

    {#if isOpen}
        <div
            class="absolute bottom-full left-0 mb-1 w-72 rounded-lg border border-border bg-popover p-1 shadow-lg"
        >
            {#if recentFolders.length > 0}
                <div class="px-2 py-1 text-xs font-medium text-muted-foreground">Recent</div>
                {#each recentFolders as folder}
                    <button
                        type="button"
                        class="flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-left text-sm hover:bg-accent"
                        onclick={() => selectFolder(folder)}
                    >
                        <FolderOpen class="h-4 w-4 shrink-0 text-muted-foreground" />
                        <div class="min-w-0 flex-1">
                            <div class="truncate font-medium">{formatFolderName(folder)}</div>
                            <div class="truncate text-xs text-muted-foreground">{folder}</div>
                        </div>
                        {#if folder === value}
                            <span class="text-primary">✓</span>
                        {/if}
                    </button>
                {/each}
                <div class="my-1 border-t border-border"></div>
            {/if}

            <button
                type="button"
                class="flex w-full items-center gap-2 rounded-md px-2 py-1.5 text-left text-sm hover:bg-accent"
                onclick={chooseFolder}
            >
                <Plus class="h-4 w-4 text-muted-foreground" />
                <span>Choose a folder</span>
            </button>
        </div>
    {/if}
</div>

```

src/lib/components/ProviderList.svelte
```
<script lang="ts">
import { Trash2 } from "@lucide/svelte";

interface AuthEntry {
    provider: string;
    entryType: string;
}

interface Props {
    entries: AuthEntry[];
    loading: boolean;
    disabled: boolean;
    ondelete: (provider: string) => void;
}

let { entries, loading, disabled, ondelete }: Props = $props();

function formatEntryType(entryType: string) {
    return entryType === "api_key" ? "API key" : entryType;
}
</script>

<div class="rounded-lg border border-border bg-card">
    <div class="border-b border-border px-4 py-3 text-sm font-medium">Saved providers</div>
    <div class="px-4 py-3 text-sm text-muted-foreground">
        {#if loading}
            <div>Loading providers…</div>
        {:else if entries.length === 0}
            <div>No providers saved yet.</div>
        {:else}
            <div class="space-y-2">
                {#each entries as entry}
                    <div class="flex items-center justify-between rounded-md border border-border bg-background px-3 py-2">
                        <div>
                            <div class="text-sm font-medium text-foreground">{entry.provider}</div>
                            <div class="text-xs text-muted-foreground">{formatEntryType(entry.entryType)}</div>
                        </div>
                        <button
                            class="rounded-md p-2 text-muted-foreground hover:bg-accent disabled:opacity-60"
                            onclick={() => ondelete(entry.provider)}
                            disabled={disabled}
                            aria-label="Remove provider"
                        >
                            <Trash2 class="h-4 w-4" />
                        </button>
                    </div>
                {/each}
            </div>
        {/if}
    </div>
</div>

```

src/lib/components/QuickStartTiles.svelte
```
<script lang="ts">
interface Props {
    onselect: (prompt: string) => void;
}

let { onselect }: Props = $props();

const tiles = [
    { emoji: "📄", label: "Create a file", prompt: "Create a new file for me" },
    { emoji: "📊", label: "Crunch data", prompt: "Help me analyze and crunch some data" },
    { emoji: "🖼️", label: "Make a prototype", prompt: "Help me make a prototype" },
    { emoji: "📁", label: "Organize files", prompt: "Help me organize my files" },
    { emoji: "📅", label: "Prep for a meeting", prompt: "Help me prep for a meeting" },
    { emoji: "✉️", label: "Draft a message", prompt: "Help me draft a message" },
];
</script>

<div class="flex flex-col items-center justify-center py-12 px-4">
    <div class="text-4xl mb-4">✨</div>
    <h2 class="text-2xl font-semibold mb-8">Let's knock something off your list</h2>
    
    <div class="grid grid-cols-3 gap-3 w-full max-w-2xl">
        {#each tiles as tile}
            <button
                class="flex items-center gap-3 p-4 rounded-lg bg-muted/50 hover:bg-muted text-left transition-colors"
                onclick={() => onselect(tile.prompt)}
            >
                <span class="text-xl">{tile.emoji}</span>
                <span class="text-sm font-medium">{tile.label}</span>
            </button>
        {/each}
    </div>
</div>

```

src/lib/components/SetupRequired.svelte
```
<script lang="ts">
import { openPath } from "@tauri-apps/plugin-opener";

const {
    runtimeDir,
    manifestPath,
    qemuAvailable = null,
    qemuPath = null,
    accelAvailable = null,
    error = null,
    onRecheck = null,
} = $props<{
    runtimeDir: string;
    manifestPath: string;
    qemuAvailable?: boolean | null;
    qemuPath?: string | null;
    accelAvailable?: boolean | null;
    error?: string | null;
    onRecheck?: (() => void) | null;
}>();

let opening = $state(false);

async function openRuntimeDir() {
    if (!runtimeDir) return;
    opening = true;
    try {
        await openPath(runtimeDir);
    } finally {
        opening = false;
    }
}
</script>

<div class="flex h-screen items-center justify-center bg-background p-6">
    <div class="w-full max-w-xl rounded-lg border border-border bg-card p-6 shadow-sm">
        <div class="space-y-3">
            <h1 class="text-xl font-semibold">Runtime setup required</h1>
            <p class="text-sm text-muted-foreground">
                Piwork needs a local runtime pack before tasks can run. Drop the runtime pack into the
                folder below, then click “Recheck”.
            </p>
        </div>

        <div class="mt-4 space-y-2 text-sm">
            <div>
                <div class="text-xs uppercase tracking-wide text-muted-foreground">Runtime folder</div>
                <code class="mt-1 block rounded-md bg-muted px-3 py-2 text-xs">{runtimeDir}</code>
            </div>
            <div>
                <div class="text-xs uppercase tracking-wide text-muted-foreground">Manifest path</div>
                <code class="mt-1 block rounded-md bg-muted px-3 py-2 text-xs">{manifestPath}</code>
            </div>
            <div>
                <div class="text-xs uppercase tracking-wide text-muted-foreground">QEMU</div>
                {#if qemuAvailable}
                    <div class="mt-1 text-xs text-emerald-400">Installed</div>
                    {#if qemuPath}
                        <code class="mt-1 block rounded-md bg-muted px-3 py-2 text-xs">{qemuPath}</code>
                    {/if}
                {:else}
                    <div class="mt-1 text-xs text-destructive">Not found</div>
                    <div class="mt-1 text-xs text-muted-foreground">Install with: brew install qemu</div>
                {/if}
            </div>
            <div>
                <div class="text-xs uppercase tracking-wide text-muted-foreground">Hardware acceleration</div>
                {#if accelAvailable === null}
                    <div class="mt-1 text-xs text-muted-foreground">Unknown</div>
                {:else if accelAvailable}
                    <div class="mt-1 text-xs text-emerald-400">Available</div>
                {:else}
                    <div class="mt-1 text-xs text-destructive">Unavailable</div>
                {/if}
            </div>
            {#if error}
                <div class="rounded-md border border-destructive/40 bg-destructive/10 px-3 py-2 text-xs text-destructive">
                    {error}
                </div>
            {/if}
        </div>

        <div class="mt-6 flex flex-wrap gap-2">
            <button
                class="rounded-md bg-secondary px-3 py-2 text-sm hover:bg-secondary/80 disabled:opacity-60"
                onclick={openRuntimeDir}
                disabled={!runtimeDir || opening}
            >
                {opening ? "Opening…" : "Open runtime folder"}
            </button>
            <button
                class="rounded-md bg-primary px-3 py-2 text-sm text-primary-foreground hover:bg-primary/90"
                onclick={() => onRecheck?.()}
            >
                Recheck
            </button>
        </div>
        <div class="mt-6 space-y-1 text-xs text-muted-foreground">
            <div>Dev quickstart:</div>
            <code class="block rounded-md bg-muted px-3 py-2">mise run runtime-build</code>
            <code class="block rounded-md bg-muted px-3 py-2">mise run tauri-dev</code>
        </div>
    </div>
</div>

```

src/lib/components/layout/AppShell.svelte
```
<script lang="ts">
import { onMount, onDestroy } from "svelte";
import { invoke } from "@tauri-apps/api/core";
import { devLog } from "$lib/utils/devLog";
import SetupRequired from "$lib/components/SetupRequired.svelte";
import { taskStore } from "$lib/stores/taskStore";
import { previewStore } from "$lib/stores/previewStore";
import TopBar from "./TopBar.svelte";
import SettingsModal from "./SettingsModal.svelte";
import LeftRail from "./LeftRail.svelte";
import RightPanel from "./RightPanel.svelte";
import MainView from "./MainView.svelte";

interface RuntimeStatus {
    status: "missing" | "ready";
    runtimeDir: string;
    manifestPath: string;
    qemuAvailable: boolean;
    qemuPath: string | null;
    accelAvailable: boolean | null;
}

let showLeftRail = $state(true);
let showRightPanel = $state(import.meta.env.DEV);
let showSettings = $state(false);
let previewOpen = $state(false);
let runtimeStatus = $state<RuntimeStatus | null>(null);
let runtimeError = $state<string | null>(null);
let checkingRuntime = $state(true);
let unsubscribePreview: (() => void) | null = null;

async function loadRuntimeStatus() {
    devLog("AppShell", "loadRuntimeStatus");
    checkingRuntime = true;
    runtimeError = null;

    try {
        runtimeStatus = await invoke<RuntimeStatus>("runtime_status");
        devLog("AppShell", `runtime_status: ${runtimeStatus?.status}`);
    } catch (error) {
        devLog("AppShell", `runtime_status error: ${error}`);
        runtimeError = error instanceof Error ? error.message : String(error);
        runtimeStatus = null;
    } finally {
        checkingRuntime = false;
    }
}

function handleKeydown(e: KeyboardEvent) {
    // Escape closes settings
    if (e.key === "Escape" && showSettings) {
        e.preventDefault();
        showSettings = false;
    }
}

onMount(() => {
    devLog("AppShell", "onMount");
    void loadRuntimeStatus();
    void taskStore.load().catch((error) => {
        devLog("AppShell", `taskStore.load error: ${error}`);
    });

    unsubscribePreview = previewStore.subscribe((value) => {
        previewOpen = value.isOpen;
    });

    window.addEventListener("keydown", handleKeydown);
});

onDestroy(() => {
    unsubscribePreview?.();
    window.removeEventListener("keydown", handleKeydown);
});
</script>

{#if checkingRuntime}
    <div class="flex h-screen items-center justify-center bg-background text-sm text-muted-foreground">
        Checking runtime…
    </div>
{:else if runtimeStatus?.status === "missing" || runtimeError}
    <SetupRequired
        runtimeDir={runtimeStatus?.runtimeDir ?? ""}
        manifestPath={runtimeStatus?.manifestPath ?? ""}
        qemuAvailable={runtimeStatus?.qemuAvailable ?? false}
        qemuPath={runtimeStatus?.qemuPath ?? null}
        accelAvailable={runtimeStatus?.accelAvailable ?? null}
        error={runtimeError}
        onRecheck={loadRuntimeStatus}
    />
{:else}
    <div class="flex h-screen flex-col overflow-hidden">
        <TopBar bind:showLeftRail bind:showRightPanel onOpenSettings={() => (showSettings = true)} />
        <div class="flex flex-1 overflow-hidden">
            {#if showLeftRail && !previewOpen}
                <LeftRail />
            {/if}
            <MainView previewOpen={previewOpen} />
            {#if showRightPanel && !previewOpen}
                <RightPanel />
            {/if}
        </div>
    </div>
    <SettingsModal open={showSettings} onClose={() => (showSettings = false)} />
{/if}

```

src/lib/components/layout/LeftRail.svelte
```
<script lang="ts">
import { onDestroy, onMount } from "svelte";
import { dev } from "$app/environment";
import { Plus, MessageSquare, MoreHorizontal, Pencil, Archive, Trash2 } from "@lucide/svelte";
import { taskStore } from "$lib/stores/taskStore";
import type { TaskMetadata } from "$lib/types/task";

let tasks = $state<TaskMetadata[]>([]);
let visibleTasks = $state<TaskMetadata[]>([]);
let activeTaskId = $state<string | null>(null);
let unsubscribe: (() => void) | null = null;
let unsubscribeActive: (() => void) | null = null;
let creating = $state(false);
let deletingAll = $state(false);
let menuTaskId = $state<string | null>(null);
let editingTaskId = $state<string | null>(null);
let editingTitle = $state("");
let savingTask = $state(false);

const statusColors: Record<string, string> = {
    queued: "bg-muted-foreground",
    running: "bg-blue-500",
    blocked: "bg-yellow-500",
    done: "bg-green-500",
    failed: "bg-red-500",
    archived: "bg-muted-foreground",
};

onMount(() => {
    unsubscribe = taskStore.subscribe((value) => {
        tasks = value;
        visibleTasks = value.filter((task) => task.status !== "archived");
    });

    unsubscribeActive = taskStore.activeTaskId.subscribe((value) => {
        activeTaskId = value;
    });

    const handleClick = () => {
        menuTaskId = null;
    };

    window.addEventListener("click", handleClick);

    return () => {
        window.removeEventListener("click", handleClick);
    };
});

onDestroy(() => {
    unsubscribe?.();
    unsubscribeActive?.();
});

async function handleNewTask() {
    if (creating) return;
    creating = true;

    try {
        const task = taskStore.create("New Task");
        await taskStore.upsert(task);
        taskStore.setActive(task.id);
    } finally {
        creating = false;
    }
}

async function handleDeleteAllTasks() {
    if (deletingAll || tasks.length === 0) return;

    deletingAll = true;
    try {
        await taskStore.deleteAll();
    } finally {
        deletingAll = false;
    }
}

function openMenu(taskId: string, event: MouseEvent) {
    event.stopPropagation();
    menuTaskId = menuTaskId === taskId ? null : taskId;
}

function startRename(task: TaskMetadata, event: MouseEvent) {
    event.stopPropagation();
    editingTaskId = task.id;
    editingTitle = task.title || "";
    menuTaskId = null;
}

async function commitRename(taskId: string) {
    const task = tasks.find((item) => item.id === taskId);
    if (!task) {
        editingTaskId = null;
        return;
    }

    const title = editingTitle.trim();
    if (!title || title === task.title) {
        editingTaskId = null;
        return;
    }

    if (savingTask) return;
    savingTask = true;

    try {
        await taskStore.upsert({
            ...task,
            title,
            updatedAt: new Date().toISOString(),
        });
    } finally {
        savingTask = false;
        editingTaskId = null;
    }
}

function cancelRename() {
    editingTaskId = null;
    editingTitle = "";
}

async function archiveTask(task: TaskMetadata, event: MouseEvent) {
    event.stopPropagation();
    if (savingTask || task.status === "archived") return;
    savingTask = true;
    menuTaskId = null;

    try {
        await taskStore.upsert({
            ...task,
            status: "archived",
            updatedAt: new Date().toISOString(),
        });
    } finally {
        savingTask = false;
    }
}
</script>

<aside class="flex h-full w-56 flex-col border-r border-border bg-sidebar overflow-hidden">
    <div class="p-3 space-y-2">
        {#if dev}
            <button
                class="flex w-full items-center justify-center gap-2 rounded-md border border-destructive/40 bg-destructive/10 px-3 py-2 text-xs font-medium text-destructive hover:bg-destructive/20 disabled:opacity-60"
                onclick={handleDeleteAllTasks}
                disabled={deletingAll || tasks.length === 0}
            >
                <Trash2 class="h-3.5 w-3.5" />
                {deletingAll ? "Wiping…" : "Delete All Tasks"}
            </button>
        {/if}
        <button
            class="flex w-full items-center justify-center gap-2 rounded-md bg-primary px-3 py-2 text-sm font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-60"
            onclick={handleNewTask}
            disabled={creating}
        >
            <Plus class="h-4 w-4" />
            {creating ? "Creating…" : "New Task"}
        </button>
    </div>

    <nav class="flex-1 overflow-y-auto px-2">
        <ul class="space-y-1">
            {#if visibleTasks.length === 0}
                <li class="px-3 py-2 text-xs text-muted-foreground">No tasks yet</li>
            {:else}
                {#each visibleTasks as task}
                    <li class="relative">
                        <div
                            class="flex items-center gap-1 rounded-md px-2 py-1 hover:bg-sidebar-accent"
                            class:bg-sidebar-accent={activeTaskId === task.id}
                        >
                            <button
                                class="flex flex-1 min-w-0 items-center gap-2 rounded-md px-2 py-2 text-sm overflow-hidden"
                                type="button"
                                onclick={() => taskStore.setActive(task.id)}
                                aria-current={activeTaskId === task.id ? "true" : "false"}
                            >
                                <span
                                    class="h-2 w-2 shrink-0 rounded-full {statusColors[task.status] ?? "bg-muted-foreground"}"
                                ></span>
                                <MessageSquare class="h-4 w-4 shrink-0 text-muted-foreground" />
                                {#if editingTaskId === task.id}
                                    <input
                                        class="w-full rounded-md border border-border bg-background px-2 py-1 text-sm"
                                        bind:value={editingTitle}
                                        onkeydown={(event) => {
                                            if (event.key === "Enter") {
                                                event.preventDefault();
                                                void commitRename(task.id);
                                            }
                                            if (event.key === "Escape") {
                                                event.preventDefault();
                                                cancelRename();
                                            }
                                        }}
                                        onblur={() => void commitRename(task.id)}
                                    />
                                {:else}
                                    <span class="truncate text-left">{task.title || "Untitled task"}</span>
                                {/if}
                            </button>
                            <button
                                class="rounded-md p-2 text-muted-foreground hover:bg-accent"
                                onclick={(event) => openMenu(task.id, event)}
                                aria-label="Task menu"
                            >
                                <MoreHorizontal class="h-4 w-4" />
                            </button>
                        </div>
                        {#if menuTaskId === task.id}
                            <div
                                class="absolute right-2 top-full z-10 mt-1 w-40 rounded-md border border-border bg-popover p-1 text-xs shadow-lg"
                                role="menu"
                            >
                                <button
                                    class="flex w-full items-center gap-2 rounded-md px-2 py-2 text-left hover:bg-accent"
                                    onclick={(event) => startRename(task, event)}
                                >
                                    <Pencil class="h-3.5 w-3.5" />
                                    Rename
                                </button>
                                <button
                                    class="flex w-full items-center gap-2 rounded-md px-2 py-2 text-left text-destructive hover:bg-accent"
                                    onclick={(event) => archiveTask(task, event)}
                                >
                                    <Archive class="h-3.5 w-3.5" />
                                    Archive
                                </button>
                            </div>
                        {/if}
                    </li>
                {/each}
            {/if}
        </ul>
    </nav>
</aside>

```

src/lib/components/layout/MainView.svelte
```
<script lang="ts">
import { onDestroy, onMount } from "svelte";
import { get } from "svelte/store";
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import { openPath, openUrl } from "@tauri-apps/plugin-opener";
import { Send, Paperclip, FolderOpen, Loader2, X } from "@lucide/svelte";
import { devLog } from "$lib/utils/devLog";
import { MessageAccumulator } from "$lib/rpc";
import type { RpcPayload, ConversationState } from "$lib/rpc";
import { taskStore } from "$lib/stores/taskStore";
import { artifactRefreshStore } from "$lib/stores/artifactRefreshStore";
import { runtimeDebugStore } from "$lib/stores/runtimeDebugStore";
import type { TaskMetadata } from "$lib/types/task";
import FolderSelector from "$lib/components/FolderSelector.svelte";
import QuickStartTiles from "$lib/components/QuickStartTiles.svelte";
import ExtensionUiDialog from "$lib/components/ExtensionUiDialog.svelte";
import type { ExtensionUiRequest } from "$lib/components/ExtensionUiDialog.svelte";
import { RuntimeService, type RuntimeServiceSnapshot } from "$lib/services/runtimeService";
import { normalizeAuthProfile } from "$lib/services/authProfile";
import { previewStore, type PreviewSelection } from "$lib/stores/previewStore";

let { previewOpen = false }: { previewOpen?: boolean } = $props();

let prompt = $state("");
let textareaEl: HTMLTextAreaElement | undefined = $state();
let runtimeService: RuntimeService | null = $state(null);
let unsubscribeRuntimeService: (() => void) | null = null;
let messageAccumulator = new MessageAccumulator();
let conversation = $state<ConversationState>(messageAccumulator.getState());
let rpcConnected = $state(false);
let rpcConnecting = $state(false);
let rpcError = $state<string | null>(null);
let rpcAuthHint = $state<string | null>(null);
let rpcLoginUrl = $state<string | null>(null);
let openingLoginUrl = $state(false);
let copyingLoginUrl = $state(false);
let loginCopied = $state(false);
let loginPromptVisible = $state(false);
let loginPromptedUrl = $state<string | null>(null);
let loginPromptCountdown = $state<number | null>(null);
let autoOpenLogin = $state(false);
let rpcStateInfo = $state<string | null>(null);
let rpcStateRequested = $state(false);
let rpcModelsRequested = $state(false);
let pendingUiRequest = $state<ExtensionUiRequest | null>(null);
let pendingUiQueue = $state<ExtensionUiRequest[]>([]);

let pendingUiSending = $state(false);
let vmLogPath = $state<string | null>(null);
let openingLog = $state(false);

interface DevToast {
    id: number;
    message: string;
}

let devToasts = $state<DevToast[]>([]);
let devToastCounter = 0;
const DEV_TOAST_TTL_MS = 5000;

// Task/runtime tracking
let currentTaskId = $state<string | null>(null);
let currentWorkingFolder = $state<string | null>(null);
let activeTask = $state<TaskMetadata | null>(null);
let currentSessionFile = $state<string | null>(null);
let workspaceRoot = $state<string | null>(null);
let authProfile = $state("default");
let taskSwitching = $state(false);
let unsubscribeActiveTask: (() => void) | null = null;

interface PreviewReadResponse {
    path: string;
    mimeType: string;
    encoding: "utf8" | "base64";
    content: string;
    truncated: boolean;
    size: number;
}

let previewSelection = $state<PreviewSelection>({
    isOpen: false,
    taskId: null,
    relativePath: null,
    requestId: 0,
    source: "preview",
    artifactSource: null,
});
let previewLoading = $state(false);
let previewError = $state<string | null>(null);
let previewContent = $state<PreviewReadResponse | null>(null);
let unsubscribePreview: (() => void) | null = null;
let previewRequestId = 0;

interface ModelOption {
    id: string;
    label: string;
    provider: string | null;
}

// Preferred model patterns - filter to just these
const PREFERRED_MODEL_PATTERNS = ["claude-opus-4-5", "gpt-5.2-codex", "gemini-3-pro"];

const fallbackModels: ModelOption[] = [
    { id: "claude-opus-4-5", label: "Opus 4.5", provider: "anthropic" },
    { id: "gpt-5.2-codex", label: "GPT 5.2", provider: "openai-codex" },
    { id: "gemini-3-pro-preview", label: "Gemini 3 Pro", provider: "google-gemini-cli" },
];

function isPreferredModel(id: string): boolean {
    return PREFERRED_MODEL_PATTERNS.some((pattern) => id.includes(pattern) || id.startsWith(pattern.split("-")[0]));
}

let availableModels = $state<ModelOption[]>([...fallbackModels]);
let selectedModelId = $state(fallbackModels[0]?.id ?? "");

const MAX_HEIGHT = 200;
const LOGIN_PROMPT_SECONDS = 5;
const LOGIN_AUTO_OPEN_KEY = "piwork:auto-open-login";

let loginPromptTimer: ReturnType<typeof setInterval> | null = null;

function autoGrow() {
    if (!textareaEl) return;
    textareaEl.style.height = "auto";
    textareaEl.style.height = Math.min(textareaEl.scrollHeight, MAX_HEIGHT) + "px";
    textareaEl.style.overflowY = textareaEl.scrollHeight > MAX_HEIGHT ? "auto" : "hidden";
}

function handleInputKeydown(e: KeyboardEvent) {
    // Enter sends, Shift+Enter adds newline
    if (e.key === "Enter" && !e.shiftKey) {
        e.preventDefault();
        void sendPrompt();
    }
}

function pushRpcMessage(message: string) {
    // Log to console for debugging (visible in terminal)
    devLog("RPC", message);
    maybeCaptureLoginUrl(message);
}

function pushDevToast(message: string) {
    if (!import.meta.env.DEV) {
        return;
    }

    const trimmed = message.trim();
    if (!trimmed) {
        return;
    }

    const id = ++devToastCounter;
    devToasts = [...devToasts, { id, message: trimmed }];

    setTimeout(() => {
        devToasts = devToasts.filter((toast) => toast.id !== id);
    }, DEV_TOAST_TTL_MS);
}

function extractUrl(message: string) {
    const match = message.match(/https?:\/\/[^\s)]+/);
    return match?.[0] ?? null;
}

function maybeCaptureLoginUrl(message: string) {
    const url = extractUrl(message);
    if (!url) return;

    const lower = message.toLowerCase();
    if (lower.includes("login") || lower.includes("oauth") || lower.includes("authorize")) {
        if (rpcLoginUrl !== url) {
            rpcLoginUrl = url;
            loginCopied = false;
            copyingLoginUrl = false;
            startLoginPrompt(url);
        }
    }
}

function stopLoginCountdown() {
    loginPromptCountdown = null;

    if (loginPromptTimer) {
        clearInterval(loginPromptTimer);
        loginPromptTimer = null;
    }
}

function setAutoOpenLogin(enabled: boolean) {
    autoOpenLogin = enabled;

    try {
        localStorage.setItem(LOGIN_AUTO_OPEN_KEY, enabled ? "true" : "false");
    } catch {
        // Ignore storage errors.
    }

    if (!enabled) {
        stopLoginCountdown();
        return;
    }

    if (rpcLoginUrl && loginPromptVisible && loginPromptedUrl === rpcLoginUrl) {
        startLoginPrompt(rpcLoginUrl);
    }
}

function clearLoginPrompt() {
    loginPromptVisible = false;
    loginPromptedUrl = null;
    stopLoginCountdown();
}

function startLoginPrompt(url: string) {
    clearLoginPrompt();
    loginPromptVisible = true;
    loginPromptedUrl = url;

    if (!autoOpenLogin) {
        loginPromptCountdown = null;
        return;
    }

    loginPromptCountdown = LOGIN_PROMPT_SECONDS;

    loginPromptTimer = setInterval(() => {
        if (!loginPromptVisible || loginPromptedUrl !== url || loginPromptCountdown === null) {
            clearLoginPrompt();
            return;
        }

        if (loginPromptCountdown <= 1) {
            clearLoginPrompt();
            void openLoginUrl();
            return;
        }

        loginPromptCountdown -= 1;
    }, 1000);
}

function updateAuthHint(message: string) {
    const lower = message.toLowerCase();
    const needsAuth =
        lower.includes("auth") ||
        lower.includes("login") ||
        lower.includes("api key") ||
        lower.includes("credential") ||
        lower.includes("unauthorized") ||
        lower.includes("token");

    if (!needsAuth) return;

    rpcAuthHint =
        "Auth required. Import credentials from pi in Settings, then restart runtime. Fallback: `mise run runtime-build-auth` (optional `PIWORK_AUTH_PATH=...`).";

    maybeCaptureLoginUrl(message);
}

function resolveModelOption(model: Record<string, unknown> | undefined) {
    if (!model) return null;

    const id = typeof model.id === "string" ? model.id : null;
    if (!id) return null;

    const label = typeof model.name === "string" ? model.name : id;
    const provider = typeof model.provider === "string" ? model.provider : null;

    return { id, label, provider } satisfies ModelOption;
}

function parseStringArray(value: unknown) {
    if (!Array.isArray(value)) return undefined;
    const filtered = value.filter((item) => typeof item === "string") as string[];
    return filtered.length > 0 ? filtered : undefined;
}

function parseExtensionUiRequest(payload: Record<string, unknown>): ExtensionUiRequest | null {
    const id = typeof payload.id === "string" ? payload.id : null;
    const method = typeof payload.method === "string" ? payload.method : null;

    if (!id || !method) return null;

    return {
        id,
        method,
        title: typeof payload.title === "string" ? payload.title : undefined,
        message: typeof payload.message === "string" ? payload.message : undefined,
        options: parseStringArray(payload.options),
        placeholder: typeof payload.placeholder === "string" ? payload.placeholder : undefined,
        prefill: typeof payload.prefill === "string" ? payload.prefill : undefined,
    };
}

function applyRuntimeSnapshot(snapshot: RuntimeServiceSnapshot) {
    rpcConnected = snapshot.rpcConnected;
    rpcConnecting = snapshot.rpcConnecting;
    rpcError = snapshot.rpcError;
    currentTaskId = snapshot.currentTaskId;
    currentWorkingFolder = snapshot.currentWorkingFolder;
    currentSessionFile = snapshot.currentSessionFile;
    workspaceRoot = snapshot.workspaceRoot;
    authProfile = snapshot.authProfile;
    taskSwitching = snapshot.taskSwitching;
}

function getRpcClient() {
    return runtimeService?.getRpcClient() ?? null;
}

function queueUiRequest(request: ExtensionUiRequest) {
    if (!pendingUiRequest) {
        pendingUiRequest = request;
        return;
    }
    pendingUiQueue = [...pendingUiQueue, request];
}

function clearUiRequest() {
    pendingUiRequest = null;
    pendingUiSending = false;

    if (pendingUiQueue.length > 0) {
        const [next, ...rest] = pendingUiQueue;
        pendingUiQueue = rest;
        pendingUiRequest = next;
    }
}

async function sendUiResponse(response: Record<string, unknown>) {
    if (!runtimeService || !pendingUiRequest || pendingUiSending) return;
    pendingUiSending = true;

    try {
        await runtimeService.send({ type: "extension_ui_response", id: pendingUiRequest.id, ...response });
    } finally {
        clearUiRequest();
    }
}

async function handleUiConfirm(confirmed: boolean) {
    await sendUiResponse({ confirmed });
}

async function handleUiSelect(value: string) {
    await sendUiResponse({ value });
}

async function handleUiSubmit(value: string) {
    await sendUiResponse({ value });
}

async function handleUiCancel() {
    await sendUiResponse({ cancelled: true });
}

async function sendLogin() {
    const sent = await sendPrompt("/login");
    if (sent) {
        pushRpcMessage("[info] Sent /login");
    }
}

function ensureModelOption(option: ModelOption) {
    if (availableModels.some((model) => model.id === option.id)) {
        return;
    }

    availableModels = [option, ...availableModels];
}

async function refreshVmLogPath() {
    vmLogPath = await RuntimeService.refreshVmLogPath();
}

async function openVmLog() {
    if (!vmLogPath || openingLog) return;
    openingLog = true;

    try {
        await openPath(vmLogPath);
    } finally {
        openingLog = false;
    }
}

async function openLoginUrl() {
    if (!rpcLoginUrl || openingLoginUrl) return;
    openingLoginUrl = true;
    clearLoginPrompt();

    try {
        await openUrl(rpcLoginUrl);
    } finally {
        openingLoginUrl = false;
    }
}

function dismissLoginPrompt() {
    clearLoginPrompt();
}

async function copyLoginUrl() {
    if (!rpcLoginUrl || copyingLoginUrl) return;

    if (!navigator?.clipboard) {
        pushRpcMessage("[error] Clipboard unavailable");
        return;
    }

    copyingLoginUrl = true;
    loginCopied = false;

    try {
        await navigator.clipboard.writeText(rpcLoginUrl);
        loginCopied = true;
        setTimeout(() => {
            loginCopied = false;
        }, 2000);
    } catch {
        pushRpcMessage("[error] Failed to copy login URL");
    } finally {
        copyingLoginUrl = false;
    }
}

async function requestState() {
    if (!runtimeService || rpcStateRequested) return;
    rpcStateRequested = true;
    await runtimeService.send({ type: "get_state" });
}

async function requestAvailableModels() {
    if (!runtimeService || rpcModelsRequested) return;
    rpcModelsRequested = true;
    await runtimeService.send({ type: "get_available_models" });
}

async function handleModelChange() {
    if (!runtimeService) return;

    const selected = availableModels.find((model) => model.id === selectedModelId) ?? null;
    if (!selected?.provider) {
        pushRpcMessage("[info] Model provider unknown; waiting for available models.");
        return;
    }

    await runtimeService.send({ type: "set_model", provider: selected.provider, modelId: selected.id });
}

function formatStateInfo(data: Record<string, unknown> | undefined) {
    if (!data) return null;

    let modelName: string | null = null;
    if (typeof data.model === "object" && data.model !== null) {
        const model = data.model as Record<string, unknown>;
        if (typeof model.name === "string") {
            modelName = model.name;
        } else if (typeof model.id === "string") {
            modelName = model.id;
        }
    }

    const sessionName = typeof data.sessionName === "string" ? data.sessionName : null;
    const sessionId = typeof data.sessionId === "string" ? data.sessionId : null;
    const isStreaming = typeof data.isStreaming === "boolean" ? data.isStreaming : null;

    const parts: string[] = [];
    if (modelName) {
        parts.push(`Model: ${modelName}`);
    }
    if (sessionName) {
        parts.push(`Session: ${sessionName}`);
    } else if (sessionId) {
        parts.push(`Session: ${sessionId.slice(0, 8)}`);
    }
    if (isStreaming !== null) {
        parts.push(`Streaming: ${isStreaming ? "yes" : "no"}`);
    }

    return parts.length > 0 ? parts.join(" · ") : null;
}

function handleRpcPayload(payload: Record<string, unknown>) {
    // Feed to message accumulator for proper conversation tracking
    messageAccumulator.processEvent(payload as RpcPayload);
    conversation = messageAccumulator.getState();

    // Auto-save conversation when agent completes a turn
    if (payload.type === "agent_end" && currentTaskId) {
        void taskStore.saveConversation(currentTaskId, messageAccumulator.serialize());
        devLog("MainView", `Auto-saved conversation after agent_end`);
    }

    const type = payload.type;

    if ((type === "tool_execution_end" || type === "turn_end" || type === "agent_end") && currentTaskId) {
        artifactRefreshStore.request(currentTaskId, type);
    }

    if (type === "turn_end" || type === "agent_end") {
        void requestState();
    }

    if (type === "response") {
        const command = typeof payload.command === "string" ? payload.command : null;

        if (command === "get_state") {
            rpcStateRequested = false;

            if (payload.success === true) {
                const data = payload.data as Record<string, unknown> | undefined;
                const info = formatStateInfo(data);
                rpcStateInfo = info;
                runtimeDebugStore.updateFromGetState(data);

                const model =
                    typeof data?.model === "object" && data.model !== null
                        ? (data.model as Record<string, unknown>)
                        : null;
                const option = model ? resolveModelOption(model) : null;
                if (option) {
                    ensureModelOption(option);
                    selectedModelId = option.id;
                }
            } else {
                const error = payload.error;
                if (typeof error === "string") {
                    pushRpcMessage(`[error] ${error}`);
                    updateAuthHint(error);
                } else {
                    pushRpcMessage("[error] get_state failed");
                }
                rpcStateInfo = null;
                runtimeDebugStore.clear();
            }

            return;
        }

        if (command === "get_available_models") {
            rpcModelsRequested = false;

            if (payload.success === true) {
                const data = payload.data as Record<string, unknown> | undefined;
                const models = Array.isArray(data?.models) ? data?.models : [];
                const mapped = models
                    .filter((model) => typeof model === "object" && model !== null)
                    .map((model) => resolveModelOption(model as Record<string, unknown>))
                    .filter((model): model is ModelOption => Boolean(model))
                    .filter((model) => isPreferredModel(model.id));

                if (mapped.length > 0) {
                    availableModels = mapped;
                    if (!mapped.some((model) => model.id === selectedModelId)) {
                        selectedModelId = mapped[0].id;
                    }
                }
            } else {
                const error = payload.error;
                if (typeof error === "string") {
                    pushRpcMessage(`[error] ${error}`);
                    updateAuthHint(error);
                } else {
                    pushRpcMessage("[error] get_available_models failed");
                }
            }

            return;
        }

        if (command === "set_model") {
            if (payload.success === true) {
                const data = payload.data as Record<string, unknown> | undefined;
                const option = data ? resolveModelOption(data) : null;
                if (option) {
                    ensureModelOption(option);
                    selectedModelId = option.id;
                }
                void requestState();
            } else {
                const error = payload.error;
                if (typeof error === "string") {
                    pushRpcMessage(`[error] ${error}`);
                    updateAuthHint(error);
                } else {
                    pushRpcMessage("[error] set_model failed");
                }
            }

            return;
        }

        if (payload.success === false) {
            const error = payload.error;
            if (typeof error === "string") {
                pushRpcMessage(`[error] ${error}`);
                updateAuthHint(error);
                return;
            }
        }
    }

    if (type === "extension_ui_request") {
        const request = parseExtensionUiRequest(payload);
        if (!request) {
            pushRpcMessage("[ui] Received malformed UI request");
            return;
        }

        if (request.method === "notify") {
            const message = request.message ?? "Notification";
            pushRpcMessage(`[notify] ${message}`);
            return;
        }

        if (request.message) {
            maybeCaptureLoginUrl(request.message);
        }
        if (request.title) {
            maybeCaptureLoginUrl(request.title);
        }

        if (request.method === "setStatus") {
            const statusKey = typeof payload.statusKey === "string" ? payload.statusKey : "status";
            const statusText = typeof payload.statusText === "string" ? payload.statusText : "";
            pushRpcMessage(`[status] ${statusKey}: ${statusText}`);
            return;
        }

        if (request.method === "setWidget") {
            const widgetKey = typeof payload.widgetKey === "string" ? payload.widgetKey : "widget";
            pushRpcMessage(`[widget] ${widgetKey}`);
            return;
        }

        queueUiRequest(request);
        pushRpcMessage(`[ui] ${request.method} requested`);
        return;
    }

    // message_update, message_end, tool_execution events are handled by MessageAccumulator
}

async function initializeRuntimeService() {
    if (runtimeService) {
        return;
    }

    runtimeService = new RuntimeService({
        onConnected: () => {
            rpcAuthHint = null;
            rpcLoginUrl = null;
            loginCopied = false;
            copyingLoginUrl = false;
            clearLoginPrompt();
            void requestState();
            void requestAvailableModels();
        },
        onError: (message) => {
            rpcAuthHint = null;
            rpcLoginUrl = null;
            loginCopied = false;
            copyingLoginUrl = false;
            clearLoginPrompt();
            rpcStateInfo = null;
            rpcStateRequested = false;
            rpcModelsRequested = false;
            runtimeDebugStore.clear();
            pushDevToast(message);
            void refreshVmLogPath();
        },
        onRpcPayload: handleRpcPayload,
        onRawRpcMessage: pushRpcMessage,
        onStateRefreshRequested: () => {
            void requestState();
        },
    });

    unsubscribeRuntimeService = runtimeService.subscribe(applyRuntimeSnapshot);
    devLog("MainView", "Runtime initialized");
}

async function connectRpc() {
    if (!runtimeService) return;

    rpcAuthHint = null;
    rpcLoginUrl = null;
    loginCopied = false;
    copyingLoginUrl = false;
    clearLoginPrompt();
    rpcStateInfo = null;
    rpcStateRequested = false;
    rpcModelsRequested = false;
    runtimeDebugStore.clear();
    pendingUiRequest = null;
    pendingUiQueue = [];
    pendingUiSending = false;

    await runtimeService.connectRpc();
}

async function disconnectRpc() {
    if (!runtimeService) return;

    await runtimeService.disconnectRpc();
    rpcAuthHint = null;
    rpcLoginUrl = null;
    loginCopied = false;
    copyingLoginUrl = false;
    clearLoginPrompt();
    rpcStateInfo = null;
    rpcStateRequested = false;
    rpcModelsRequested = false;
    runtimeDebugStore.clear();
    pendingUiRequest = null;
    pendingUiQueue = [];
    pendingUiSending = false;
}

async function sendPrompt(message?: string): Promise<boolean> {
    if (!runtimeService) return false;

    const content = (message ?? prompt).trim();
    if (!content) return false;

    // Auto-create task if none active
    if (!currentTaskId) {
        const title = content.length > 50 ? content.substring(0, 50) + "…" : content;
        const task = taskStore.create(title, currentWorkingFolder);
        await taskStore.upsert(task);
        taskStore.setActive(task.id);
        devLog("MainView", `Auto-created task: ${task.id} with folder: ${currentWorkingFolder}`);
    }

    try {
        await runtimeService.waitForTaskSwitchComplete();
        await runtimeService.waitForRpcReady();
    } catch (error) {
        devLog("MainView", `Prompt blocked until runtime ready: ${error}`);
        return false;
    }

    if (!getRpcClient() || !rpcConnected || taskSwitching) {
        return false;
    }

    if (currentTaskId && activeTask && activeTask.title === "New Task" && conversation.messages.length === 0) {
        const nextTitle = content.length > 50 ? `${content.substring(0, 50)}…` : content;
        await taskStore.upsert({
            ...activeTask,
            title: nextTitle,
            updatedAt: new Date().toISOString(),
        });
    }

    // Add user message to conversation
    messageAccumulator.addUserMessage(content);
    conversation = messageAccumulator.getState();

    try {
        await runtimeService.sendPrompt(content);
        prompt = "";
        return true;
    } catch (error) {
        devLog("MainView", `Prompt send failed: ${error}`);
        return false;
    }
}

let testPromptUnlisten: (() => void) | null = null;
let testFolderUnlisten: (() => void) | null = null;
let testTaskUnlisten: (() => void) | null = null;
let testCreateTaskUnlisten: (() => void) | null = null;
let testDeleteAllTasksUnlisten: (() => void) | null = null;
let testDumpStateUnlisten: (() => void) | null = null;
let testOpenPreviewUnlisten: (() => void) | null = null;
let testSetAuthProfileUnlisten: (() => void) | null = null;
let testSendLoginUnlisten: (() => void) | null = null;

async function saveConversationForTask(taskId: string | null): Promise<void> {
    if (!taskId || messageAccumulator.getState().messages.length === 0) {
        return;
    }

    const list = get(taskStore);
    const hasTask = list.some((task) => task.id === taskId);
    if (!hasTask) {
        return;
    }

    try {
        await taskStore.saveConversation(taskId, messageAccumulator.serialize());
        devLog("MainView", `Saved conversation to task ${taskId}`);
    } catch (error) {
        devLog("MainView", `Failed to save conversation: ${error}`);
    }
}

async function loadConversationForTask(taskId: string | null): Promise<void> {
    messageAccumulator.reset();
    conversation = messageAccumulator.getState();

    if (!taskId) {
        return;
    }

    try {
        const saved = await taskStore.loadConversation(taskId);
        if (!saved) {
            return;
        }

        messageAccumulator.loadState(saved);
        conversation = messageAccumulator.getState();
        devLog("MainView", `Loaded conversation for task ${taskId}`);
    } catch (error) {
        devLog("MainView", `Failed to load conversation: ${error}`);
    }
}

async function persistWorkingFolderForActiveTask(folder: string | null): Promise<void> {
    if (!currentTaskId) {
        return;
    }

    const list = await invoke<TaskMetadata[]>("task_store_list");
    const task = list.find((item) => item.id === currentTaskId);
    if (!task) {
        return;
    }

    await taskStore.upsert({
        ...task,
        workingFolder: folder,
        updatedAt: new Date().toISOString(),
    });
}

async function handleTaskSwitch(newTask: TaskMetadata | null): Promise<void> {
    if (!runtimeService) {
        return;
    }

    try {
        await runtimeService.handleTaskSwitch(newTask, {
            saveConversationForTask,
            loadConversationForTask,
        });
    } catch (error) {
        devLog("MainView", `Task switch failed: ${error}`);
    }
}

async function handleFolderChange(folder: string | null): Promise<void> {
    if (!runtimeService) {
        return;
    }

    const requestedFolder = typeof folder === "string" ? folder.trim() : "";

    try {
        if (!currentTaskId && requestedFolder) {
            const task = taskStore.create("New Task");
            await taskStore.upsert(task);
            await handleTaskSwitch(task);
            taskStore.setActive(task.id);
        }

        await runtimeService.handleFolderChange(requestedFolder || null, {
            persistWorkingFolderForActiveTask,
        });
    } catch (error) {
        const message = error instanceof Error ? error.message : String(error);
        devLog("MainView", `Folder change failed: ${message}`);
        pushDevToast(`Folder change failed: ${message}`);
    }
}

async function applyAuthProfileForTest(profileValue: string | null | undefined): Promise<void> {
    const profile = normalizeAuthProfile(profileValue);

    try {
        localStorage.setItem("piwork:auth-profile", profile);
    } catch {
        // Ignore storage errors in test flows.
    }

    authProfile = profile;
    devLog("TestHarness", `applying auth profile: ${profile}`);

    const previousTaskId = currentTaskId;

    if (previousTaskId) {
        taskStore.setActive(null);
    }

    await disconnectRpc();
    await invoke("vm_stop").catch((error) => {
        devLog("MainView", `vm_stop failed during auth profile apply: ${error}`);
    });
    await connectRpc();

    if (previousTaskId) {
        taskStore.setActive(previousTaskId);
    }
}

function formatBytes(bytes: number): string {
    if (bytes < 1024) {
        return `${bytes} B`;
    }

    if (bytes < 1024 * 1024) {
        return `${(bytes / 1024).toFixed(1)} KB`;
    }

    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function closePreview() {
    previewStore.close();
}

async function loadPreviewForSelection(selection: PreviewSelection): Promise<void> {
    previewSelection = selection;
    const requestId = ++previewRequestId;

    if (!selection.isOpen || !selection.taskId || !selection.relativePath) {
        previewError = null;
        previewContent = null;
        previewLoading = false;
        return;
    }

    if (selection.taskId !== currentTaskId) {
        taskStore.setActive(selection.taskId);
    }

    previewLoading = true;
    previewError = null;

    try {
        const response =
            selection.source === "artifact"
                ? await invoke<PreviewReadResponse>("task_artifact_read", {
                      taskId: selection.taskId,
                      source: selection.artifactSource ?? "outputs",
                      relativePath: selection.relativePath,
                  })
                : await invoke<PreviewReadResponse>("task_preview_read", {
                      taskId: selection.taskId,
                      relativePath: selection.relativePath,
                  });

        if (requestId !== previewRequestId) {
            return;
        }

        previewContent = response;
    } catch (error) {
        if (requestId !== previewRequestId) {
            return;
        }

        previewError = error instanceof Error ? error.message : String(error);
        previewContent = null;
    } finally {
        if (requestId === previewRequestId) {
            previewLoading = false;
        }
    }
}

onMount(() => {
    try {
        const stored = localStorage.getItem(LOGIN_AUTO_OPEN_KEY);
        if (stored === "true") {
            autoOpenLogin = true;
        } else if (stored === "false") {
            autoOpenLogin = false;
        }
    } catch {
        // Ignore storage errors.
    }

    void (async () => {
        try {
            await initializeRuntimeService();
            await connectRpc();

            // Subscribe to active task changes
            unsubscribeActiveTask = taskStore.activeTask.subscribe((task) => {
                activeTask = task;
                void handleTaskSwitch(task);
            });

            unsubscribePreview = previewStore.subscribe((selection) => {
                void loadPreviewForSelection(selection);
            });
        } catch (error) {
            devLog("MainView", `Failed to initialize runtime service: ${error}`);
        }
    })();

    void refreshVmLogPath();

    // Test harness listeners (dev only)
    if (import.meta.env.DEV) {
        listen<string>("test_prompt", (event) => {
            devLog("TestHarness", `received test_prompt: ${event.payload}`);
            prompt = event.payload;
            void sendPrompt();
        }).then((unlisten) => {
            testPromptUnlisten = unlisten;
        });

        listen<string | null>("test_set_folder", (event) => {
            devLog("TestHarness", `received test_set_folder: ${event.payload}`);
            void handleFolderChange(event.payload);
        }).then((unlisten) => {
            testFolderUnlisten = unlisten;
        });

        listen<string | null>("test_set_task", (event) => {
            devLog("TestHarness", `received test_set_task: ${event.payload}`);
            taskStore.setActive(event.payload ?? null);
        }).then((unlisten) => {
            testTaskUnlisten = unlisten;
        });

        listen<string | null>("test_set_auth_profile", (event) => {
            devLog("TestHarness", `received test_set_auth_profile: ${event.payload}`);
            void applyAuthProfileForTest(event.payload);
        }).then((unlisten) => {
            testSetAuthProfileUnlisten = unlisten;
        });

        listen("test_send_login", () => {
            devLog("TestHarness", "received test_send_login");
            void sendLogin();
        }).then((unlisten) => {
            testSendLoginUnlisten = unlisten;
        });

        listen<{ title?: string | null; workingFolder?: string | null }>("test_create_task", (event) => {
            const title = event.payload?.title ?? "New Task";
            const folder = event.payload?.workingFolder ?? null;
            devLog("TestHarness", `received test_create_task: ${title}`);

            const task = taskStore.create(title, folder);
            void taskStore.upsert(task).then(() => {
                taskStore.setActive(task.id);
            });
        }).then((unlisten) => {
            testCreateTaskUnlisten = unlisten;
        });

        listen("test_delete_all_tasks", () => {
            devLog("TestHarness", "received test_delete_all_tasks");
            void taskStore.deleteAll();
        }).then((unlisten) => {
            testDeleteAllTasksUnlisten = unlisten;
        });

        listen("test_dump_state", () => {
            const messageCount = conversation.messages.length;
            const hasStreaming = conversation.isAgentRunning;
            devLog(
                "TestHarness",
                `state: task=${currentTaskId ?? "none"} session=${currentSessionFile ?? "none"} folder=${
                    currentWorkingFolder ?? "none"
                } root=${workspaceRoot ?? "none"} auth=${authProfile} messages=${messageCount} streaming=${hasStreaming} switching=${taskSwitching}`,
            );
        }).then((unlisten) => {
            testDumpStateUnlisten = unlisten;
        });

        listen<{ taskId?: string | null; relativePath?: string | null }>("test_open_preview", (event) => {
            const taskId = event.payload?.taskId ?? null;
            const relativePath = event.payload?.relativePath ?? null;
            devLog("TestHarness", `received test_open_preview: task=${taskId} path=${relativePath}`);

            if (taskId && relativePath) {
                previewStore.open(taskId, relativePath);
            }
        }).then((unlisten) => {
            testOpenPreviewUnlisten = unlisten;
        });
    }
});

onDestroy(() => {
    // Save conversation before unmounting
    if (currentTaskId && messageAccumulator.getState().messages.length > 0) {
        void taskStore.saveConversation(currentTaskId, messageAccumulator.serialize());
    }
    unsubscribeActiveTask?.();
    unsubscribePreview?.();
    unsubscribeRuntimeService?.();
    void disconnectRpc();
    testPromptUnlisten?.();
    testFolderUnlisten?.();
    testTaskUnlisten?.();
    testSetAuthProfileUnlisten?.();
    testSendLoginUnlisten?.();
    testCreateTaskUnlisten?.();
    testDeleteAllTasksUnlisten?.();
    testDumpStateUnlisten?.();
    testOpenPreviewUnlisten?.();
});
</script>

<main class="flex min-h-0 flex-1 bg-background">
    <div class="flex min-h-0 flex-1 flex-col {previewOpen && previewSelection.isOpen ? 'border-r border-border' : ''}">
    <!-- Chat transcript area -->
    <div class="flex-1 overflow-y-auto p-4 mr-2">
        <div class="mx-auto max-w-3xl space-y-4">
            {#if !rpcConnected}
                <div class="flex h-full flex-col items-center justify-center py-20 text-center">
                    <FolderOpen class="mb-4 h-12 w-12 text-muted-foreground" />
                    <h2 class="mb-2 text-lg font-medium">Booting runtime…</h2>
                    <p class="mb-6 text-sm text-muted-foreground">
                        {#if rpcConnecting}
                            Starting VM…
                        {:else if rpcError}
                            Failed to start runtime: {rpcError}
                        {:else}
                            Waiting for the VM to signal READY.
                        {/if}
                    </p>
                    {#if rpcError}
                        <div class="flex flex-col items-center gap-2">
                            {#if vmLogPath}
                                <code class="rounded-md bg-muted px-3 py-1 text-[11px]">{vmLogPath}</code>
                                <button
                                    class="rounded-md bg-secondary px-4 py-2 text-sm hover:bg-secondary/80 disabled:opacity-60"
                                    onclick={openVmLog}
                                    disabled={openingLog}
                                >
                                    {openingLog ? "Opening log…" : "Open QEMU log"}
                                </button>
                            {/if}
                            <button
                                class="rounded-md bg-primary px-4 py-2 text-sm text-primary-foreground hover:bg-primary/90 disabled:opacity-60"
                                onclick={connectRpc}
                                disabled={rpcConnecting}
                            >
                                Retry
                            </button>
                        </div>
                    {/if}
                </div>
            {:else}
                <div class="flex-1 flex flex-col">
                    {#if rpcAuthHint}
                        <div class="mt-2 rounded-md border border-amber-500/30 bg-amber-500/10 px-2 py-1 text-[11px] text-amber-200">
                            {rpcAuthHint}
                        </div>
                        <div class="mt-2 flex flex-wrap gap-2">
                            <button
                                class="rounded-md bg-secondary px-3 py-1 text-[11px] hover:bg-secondary/80 disabled:opacity-60"
                                onclick={sendLogin}
                                disabled={!rpcConnected}
                            >
                                Send /login
                            </button>
                        </div>
                    {/if}
                    {#if rpcLoginUrl}
                        {#if loginPromptVisible && loginPromptedUrl === rpcLoginUrl}
                            <div class="mt-2 flex flex-wrap items-center gap-2 text-[11px] text-muted-foreground">
                                <span>
                                    {#if loginPromptCountdown !== null}
                                        Auto-opening in {loginPromptCountdown}s.
                                    {:else}
                                        Login URL detected.
                                    {/if}
                                </span>
                                <button
                                    class="rounded-md bg-secondary px-2 py-1 text-[11px] hover:bg-secondary/80 disabled:opacity-60"
                                    onclick={openLoginUrl}
                                    disabled={openingLoginUrl}
                                >
                                    Open now
                                </button>
                                <button
                                    class="rounded-md px-2 py-1 text-[11px] text-muted-foreground hover:bg-accent disabled:opacity-60"
                                    onclick={dismissLoginPrompt}
                                    disabled={openingLoginUrl}
                                >
                                    Dismiss
                                </button>
                            </div>
                        {/if}
                        <code class="mt-2 block rounded-md bg-muted px-2 py-1 text-[11px]">{rpcLoginUrl}</code>
                        <div class="mt-2 flex flex-wrap gap-2">
                            <button
                                class="rounded-md bg-secondary px-3 py-1 text-[11px] hover:bg-secondary/80 disabled:opacity-60"
                                onclick={openLoginUrl}
                                disabled={openingLoginUrl}
                            >
                                {openingLoginUrl ? "Opening login…" : "Open login URL"}
                            </button>
                            <button
                                class="rounded-md bg-secondary px-3 py-1 text-[11px] hover:bg-secondary/80 disabled:opacity-60"
                                onclick={copyLoginUrl}
                                disabled={copyingLoginUrl}
                            >
                                {loginCopied
                                    ? "Copied"
                                    : copyingLoginUrl
                                        ? "Copying…"
                                        : "Copy URL"}
                            </button>
                            <button
                                class="rounded-md px-3 py-1 text-[11px] text-muted-foreground hover:bg-accent disabled:opacity-60"
                                onclick={() => setAutoOpenLogin(!autoOpenLogin)}
                                title="When on, login links auto-open after a short countdown."
                            >
                                Auto-open: {autoOpenLogin ? "On" : "Off"}
                            </button>
                        </div>
                    {/if}
                    <!-- Chat messages -->
                    <div class="mt-4 space-y-4">
                        {#if conversation.messages.length === 0 && !conversation.isAgentRunning}
                            <QuickStartTiles onselect={sendPrompt} />
                        {:else}
                            {#each conversation.messages as message}
                                {@const hasContent = message.blocks.length > 0 || message.isStreaming}
                                {#if message.role === 'user' || hasContent}
                                <div class="flex {message.role === 'user' ? 'justify-end' : 'justify-start'}">
                                    <div class="max-w-[80%] rounded-lg px-3 py-2 {message.role === 'user' ? 'bg-primary text-primary-foreground' : 'bg-muted'}">
                                        {#each message.blocks as block}
                                            {#if block.type === 'text'}
                                                <div class="text-sm whitespace-pre-wrap">{block.text}</div>
                                            {:else if block.type === 'thinking' && !block.isCollapsed}
                                                <div class="text-xs text-muted-foreground italic border-l-2 border-muted-foreground/30 pl-2 my-1">
                                                    {block.text}
                                                </div>
                                            {:else if block.type === 'tool_call'}
                                                <div class="text-xs text-muted-foreground my-1 flex items-center gap-1">
                                                    {#if block.isStreaming}
                                                        <Loader2 class="h-3 w-3 animate-spin" />
                                                    {/if}
                                                    <span class="font-mono">{block.name}</span>
                                                </div>
                                            {:else if block.type === 'tool_result' && block.isError}
                                                <div class="text-xs text-red-400 my-1">
                                                    Error: {block.output}
                                                </div>
                                            {/if}
                                        {/each}
                                        {#if message.isStreaming && message.blocks.length === 0}
                                            <Loader2 class="h-4 w-4 animate-spin text-muted-foreground" />
                                        {/if}
                                    </div>
                                </div>
                                {/if}
                            {/each}
                            {#if conversation.isAgentRunning && !conversation.messages.some(m => m.isStreaming)}
                                <div class="flex justify-start">
                                    <div class="rounded-lg bg-muted px-3 py-2">
                                        <Loader2 class="h-4 w-4 animate-spin text-muted-foreground" />
                                    </div>
                                </div>
                            {/if}
                        {/if}
                        {#if conversation.error}
                            <div class="rounded-lg bg-red-500/10 border border-red-500/30 px-3 py-2 text-sm text-red-400">
                                {conversation.error}
                            </div>
                        {/if}
                    </div>

                    {#if pendingUiRequest}
                        <ExtensionUiDialog
                            request={pendingUiRequest}
                            sending={pendingUiSending}
                            onconfirm={handleUiConfirm}
                            onselect={handleUiSelect}
                            onsubmit={handleUiSubmit}
                            oncancel={handleUiCancel}
                        />
                    {/if}
                </div>
            {/if}
        </div>
    </div>

    <!-- Composer -->
    <div class="border-t border-border p-4">
        <div class="mx-auto max-w-3xl">
            <div class="flex flex-col gap-2 rounded-lg border border-input bg-background p-2">
                <textarea
                    bind:this={textareaEl}
                    bind:value={prompt}
                    oninput={autoGrow}
                    onkeydown={handleInputKeydown}
                    placeholder="What would you like to do?"
                    rows="1"
                    class="w-full resize-none bg-transparent px-2 py-2 text-sm outline-none placeholder:text-muted-foreground"
                    style="overflow-y: hidden;"
                ></textarea>
                <div class="flex items-center justify-between">
                    <div class="flex items-center gap-1">
                        <FolderSelector
                            value={currentWorkingFolder}
                            onchange={handleFolderChange}
                            disabled={!rpcConnected || Boolean(activeTask?.workingFolder)}
                            locked={Boolean(activeTask?.workingFolder)}
                        />
                        <button class="rounded-md p-1.5 hover:bg-accent" aria-label="Attach file">
                            <Paperclip class="h-4 w-4 text-muted-foreground" />
                        </button>
                    </div>
                    <div class="flex items-center gap-2">
                        <select
                            bind:value={selectedModelId}
                            onchange={handleModelChange}
                            class="max-w-32 truncate appearance-none rounded-md bg-transparent px-2 py-1 text-xs text-muted-foreground outline-none hover:bg-accent cursor-pointer"
                        >
                            {#each availableModels as model}
                                <option value={model.id}>{model.label}</option>
                            {/each}
                        </select>
                        <button
                            class="rounded-md bg-primary p-2 text-primary-foreground hover:bg-primary/90 disabled:opacity-50"
                            disabled={!prompt.trim() || !rpcConnected}
                            onclick={() => sendPrompt()}
                            aria-label="Send"
                        >
                            <Send class="h-4 w-4" />
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    </div>

    {#if previewOpen && previewSelection.isOpen}
        <aside class="flex min-h-0 w-1/2 flex-col bg-background">
            <div class="flex items-center justify-between border-b border-border px-3 py-2">
                <div class="min-w-0">
                    <div class="truncate text-sm font-medium text-foreground">
                        {previewSelection.relativePath ?? "Preview"}
                    </div>
                    {#if previewContent}
                        <div class="text-[11px] text-muted-foreground">
                            {previewContent.mimeType} · {formatBytes(previewContent.size)}
                        </div>
                    {/if}
                </div>
                <button
                    class="rounded-md p-1.5 text-muted-foreground hover:bg-accent"
                    onclick={closePreview}
                    aria-label="Close preview"
                >
                    <X class="h-4 w-4" />
                </button>
            </div>

            <div class="min-h-0 flex-1 overflow-auto p-3">
                {#if previewLoading}
                    <div class="text-sm text-muted-foreground">Loading preview…</div>
                {:else if previewError}
                    <div class="rounded-md border border-red-500/30 bg-red-500/10 px-3 py-2 text-sm text-red-400">
                        {previewError}
                    </div>
                {:else if previewContent}
                    {#if previewContent.encoding === "utf8"}
                        <pre class="whitespace-pre-wrap rounded-md border border-border bg-muted p-3 text-xs text-foreground">{previewContent.content}</pre>
                    {:else if previewContent.mimeType.startsWith("image/")}
                        <img
                            src={`data:${previewContent.mimeType};base64,${previewContent.content}`}
                            alt={previewContent.path}
                            class="max-h-[80vh] w-full rounded-md border border-border object-contain bg-muted"
                        />
                    {:else}
                        <div class="rounded-md border border-border bg-muted px-3 py-2 text-sm text-muted-foreground">
                            Binary preview is not supported yet for this file type.
                        </div>
                    {/if}

                    {#if previewContent.truncated}
                        <div class="mt-2 text-[11px] text-amber-300">
                            Preview content truncated for responsiveness.
                        </div>
                    {/if}
                {:else}
                    <div class="text-sm text-muted-foreground">No preview selected.</div>
                {/if}
            </div>
        </aside>
    {/if}

    {#if import.meta.env.DEV && devToasts.length > 0}
        <div class="pointer-events-none fixed bottom-4 right-4 z-50 flex max-w-sm flex-col gap-2">
            {#each devToasts as toast (toast.id)}
                <div class="rounded-md border border-red-500/40 bg-red-500/15 px-3 py-2 text-xs text-red-100 shadow">
                    {toast.message}
                </div>
            {/each}
        </div>
    {/if}
</main>

```

src/lib/components/layout/RightPanel.svelte
```
<script lang="ts">
import { invoke } from "@tauri-apps/api/core";
import { onDestroy, onMount } from "svelte";
import { Activity, FolderOpen, Link, ChevronDown, RefreshCw, FileText, Image, ExternalLink } from "@lucide/svelte";
import { taskStore } from "$lib/stores/taskStore";
import { previewStore } from "$lib/stores/previewStore";
import { artifactRefreshStore } from "$lib/stores/artifactRefreshStore";
import type { TaskMetadata } from "$lib/types/task";

type CardId = "progress" | "workingFolder" | "scratchpad" | "context";

interface ArtifactFileEntry {
    source: "outputs" | "uploads";
    path: string;
    size: number;
    modifiedAt: number;
    readOnly: boolean;
}

interface ArtifactListResponse {
    files: ArtifactFileEntry[];
    truncated: boolean;
}

interface WorkingFileEntry {
    path: string;
    size: number;
    modifiedAt: number;
}

interface PreviewListResponse {
    root: string;
    files: WorkingFileEntry[];
    truncated: boolean;
}

let expanded = $state<Record<CardId, boolean>>({
    progress: true,
    workingFolder: true,
    scratchpad: true,
    context: false,
});

let activeTask: TaskMetadata | null = $state(null);
let unsubscribeActive: (() => void) | null = null;
let unsubscribeArtifactRefresh: (() => void) | null = null;

let files = $state<ArtifactFileEntry[]>([]);
let filesTruncated = $state(false);
let filesLoading = $state(false);
let scratchpadError = $state<string | null>(null);

let workingFiles = $state<WorkingFileEntry[]>([]);
let workingFilesTruncated = $state(false);
let workingFilesLoading = $state(false);
let workingFilesError = $state<string | null>(null);

let workingFolderError = $state<string | null>(null);
let openingWorkingFolder = $state(false);

let lastFilesKey = "";
let filesRequestId = 0;
let workingFilesRequestId = 0;
let scratchpadRefreshTimer: ReturnType<typeof setTimeout> | null = null;
let workingFolderRefreshTimer: ReturnType<typeof setTimeout> | null = null;

const cards: { id: CardId; label: string; icon: typeof Activity }[] = [
    { id: "progress", label: "Progress", icon: Activity },
    { id: "workingFolder", label: "Working folder", icon: FolderOpen },
    { id: "scratchpad", label: "Scratchpad", icon: FolderOpen },
    { id: "context", label: "Context", icon: Link },
];

function toggle(id: CardId) {
    expanded[id] = !expanded[id];
}

function formatBytes(bytes: number): string {
    if (bytes < 1024) {
        return `${bytes} B`;
    }
    if (bytes < 1024 * 1024) {
        return `${(bytes / 1024).toFixed(1)} KB`;
    }
    return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
}

function folderBasename(path: string): string {
    const trimmed = path.replace(/\/+$/, "");
    const parts = trimmed.split("/");
    return parts[parts.length - 1] || path;
}

function cardTitle(card: CardId): string {
    if (card !== "workingFolder") {
        return cards.find((entry) => entry.id === card)?.label ?? "";
    }

    if (activeTask?.workingFolder) {
        return folderBasename(activeTask.workingFolder);
    }

    return "Working folder";
}

function clearFilesState() {
    files = [];
    filesTruncated = false;
    scratchpadError = null;
    filesLoading = false;
}

function clearWorkingFilesState() {
    workingFiles = [];
    workingFilesTruncated = false;
    workingFilesError = null;
    workingFilesLoading = false;
}

async function loadFiles(): Promise<void> {
    if (!activeTask?.id) {
        clearFilesState();
        return;
    }

    const requestId = ++filesRequestId;
    filesLoading = true;
    scratchpadError = null;

    try {
        const result = await invoke<ArtifactListResponse>("task_artifact_list", {
            taskId: activeTask.id,
        });

        if (requestId !== filesRequestId) {
            return;
        }

        files = result.files;
        filesTruncated = result.truncated;
    } catch (error) {
        if (requestId !== filesRequestId) {
            return;
        }

        scratchpadError = error instanceof Error ? error.message : String(error);
        files = [];
        filesTruncated = false;
    } finally {
        if (requestId === filesRequestId) {
            filesLoading = false;
        }
    }
}

async function loadWorkingFiles(): Promise<void> {
    if (!activeTask?.id || !activeTask.workingFolder) {
        clearWorkingFilesState();
        return;
    }

    const requestId = ++workingFilesRequestId;
    workingFilesLoading = true;
    workingFilesError = null;

    try {
        const result = await invoke<PreviewListResponse>("task_preview_list", {
            taskId: activeTask.id,
        });

        if (requestId !== workingFilesRequestId) {
            return;
        }

        workingFiles = result.files;
        workingFilesTruncated = result.truncated;
    } catch (error) {
        if (requestId !== workingFilesRequestId) {
            return;
        }

        workingFilesError = error instanceof Error ? error.message : String(error);
        workingFiles = [];
        workingFilesTruncated = false;
    } finally {
        if (requestId === workingFilesRequestId) {
            workingFilesLoading = false;
        }
    }
}

function openPreview(file: ArtifactFileEntry) {
    if (!activeTask?.id) {
        return;
    }

    previewStore.open(activeTask.id, file.path, {
        source: "artifact",
        artifactSource: file.source,
    });
}

function openWorkingPreview(file: WorkingFileEntry) {
    if (!activeTask?.id) {
        return;
    }

    previewStore.open(activeTask.id, file.path, { source: "preview" });
}

async function openWorkingFolderInFinder() {
    const folder = activeTask?.workingFolder;
    if (!folder || openingWorkingFolder) {
        return;
    }

    openingWorkingFolder = true;
    workingFolderError = null;

    try {
        await invoke("open_path_in_finder", { path: folder });
    } catch (error) {
        workingFolderError = error instanceof Error ? error.message : String(error);
    } finally {
        openingWorkingFolder = false;
    }
}

function scheduleLoadFiles(delayMs = 200) {
    if (scratchpadRefreshTimer) {
        clearTimeout(scratchpadRefreshTimer);
    }

    scratchpadRefreshTimer = setTimeout(() => {
        scratchpadRefreshTimer = null;
        void loadFiles();
    }, delayMs);
}

function scheduleLoadWorkingFiles(delayMs = 200) {
    if (workingFolderRefreshTimer) {
        clearTimeout(workingFolderRefreshTimer);
    }

    workingFolderRefreshTimer = setTimeout(() => {
        workingFolderRefreshTimer = null;
        void loadWorkingFiles();
    }, delayMs);
}

onMount(() => {
    unsubscribeActive = taskStore.activeTask.subscribe((value) => {
        activeTask = value;
        workingFolderError = null;

        const nextKey = `${value?.id ?? ""}`;
        if (nextKey === lastFilesKey) {
            return;
        }

        lastFilesKey = nextKey;
        void loadFiles();
        void loadWorkingFiles();
    });

    unsubscribeArtifactRefresh = artifactRefreshStore.subscribe((event) => {
        if (!activeTask?.id) {
            return;
        }

        if (!event.taskId || event.taskId !== activeTask.id) {
            return;
        }

        scheduleLoadFiles(150);
        scheduleLoadWorkingFiles(150);
    });
});

onDestroy(() => {
    unsubscribeActive?.();
    unsubscribeArtifactRefresh?.();

    if (scratchpadRefreshTimer) {
        clearTimeout(scratchpadRefreshTimer);
        scratchpadRefreshTimer = null;
    }

    if (workingFolderRefreshTimer) {
        clearTimeout(workingFolderRefreshTimer);
        workingFolderRefreshTimer = null;
    }
});
</script>

<aside class="flex h-full w-72 flex-col overflow-y-auto border-l border-border bg-background p-3">
    <div class="space-y-2">
        {#each cards as card}
            <div class="rounded-lg border border-border bg-card">
                <div class="flex w-full items-center gap-1 p-3 text-sm font-medium">
                    <button
                        class="flex min-w-0 flex-1 items-center gap-2 text-left"
                        onclick={() => toggle(card.id)}
                    >
                        <card.icon class="h-4 w-4 text-muted-foreground" />
                        <span class="truncate">{cardTitle(card.id)}</span>
                    </button>

                    {#if card.id === "workingFolder" && activeTask?.workingFolder}
                        <button
                            class="inline-flex h-7 w-7 items-center justify-center rounded-md border border-border text-muted-foreground hover:bg-accent disabled:opacity-60"
                            onclick={openWorkingFolderInFinder}
                            disabled={openingWorkingFolder}
                            title="Open in Finder"
                            aria-label="Open in Finder"
                        >
                            <ExternalLink class="h-3.5 w-3.5" />
                        </button>
                    {/if}

                    <button
                        class="inline-flex h-7 w-7 items-center justify-center rounded-md text-muted-foreground hover:bg-accent"
                        onclick={() => toggle(card.id)}
                        aria-label={expanded[card.id] ? "Collapse card" : "Expand card"}
                    >
                        <ChevronDown class="h-4 w-4 transition-transform {expanded[card.id] ? 'rotate-180' : ''}" />
                    </button>
                </div>

                {#if expanded[card.id]}
                    <div class="border-t border-border px-3 py-3 text-sm text-muted-foreground">
                        {#if card.id === "progress"}
                            {#if activeTask}
                                <p class="font-medium text-foreground">{activeTask.title || "Untitled task"}</p>
                                <p class="text-xs text-muted-foreground">Status: {activeTask.status}</p>
                            {:else}
                                <p>No active task</p>
                            {/if}
                        {:else if card.id === "workingFolder"}
                            {#if !activeTask}
                                <p>No active task</p>
                            {:else}
                                <div class="space-y-2">
                                    {#if activeTask.workingFolder}
                                        <div class="rounded-md bg-muted px-2 py-1 text-xs text-foreground break-all">
                                            {activeTask.workingFolder}
                                        </div>

                                        {#if workingFolderError}
                                            <div class="rounded-md border border-red-500/30 bg-red-500/10 px-2 py-1 text-xs text-red-400">
                                                {workingFolderError}
                                            </div>
                                        {/if}

                                        {#if workingFilesError}
                                            <div class="rounded-md border border-red-500/30 bg-red-500/10 px-2 py-1 text-xs text-red-400">
                                                {workingFilesError}
                                            </div>
                                        {/if}

                                        {#if workingFilesTruncated}
                                            <div class="rounded-md border border-amber-500/30 bg-amber-500/10 px-2 py-1 text-xs text-amber-300">
                                                Working-folder file list truncated for responsiveness.
                                            </div>
                                        {/if}

                                        <div class="space-y-1">
                                            <div class="flex items-center justify-between text-[11px] uppercase tracking-wide text-muted-foreground">
                                                <span>Files {workingFiles.length > 0 ? `(${workingFiles.length})` : ""}</span>
                                                {#if workingFilesLoading}
                                                    <span class="inline-flex items-center gap-1 normal-case tracking-normal text-[10px] text-muted-foreground">
                                                        <RefreshCw class="h-3 w-3 animate-spin" />
                                                        Updating…
                                                    </span>
                                                {/if}
                                            </div>

                                            <div class="max-h-48 overflow-y-auto rounded-md border border-border">
                                                {#if workingFilesLoading && workingFiles.length === 0}
                                                    <div class="px-2 py-2 text-xs text-muted-foreground">Loading files…</div>
                                                {:else if workingFiles.length === 0}
                                                    <div class="px-2 py-2 text-xs text-muted-foreground">No files in working folder yet.</div>
                                                {:else}
                                                    {#each workingFiles as file}
                                                        <button
                                                            class="flex w-full items-center gap-2 border-b border-border px-2 py-1.5 text-left text-xs hover:bg-accent last:border-b-0"
                                                            onclick={() => openWorkingPreview(file)}
                                                        >
                                                            {#if file.path.endsWith('.png') || file.path.endsWith('.jpg') || file.path.endsWith('.jpeg') || file.path.endsWith('.gif') || file.path.endsWith('.webp') || file.path.endsWith('.svg')}
                                                                <Image class="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                                                            {:else}
                                                                <FileText class="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                                                            {/if}
                                                            <span class="min-w-0 flex-1 truncate">{file.path}</span>
                                                            <span class="shrink-0 text-[10px] text-muted-foreground">{formatBytes(file.size)}</span>
                                                        </button>
                                                    {/each}
                                                {/if}
                                            </div>
                                        </div>
                                    {:else}
                                        <div class="rounded-md border border-dashed border-border px-2 py-2 text-xs text-muted-foreground">
                                            No working folder set for this task.
                                        </div>
                                    {/if}
                                </div>
                            {/if}
                        {:else if card.id === "scratchpad"}
                            {#if !activeTask}
                                <p>No active task</p>
                            {:else}
                                <div class="space-y-3">
                                    <div class="flex items-center justify-between text-[11px] uppercase tracking-wide text-muted-foreground">
                                        <span>Files {files.length > 0 ? `(${files.length})` : ""}</span>
                                        {#if filesLoading}
                                            <span class="inline-flex items-center gap-1 normal-case tracking-normal text-[10px] text-muted-foreground">
                                                <RefreshCw class="h-3 w-3 animate-spin" />
                                                Updating…
                                            </span>
                                        {/if}
                                    </div>

                                    {#if scratchpadError}
                                        <div class="rounded-md border border-red-500/30 bg-red-500/10 px-2 py-1 text-xs text-red-400">
                                            {scratchpadError}
                                        </div>
                                    {/if}

                                    {#if filesTruncated}
                                        <div class="rounded-md border border-amber-500/30 bg-amber-500/10 px-2 py-1 text-xs text-amber-300">
                                            File list truncated for responsiveness.
                                        </div>
                                    {/if}

                                    <div class="max-h-56 overflow-y-auto rounded-md border border-border">
                                        {#if filesLoading && files.length === 0}
                                            <div class="px-2 py-2 text-xs text-muted-foreground">Loading files…</div>
                                        {:else if files.length === 0}
                                            <div class="px-2 py-2 text-xs text-muted-foreground">No scratchpad files yet.</div>
                                        {:else}
                                            {#each files as file}
                                                <button
                                                    class="flex w-full items-center gap-2 border-b border-border px-2 py-1.5 text-left text-xs hover:bg-accent last:border-b-0"
                                                    onclick={() => openPreview(file)}
                                                >
                                                    {#if file.path.endsWith('.png') || file.path.endsWith('.jpg') || file.path.endsWith('.jpeg') || file.path.endsWith('.gif') || file.path.endsWith('.webp') || file.path.endsWith('.svg')}
                                                        <Image class="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                                                    {:else}
                                                        <FileText class="h-3.5 w-3.5 shrink-0 text-muted-foreground" />
                                                    {/if}
                                                    <span class="min-w-0 flex-1 truncate">{file.path}</span>
                                                    <span class="shrink-0 text-[10px] text-muted-foreground">{formatBytes(file.size)}</span>
                                                </button>
                                            {/each}
                                        {/if}
                                    </div>
                                </div>
                            {/if}
                        {:else if card.id === "context"}
                            <div class="space-y-2 text-xs">
                                <div class="rounded-md border border-border bg-muted/50 px-2 py-2">
                                    <p class="font-medium text-foreground">Scoped local mode (MVP)</p>
                                    <ul class="mt-1 list-disc space-y-1 pl-4 text-muted-foreground">
                                        <li>Access is scoped to the active task folder under your workspace root.</li>
                                        <li>Traversal and symlink escape attempts are blocked by policy.</li>
                                        <li>This is not yet a hardened sandbox for hostile code.</li>
                                    </ul>
                                </div>
                                <p>No connectors enabled.</p>
                            </div>
                        {/if}
                    </div>
                {/if}
            </div>
        {/each}
    </div>
</aside>

```

src/lib/components/layout/SettingsModal.svelte
```
<script lang="ts">
import { onDestroy } from "svelte";
import { invoke } from "@tauri-apps/api/core";
import { openPath } from "@tauri-apps/plugin-opener";
import { X } from "@lucide/svelte";

const { open = false, onClose = null } = $props<{
    open?: boolean;
    onClose?: (() => void) | null;
}>();

interface AuthStoreEntry {
    provider: string;
    entryType: string;
}

interface AuthStoreSummary {
    path: string;
    entries: AuthStoreEntry[];
}

const DEFAULT_PROFILE = "default";
const RUNTIME_BUILD_AUTH_COMMAND = "PIWORK_COPY_AUTH=1 mise run runtime-build-auth";

let entries = $state<AuthStoreEntry[]>([]);
let storePath = $state<string | null>(null);
let loading = $state(false);
let importingAuth = $state(false);
let openingStorePath = $state(false);
let error = $state<string | null>(null);
let notice = $state<string | null>(null);
let noticeTimer: ReturnType<typeof setTimeout> | null = null;
let wasOpen = $state(false);

function clearNotice() {
    notice = null;
    if (noticeTimer) {
        clearTimeout(noticeTimer);
        noticeTimer = null;
    }
}

function setNotice(message: string) {
    notice = message;
    if (noticeTimer) {
        clearTimeout(noticeTimer);
    }
    noticeTimer = setTimeout(() => {
        notice = null;
    }, 3000);
}

function formatEntryType(entryType: string) {
    return entryType === "api_key" ? "API key" : entryType;
}

async function loadAuthStatus() {
    loading = true;
    error = null;

    try {
        const summary = await invoke<AuthStoreSummary>("auth_store_list", {
            profile: DEFAULT_PROFILE,
        });
        entries = summary.entries;
        storePath = summary.path;
    } catch (err) {
        error = err instanceof Error ? err.message : String(err);
    } finally {
        loading = false;
    }
}

async function importPiAuth() {
    if (importingAuth) return;

    importingAuth = true;
    error = null;

    try {
        const summary = await invoke<AuthStoreSummary>("auth_store_import_pi", {
            profile: DEFAULT_PROFILE,
        });
        entries = summary.entries;
        storePath = summary.path;
        setNotice("Imported ~/.pi/agent/auth.json");
    } catch (err) {
        error = err instanceof Error ? err.message : String(err);
    } finally {
        importingAuth = false;
    }
}

async function openAuthStorePath() {
    if (!storePath || openingStorePath) return;

    openingStorePath = true;
    try {
        await openPath(storePath);
    } finally {
        openingStorePath = false;
    }
}

function initializeOpen() {
    clearNotice();
    error = null;
    void loadAuthStatus();
}

function resetOnClose() {
    clearNotice();
    error = null;
    loading = false;
    importingAuth = false;
    openingStorePath = false;
}

$effect(() => {
    if (open && !wasOpen) {
        wasOpen = true;
        initializeOpen();
        return;
    }

    if (!open && wasOpen) {
        wasOpen = false;
        resetOnClose();
    }
});

onDestroy(() => {
    if (noticeTimer) {
        clearTimeout(noticeTimer);
    }
});
</script>

{#if open}
    <div class="fixed inset-0 z-50 flex items-center justify-center p-4">
        <button
            class="absolute inset-0 bg-black/40"
            type="button"
            aria-label="Close settings"
            onclick={() => onClose?.()}
        ></button>

        <div class="relative max-h-[90vh] w-full max-w-xl overflow-y-auto rounded-lg border border-border bg-card p-6 shadow-lg">
            <div class="flex items-center justify-between">
                <div>
                    <h2 class="text-lg font-semibold">Settings</h2>
                    <p class="text-sm text-muted-foreground">Authentication (MVP)</p>
                </div>
                <button class="rounded-md p-2 hover:bg-accent" aria-label="Close" onclick={() => onClose?.()}>
                    <X class="h-4 w-4" />
                </button>
            </div>

            <div class="mt-3 rounded-md border border-border bg-muted/40 px-3 py-2 text-xs text-muted-foreground">
                For MVP, auth comes from either imported host credentials (<span class="font-mono">~/.pi/agent/auth.json</span>)
                or baked runtime auth (<span class="font-mono">{RUNTIME_BUILD_AUTH_COMMAND}</span>).
            </div>

            <div class="mt-6 rounded-lg border border-border bg-muted/30 p-4">
                <div class="flex flex-wrap items-center justify-between gap-2">
                    <div class="text-sm font-medium">Current auth status</div>
                    <span
                        class="rounded-full px-2 py-1 text-[11px] font-medium {loading
                            ? 'bg-secondary text-muted-foreground'
                            : entries.length > 0
                                ? 'bg-emerald-500/15 text-emerald-300'
                                : 'bg-amber-500/15 text-amber-300'}"
                    >
                        {#if loading}
                            Checking…
                        {:else if entries.length > 0}
                            Configured
                        {:else}
                            Not configured
                        {/if}
                    </span>
                </div>

                <div class="mt-3 text-xs text-muted-foreground">
                    {#if loading}
                        Checking stored providers…
                    {:else if entries.length === 0}
                        No providers found in the default auth store yet.
                    {:else}
                        Found {entries.length} provider{entries.length === 1 ? "" : "s"} in default auth store.
                    {/if}
                </div>

                {#if entries.length > 0}
                    <div class="mt-3 space-y-2">
                        {#each entries as entry}
                            <div class="flex items-center justify-between rounded-md border border-border bg-background px-3 py-2">
                                <div class="text-sm font-medium text-foreground">{entry.provider}</div>
                                <div class="text-xs text-muted-foreground">{formatEntryType(entry.entryType)}</div>
                            </div>
                        {/each}
                    </div>
                {/if}

                {#if storePath}
                    <div class="mt-3 text-[11px] text-muted-foreground">
                        <span class="uppercase tracking-wide">Storage</span>
                        <code class="mt-1 block rounded-md bg-muted px-2 py-1">{storePath}</code>
                    </div>
                {/if}

                <div class="mt-4 flex flex-wrap items-center gap-2">
                    <button
                        class="rounded-md bg-primary px-3 py-2 text-xs font-medium text-primary-foreground hover:bg-primary/90 disabled:opacity-60"
                        onclick={importPiAuth}
                        disabled={importingAuth}
                    >
                        {importingAuth ? "Importing…" : "Import from pi"}
                    </button>

                    <button
                        class="rounded-md bg-secondary px-3 py-2 text-xs hover:bg-secondary/80 disabled:opacity-60"
                        onclick={loadAuthStatus}
                        disabled={loading}
                    >
                        {loading ? "Refreshing…" : "Refresh"}
                    </button>

                    <button
                        class="rounded-md bg-secondary px-3 py-2 text-xs hover:bg-secondary/80 disabled:opacity-60"
                        onclick={openAuthStorePath}
                        disabled={!storePath || openingStorePath}
                    >
                        {openingStorePath ? "Opening…" : "Open auth file"}
                    </button>
                </div>

                {#if notice}
                    <div class="mt-3 text-xs text-emerald-400">{notice}</div>
                {/if}

                {#if error}
                    <div class="mt-3 rounded-md border border-destructive/40 bg-destructive/10 px-2 py-1 text-xs text-destructive">
                        {error}
                    </div>
                {/if}
            </div>

            <div class="mt-3 text-xs text-muted-foreground">
                After auth changes, restart runtime if the current task session is already running.
            </div>
        </div>
    </div>
{/if}

```

src/lib/components/layout/TopBar.svelte
```
<script lang="ts">
import { onDestroy, onMount } from "svelte";
import { dev } from "$app/environment";
import { Settings, PanelLeft, PanelRight } from "@lucide/svelte";
import { taskStore } from "$lib/stores/taskStore";
import { runtimeDebugStore, type RuntimeDebugState } from "$lib/stores/runtimeDebugStore";
import type { TaskMetadata } from "$lib/types/task";

let {
    showLeftRail = $bindable(true),
    showRightPanel = $bindable(false),
    onOpenSettings = null,
}: {
    showLeftRail?: boolean;
    showRightPanel?: boolean;
    onOpenSettings?: (() => void) | null;
} = $props();

let activeTask: TaskMetadata | null = $state(null);
let runtimeDebug: RuntimeDebugState = $state({
    activeTaskId: null,
    sessionId: null,
    sessionName: null,
    currentCwd: null,
    workingFolderRelative: null,
    updatedAt: 0,
});

let unsubscribeActive: (() => void) | null = null;
let unsubscribeRuntimeDebug: (() => void) | null = null;

function shortId(value: string | null): string | null {
    return value ? value.slice(0, 8) : null;
}

function shouldShowSessionChip(): boolean {
    if (!activeTask) {
        return false;
    }

    if (runtimeDebug.sessionId && runtimeDebug.sessionId !== activeTask.id) {
        return true;
    }

    if (runtimeDebug.sessionName && runtimeDebug.sessionName !== activeTask.id) {
        return true;
    }

    return false;
}

function sessionChipValue(): string | null {
    if (runtimeDebug.sessionId) {
        return shortId(runtimeDebug.sessionId);
    }

    return runtimeDebug.sessionName;
}

onMount(() => {
    unsubscribeActive = taskStore.activeTask.subscribe((value) => {
        activeTask = value;
    });

    unsubscribeRuntimeDebug = runtimeDebugStore.subscribe((value) => {
        runtimeDebug = value;
    });
});

onDestroy(() => {
    unsubscribeActive?.();
    unsubscribeRuntimeDebug?.();
});
</script>

<header class="flex h-12 items-center justify-between border-b border-border bg-background px-4">
    <div class="flex items-center gap-2">
        <button
            class="rounded-md p-2 hover:bg-accent {showLeftRail ? 'bg-accent' : ''}"
            aria-label="Toggle tasks"
            onclick={() => (showLeftRail = !showLeftRail)}
        >
            <PanelLeft class="h-4 w-4" />
        </button>
        <span class="text-lg font-semibold">Piwork</span>
        <span class="text-sm text-muted-foreground">
            {activeTask ? activeTask.title || "Untitled task" : "No active task"}
        </span>

        {#if dev && activeTask}
            <div class="hidden items-center gap-1.5 md:flex">
                <span class="rounded bg-muted px-1.5 py-0.5 text-[10px] text-muted-foreground" title={activeTask.id}>
                    task {shortId(activeTask.id)}
                </span>

                {#if runtimeDebug.activeTaskId && runtimeDebug.activeTaskId !== activeTask.id}
                    <span
                        class="rounded border border-red-500/40 bg-red-500/15 px-1.5 py-0.5 text-[10px] text-red-300"
                        title={`runtime active task: ${runtimeDebug.activeTaskId}`}
                    >
                        runtime mismatch
                    </span>
                {/if}

                {#if shouldShowSessionChip()}
                    <span
                        class="rounded bg-muted px-1.5 py-0.5 text-[10px] text-muted-foreground"
                        title={runtimeDebug.sessionName ?? runtimeDebug.sessionId ?? ""}
                    >
                        session {sessionChipValue()}
                    </span>
                {/if}

                {#if runtimeDebug.currentCwd}
                    <span
                        class="max-w-44 truncate rounded bg-muted px-1.5 py-0.5 text-[10px] text-muted-foreground"
                        title={runtimeDebug.currentCwd}
                    >
                        cwd {runtimeDebug.currentCwd}
                    </span>
                {/if}
            </div>
        {/if}
    </div>

    <div class="flex items-center gap-2">
        <span class="rounded-full bg-green-500/20 px-2 py-0.5 text-xs text-green-600">Network</span>
        <button
            class="rounded-md p-2 hover:bg-accent {showRightPanel ? 'bg-accent' : ''}"
            aria-label="Toggle panel"
            onclick={() => (showRightPanel = !showRightPanel)}
        >
            <PanelRight class="h-4 w-4" />
        </button>
        <button class="rounded-md p-2 hover:bg-accent" aria-label="Settings" onclick={() => onOpenSettings?.()}>
            <Settings class="h-4 w-4" />
        </button>
    </div>
</header>

```

src/lib/components/layout/index.ts
```
export { default as AppShell } from "./AppShell.svelte";
export { default as TopBar } from "./TopBar.svelte";
export { default as SettingsModal } from "./SettingsModal.svelte";
export { default as LeftRail } from "./LeftRail.svelte";
// MainView is lazy-loaded by AppShell, don't export from barrel
export { default as RightPanel } from "./RightPanel.svelte";

```

src/lib/rpc/index.ts
```
export type { RpcClient, RpcEvent, RpcListener, RpcPayload } from "./types";
export type * from "./types";
export { MockRpcClient, parseJsonl } from "./mockRpcClient";
export { TauriRpcClient } from "./tauriRpcClient";
export { MessageAccumulator } from "./messageAccumulator";
export type * from "./messageAccumulator";

```

src/lib/rpc/messageAccumulator.ts
```
/**
 * Accumulates RPC streaming events into renderable conversation state
 */

import type {
    RpcPayload,
    MessageUpdateEvent,
    ToolExecutionStartEvent,
    ToolExecutionUpdateEvent,
    ToolExecutionEndEvent,
} from "./types";

export interface TextBlock {
    type: "text";
    text: string;
    isStreaming: boolean;
}

export interface ThinkingBlock {
    type: "thinking";
    text: string;
    isStreaming: boolean;
    isCollapsed: boolean;
}

export interface ToolCallBlock {
    type: "tool_call";
    id: string;
    name: string;
    input: string;
    isStreaming: boolean;
    isCollapsed: boolean;
}

export interface ToolResultBlock {
    type: "tool_result";
    toolCallId: string;
    output: string;
    isError: boolean;
    isStreaming: boolean;
    isCollapsed: boolean;
}

export type ContentBlock = TextBlock | ThinkingBlock | ToolCallBlock | ToolResultBlock;

export interface ConversationMessage {
    role: "user" | "assistant";
    blocks: ContentBlock[];
    isStreaming: boolean;
}

export interface ConversationState {
    messages: ConversationMessage[];
    isAgentRunning: boolean;
    error: string | null;
}

export class MessageAccumulator {
    private state: ConversationState = {
        messages: [],
        isAgentRunning: false,
        error: null,
    };

    private currentText = "";
    private currentThinking = "";
    private currentToolInput = "";
    private currentToolId = "";
    private currentToolName = "";
    private activeToolOutputs = new Map<string, string>();

    getState(): ConversationState {
        return { ...this.state, messages: [...this.state.messages] };
    }

    addUserMessage(text: string): void {
        this.state.messages.push({
            role: "user",
            blocks: [{ type: "text", text, isStreaming: false }],
            isStreaming: false,
        });
    }

    processEvent(payload: RpcPayload): void {
        // Debug: log what we receive
        if (import.meta.env.DEV) {
            console.log("[Accumulator]", payload.type, payload);
        }

        switch (payload.type) {
            case "agent_start":
                this.state.isAgentRunning = true;
                this.state.error = null;
                break;

            case "agent_end":
                this.state.isAgentRunning = false;
                this.finalizeCurrentMessage();
                break;

            case "turn_start":
                // Start a new assistant message
                this.ensureAssistantMessage();
                break;

            case "turn_end":
                this.finalizeCurrentMessage();
                break;

            case "message_update":
                this.handleMessageUpdate(payload as MessageUpdateEvent);
                break;

            case "tool_execution_start":
                this.handleToolExecutionStart(payload as ToolExecutionStartEvent);
                break;

            case "tool_execution_update":
                this.handleToolExecutionUpdate(payload as ToolExecutionUpdateEvent);
                break;

            case "tool_execution_end":
                this.handleToolExecutionEnd(payload as ToolExecutionEndEvent);
                break;

            case "message_end":
                // Extract content from the completed message
                this.handleMessageEnd(payload as { message?: Record<string, unknown> });
                break;

            case "response":
                // Handle command responses (errors, etc.)
                if (payload.success === false && payload.error) {
                    this.state.error = payload.error as string;
                }
                break;
        }
    }

    private handleMessageEnd(payload: { message?: Record<string, unknown> }): void {
        const message = payload.message;
        if (!message) return;

        // Ignore user message echoes - we already added the user message locally
        if (message.role === "user") return;

        const errorMessage = typeof message.errorMessage === "string" ? message.errorMessage : null;

        // Check if we already have text blocks from streaming
        const lastMsg = this.state.messages[this.state.messages.length - 1];
        const hasTextBlocks =
            lastMsg?.role === "assistant" && lastMsg.blocks.some((b: ContentBlock) => b.type === "text");

        if (!hasTextBlocks) {
            const content = this.extractMessageContent(message);
            if (content) {
                const msg = this.ensureAssistantMessage();
                this.updateOrAddBlock(msg, "text", {
                    type: "text",
                    text: content,
                    isStreaming: false,
                });
            } else if (errorMessage) {
                // Show error if no content but there's an error
                this.state.error = errorMessage;
            }
        } else if (errorMessage) {
            this.state.error = errorMessage;
        }

        this.finalizeCurrentMessage();
    }

    private extractMessageContent(message: Record<string, unknown>): string | null {
        // String content
        if (typeof message.content === "string") {
            return message.content;
        }

        // Array of content blocks
        if (Array.isArray(message.content)) {
            const parts = message.content
                .filter((part): part is Record<string, unknown> => typeof part === "object" && part !== null)
                .filter((part) => part.type === "text" && typeof part.text === "string")
                .map((part) => part.text as string);

            if (parts.length > 0) {
                return parts.join("");
            }
        }

        return null;
    }

    private ensureAssistantMessage(): ConversationMessage {
        const last = this.state.messages[this.state.messages.length - 1];
        if (last?.role === "assistant" && last.isStreaming) {
            return last;
        }

        const msg: ConversationMessage = {
            role: "assistant",
            blocks: [],
            isStreaming: true,
        };
        this.state.messages.push(msg);
        return msg;
    }

    private handleMessageUpdate(event: MessageUpdateEvent): void {
        const { assistantMessageEvent } = event;
        if (!assistantMessageEvent) return;

        const msg = this.ensureAssistantMessage();

        switch (assistantMessageEvent.type) {
            case "text_start":
                this.currentText = "";
                break;

            case "text_delta":
                this.currentText += assistantMessageEvent.delta;
                this.updateOrAddBlock(msg, "text", {
                    type: "text",
                    text: this.currentText,
                    isStreaming: true,
                });
                break;

            case "text_end":
                this.updateOrAddBlock(msg, "text", {
                    type: "text",
                    text: assistantMessageEvent.content || this.currentText,
                    isStreaming: false,
                });
                this.currentText = "";
                break;

            case "thinking_start":
                this.currentThinking = "";
                break;

            case "thinking_delta":
                this.currentThinking += assistantMessageEvent.delta;
                this.updateOrAddBlock(msg, "thinking", {
                    type: "thinking",
                    text: this.currentThinking,
                    isStreaming: true,
                    isCollapsed: false,
                });
                break;

            case "thinking_end":
                this.updateOrAddBlock(msg, "thinking", {
                    type: "thinking",
                    text: assistantMessageEvent.content || this.currentThinking,
                    isStreaming: false,
                    isCollapsed: true, // Collapse when done
                });
                this.currentThinking = "";
                break;

            case "toolcall_start":
                this.currentToolId = assistantMessageEvent.toolCallId;
                this.currentToolName = assistantMessageEvent.toolName;
                this.currentToolInput = "";
                break;

            case "toolcall_delta":
                this.currentToolInput += assistantMessageEvent.delta;
                this.updateOrAddToolCall(msg, this.currentToolId, {
                    type: "tool_call",
                    id: this.currentToolId,
                    name: this.currentToolName,
                    input: this.currentToolInput,
                    isStreaming: true,
                    isCollapsed: false,
                });
                break;

            case "toolcall_end":
                const toolCall = assistantMessageEvent.toolCall;
                this.updateOrAddToolCall(msg, toolCall.id, {
                    type: "tool_call",
                    id: toolCall.id,
                    name: toolCall.name,
                    input: JSON.stringify(toolCall.input, null, 2),
                    isStreaming: false,
                    isCollapsed: true,
                });
                this.currentToolId = "";
                this.currentToolName = "";
                this.currentToolInput = "";
                break;

            case "done":
                msg.isStreaming = false;
                break;

            case "error":
                msg.isStreaming = false;
                this.state.error = assistantMessageEvent.error || "Unknown error";
                break;
        }
    }

    private handleToolExecutionStart(event: ToolExecutionStartEvent): void {
        this.activeToolOutputs.set(event.toolCallId, "");
    }

    private handleToolExecutionUpdate(event: ToolExecutionUpdateEvent): void {
        const current = this.activeToolOutputs.get(event.toolCallId) || "";
        this.activeToolOutputs.set(event.toolCallId, current + event.output);

        // Update the tool result block if it exists
        const msg = this.state.messages[this.state.messages.length - 1];
        if (msg?.role === "assistant") {
            this.updateOrAddToolResult(msg, event.toolCallId, {
                type: "tool_result",
                toolCallId: event.toolCallId,
                output: this.activeToolOutputs.get(event.toolCallId) || "",
                isError: false,
                isStreaming: true,
                isCollapsed: false,
            });
        }
    }

    private handleToolExecutionEnd(event: ToolExecutionEndEvent): void {
        const msg = this.state.messages[this.state.messages.length - 1];
        if (msg?.role === "assistant") {
            this.updateOrAddToolResult(msg, event.toolCallId, {
                type: "tool_result",
                toolCallId: event.toolCallId,
                output: event.result.output,
                isError: event.result.isError || false,
                isStreaming: false,
                isCollapsed: true,
            });
        }
        this.activeToolOutputs.delete(event.toolCallId);
    }

    private updateOrAddBlock(
        msg: ConversationMessage,
        type: "text" | "thinking",
        block: TextBlock | ThinkingBlock,
    ): void {
        // Find the last block of this type that's streaming
        const idx = msg.blocks.findLastIndex((b) => b.type === type && (b as TextBlock).isStreaming);
        if (idx >= 0) {
            msg.blocks[idx] = block;
        } else {
            msg.blocks.push(block);
        }
    }

    private updateOrAddToolCall(msg: ConversationMessage, id: string, block: ToolCallBlock): void {
        const idx = msg.blocks.findIndex((b) => b.type === "tool_call" && (b as ToolCallBlock).id === id);
        if (idx >= 0) {
            msg.blocks[idx] = block;
        } else {
            msg.blocks.push(block);
        }
    }

    private updateOrAddToolResult(msg: ConversationMessage, toolCallId: string, block: ToolResultBlock): void {
        const idx = msg.blocks.findIndex(
            (b) => b.type === "tool_result" && (b as ToolResultBlock).toolCallId === toolCallId,
        );
        if (idx >= 0) {
            msg.blocks[idx] = block;
        } else {
            // Insert after the corresponding tool_call
            const toolCallIdx = msg.blocks.findIndex(
                (b) => b.type === "tool_call" && (b as ToolCallBlock).id === toolCallId,
            );
            if (toolCallIdx >= 0) {
                msg.blocks.splice(toolCallIdx + 1, 0, block);
            } else {
                msg.blocks.push(block);
            }
        }
    }

    private finalizeCurrentMessage(): void {
        const last = this.state.messages[this.state.messages.length - 1];
        if (last?.role === "assistant") {
            last.isStreaming = false;
            for (const block of last.blocks) {
                if ("isStreaming" in block) {
                    block.isStreaming = false;
                }
            }
        }
        this.currentText = "";
        this.currentThinking = "";
        this.currentToolInput = "";
        this.currentToolId = "";
        this.currentToolName = "";
    }

    reset(): void {
        this.state = {
            messages: [],
            isAgentRunning: false,
            error: null,
        };
        this.currentText = "";
        this.currentThinking = "";
        this.currentToolInput = "";
        this.currentToolId = "";
        this.currentToolName = "";
        this.activeToolOutputs.clear();
    }

    serialize(): string {
        // Only serialize messages, not transient state
        return JSON.stringify({
            messages: this.state.messages,
        });
    }

    loadState(json: string): void {
        this.reset();
        try {
            const data = JSON.parse(json);
            if (Array.isArray(data.messages)) {
                this.state.messages = data.messages;
            }
        } catch {
            // Invalid JSON, keep reset state
        }
    }
}

```

src/lib/rpc/mockRpcClient.ts
```
import type { RpcClient, RpcEvent, RpcListener } from "$lib/rpc/types";

export interface MockRpcOptions {
    delayMs?: number;
}

export class MockRpcClient implements RpcClient {
    private listeners = new Set<RpcListener>();
    private timers: Array<ReturnType<typeof setTimeout>> = [];
    private events: RpcEvent[];
    private delayMs: number;

    public sentCommands: Record<string, unknown>[] = [];

    constructor(events: RpcEvent[], options: MockRpcOptions = {}) {
        this.events = events;
        this.delayMs = options.delayMs ?? 20;
    }

    static fromJsonl(jsonl: string, options: MockRpcOptions = {}) {
        const events = parseJsonl(jsonl);
        return new MockRpcClient(events, options);
    }

    async connect(_workingFolder?: string | null, _taskId?: string | null, _authProfile?: string | null) {
        this.startStreaming();
    }

    async disconnect() {
        this.stopStreaming();
    }

    async stopVm() {
        this.stopStreaming();
    }

    async send(command: Record<string, unknown>) {
        this.sentCommands.push(command);
    }

    subscribe(listener: RpcListener) {
        this.listeners.add(listener);
        return () => {
            this.listeners.delete(listener);
        };
    }

    private startStreaming() {
        this.stopStreaming();

        this.events.forEach((event, index) => {
            const timer = setTimeout(() => {
                this.emit(event);
            }, this.delayMs * index);
            this.timers.push(timer);
        });
    }

    private stopStreaming() {
        this.timers.forEach((timer) => clearTimeout(timer));
        this.timers = [];
    }

    private emit(event: RpcEvent) {
        this.listeners.forEach((listener) => listener(event));
    }
}

export function parseJsonl(jsonl: string) {
    return jsonl
        .split(/\r?\n/)
        .map((line) => line.trim())
        .filter(Boolean)
        .map((line) => JSON.parse(line) as RpcEvent);
}

```

src/lib/rpc/tauriRpcClient.ts
```
import { invoke } from "@tauri-apps/api/core";
import { listen } from "@tauri-apps/api/event";
import { devLog } from "$lib/utils/devLog";
import type { RpcClient, RpcEvent, RpcListener } from "$lib/rpc/types";

export class TauriRpcClient implements RpcClient {
    private unlisten: (() => void) | null = null;
    private listeners = new Set<RpcListener>();
    private connecting = false;

    async connect(workingFolder?: string | null, taskId?: string | null, authProfile?: string | null) {
        devLog(
            "RpcClient",
            `connect start, workingFolder: ${workingFolder ?? "none"}, taskId: ${taskId ?? "none"}, authProfile: ${
                authProfile ?? "default"
            }`,
        );
        if (this.unlisten || this.connecting) {
            devLog("RpcClient", "already connected or connecting");
            return;
        }
        this.connecting = true;

        try {
            devLog("RpcClient", "setting up event listener");
            const unlisten = await listen<{ event: string; message: string }>("vm_event", ({ payload }) => {
                devLog("RpcClient", `vm_event: ${payload.event}`);
                const event: RpcEvent = {
                    type: payload.event,
                    message: payload.message,
                };
                this.listeners.forEach((listener) => listener(event));
            });
            this.unlisten = unlisten;

            devLog("RpcClient", "calling vm_start");
            const result = await invoke<{ status: string }>("vm_start", {
                workingFolder: workingFolder ?? null,
                taskId: taskId ?? null,
                authProfile: authProfile ?? null,
            });
            devLog("RpcClient", `vm_start returned: ${JSON.stringify(result)}`);

            // If VM was already running and ready, emit a synthetic ready event
            if (result?.status === "ready") {
                devLog("RpcClient", "VM already ready, emitting ready event");
                const event: RpcEvent = { type: "ready", message: "" };
                this.listeners.forEach((listener) => listener(event));
            }
        } finally {
            this.connecting = false;
        }
    }

    async disconnect() {
        // Just detach the event listener - don't stop VM
        // VM persists across HMR, we just reconnect
        if (this.unlisten) {
            this.unlisten();
            this.unlisten = null;
        }
        this.connecting = false;
    }

    async stopVm() {
        // Actually stop the VM (for app close, not HMR)
        this.disconnect();
        await invoke("vm_stop");
    }

    async send(command: Record<string, unknown>) {
        await invoke("rpc_send", { message: JSON.stringify(command) });
    }

    subscribe(listener: RpcListener) {
        this.listeners.add(listener);
        return () => {
            this.listeners.delete(listener);
        };
    }
}

```

src/lib/rpc/types.ts
```
/**
 * RPC types for pi agent
 * See: https://github.com/anthropics/anthropic-tools/blob/main/docs/rpc.md
 */

// Client interface
export type RpcEvent = Record<string, unknown> & {
    type: string;
};

export type RpcListener = (event: RpcEvent) => void;

export interface RpcClient {
    connect(workingFolder?: string | null, taskId?: string | null, authProfile?: string | null): Promise<void>;
    disconnect(): Promise<void>;
    stopVm(): Promise<void>;
    send(command: Record<string, unknown>): Promise<void>;
    subscribe(listener: RpcListener): () => void;
}

// Assistant message delta types
export type AssistantMessageEventType =
    | "start"
    | "text_start"
    | "text_delta"
    | "text_end"
    | "thinking_start"
    | "thinking_delta"
    | "thinking_end"
    | "toolcall_start"
    | "toolcall_delta"
    | "toolcall_end"
    | "done"
    | "error";

export interface TextDeltaEvent {
    type: "text_delta";
    contentIndex: number;
    delta: string;
}

export interface TextStartEvent {
    type: "text_start";
    contentIndex: number;
}

export interface TextEndEvent {
    type: "text_end";
    contentIndex: number;
    content: string;
}

export interface ThinkingDeltaEvent {
    type: "thinking_delta";
    contentIndex: number;
    delta: string;
}

export interface ThinkingStartEvent {
    type: "thinking_start";
    contentIndex: number;
}

export interface ThinkingEndEvent {
    type: "thinking_end";
    contentIndex: number;
    content: string;
}

export interface ToolCallStartEvent {
    type: "toolcall_start";
    contentIndex: number;
    toolName: string;
    toolCallId: string;
}

export interface ToolCallDeltaEvent {
    type: "toolcall_delta";
    contentIndex: number;
    delta: string;
}

export interface ToolCallEndEvent {
    type: "toolcall_end";
    contentIndex: number;
    toolCall: ToolCall;
}

export interface DoneEvent {
    type: "done";
    reason: "stop" | "length" | "toolUse";
}

export interface ErrorEvent {
    type: "error";
    reason: "aborted" | "error";
    error?: string;
}

export type AssistantMessageEvent =
    | { type: "start" }
    | TextStartEvent
    | TextDeltaEvent
    | TextEndEvent
    | ThinkingStartEvent
    | ThinkingDeltaEvent
    | ThinkingEndEvent
    | ToolCallStartEvent
    | ToolCallDeltaEvent
    | ToolCallEndEvent
    | DoneEvent
    | ErrorEvent;

// Tool types
export interface ToolCall {
    id: string;
    name: string;
    input: Record<string, unknown>;
}

export interface ToolResult {
    toolCallId: string;
    output: string;
    isError?: boolean;
}

// Message types
export interface AgentMessage {
    role: "user" | "assistant";
    content: MessageContent[];
    model?: string;
}

export type MessageContent =
    | { type: "text"; text: string }
    | { type: "thinking"; text: string }
    | { type: "tool_use"; id: string; name: string; input: Record<string, unknown> }
    | { type: "tool_result"; tool_use_id: string; content: string; is_error?: boolean };

// RPC Events
export interface AgentStartEvent {
    type: "agent_start";
}

export interface AgentEndEvent {
    type: "agent_end";
    messages: AgentMessage[];
}

export interface TurnStartEvent {
    type: "turn_start";
}

export interface TurnEndEvent {
    type: "turn_end";
    message: AgentMessage;
    toolResults?: ToolResult[];
}

export interface MessageStartEvent {
    type: "message_start";
    message: AgentMessage;
}

export interface MessageUpdateEvent {
    type: "message_update";
    message?: AgentMessage;
    assistantMessageEvent: AssistantMessageEvent;
}

export interface MessageEndEvent {
    type: "message_end";
    message: AgentMessage;
}

export interface ToolExecutionStartEvent {
    type: "tool_execution_start";
    toolCallId: string;
    toolName: string;
}

export interface ToolExecutionUpdateEvent {
    type: "tool_execution_update";
    toolCallId: string;
    output: string;
}

export interface ToolExecutionEndEvent {
    type: "tool_execution_end";
    toolCallId: string;
    result: ToolResult;
}

export interface ResponseEvent {
    type: "response";
    command: string;
    success: boolean;
    data?: unknown;
    error?: string;
    id?: string;
}

export interface ExtensionUiRequestEvent {
    type: "extension_ui_request";
    id: string;
    method: string;
    title?: string;
    message?: string;
    options?: string[];
    placeholder?: string;
    prefill?: string;
}

export type RpcPayload =
    | AgentStartEvent
    | AgentEndEvent
    | TurnStartEvent
    | TurnEndEvent
    | MessageStartEvent
    | MessageUpdateEvent
    | MessageEndEvent
    | ToolExecutionStartEvent
    | ToolExecutionUpdateEvent
    | ToolExecutionEndEvent
    | ResponseEvent
    | ExtensionUiRequestEvent
    | { type: string; [key: string]: unknown };

```

src/lib/services/authProfile.ts
```
const AUTH_PROFILE_PATTERN = /^[A-Za-z0-9._-]+$/;

export function normalizeAuthProfile(value: string | null | undefined): string {
    const trimmed = value?.trim() ?? "";

    if (!trimmed) {
        return "default";
    }

    if (!AUTH_PROFILE_PATTERN.test(trimmed)) {
        return "default";
    }

    if (trimmed.includes("..")) {
        return "default";
    }

    return trimmed;
}

```

src/lib/services/runtimeService.ts
```
import { invoke } from "@tauri-apps/api/core";
import { TauriRpcClient } from "$lib/rpc";
import { devLog } from "$lib/utils/devLog";
import { normalizeAuthProfile } from "$lib/services/authProfile";
import type { RpcEvent } from "$lib/rpc";
import type { TaskMetadata } from "$lib/types/task";

const POLL_INTERVAL_MS = 100;
const TASK_SWITCH_TIMEOUT_MS = 5000;
const RPC_READY_TIMEOUT_MS = 6000;
const RPC_COMMAND_TIMEOUT_MS = 5000;
const AUTH_PROFILE_STORAGE_KEY = "piwork:auth-profile";

export interface RuntimeServiceSnapshot {
    rpcConnected: boolean;
    rpcConnecting: boolean;
    rpcError: string | null;
    currentTaskId: string | null;
    currentWorkingFolder: string | null;
    currentSessionFile: string | null;
    workspaceRoot: string | null;
    authProfile: string;
    taskSwitching: boolean;
}

interface VmStatusResponse {
    status: "starting" | "ready" | "stopped";
    rpcPath: string | null;
    logPath: string | null;
}

interface WorkingFolderValidation {
    folder: string;
    workspaceRoot: string;
    relativePath: string;
}

interface PendingRpcResponse {
    resolve: (payload: Record<string, unknown>) => void;
    reject: (error: Error) => void;
    timeout: ReturnType<typeof setTimeout>;
}

interface PendingTaskSwitch {
    taskId: string;
    resolve: () => void;
    reject: (error: Error) => void;
    timeout: ReturnType<typeof setTimeout>;
}

class TaskdError extends Error {
    code: string;
    retryable: boolean;

    constructor(code: string, message: string, retryable = false) {
        super(message);
        this.name = "TaskdError";
        this.code = code;
        this.retryable = retryable;
    }
}

interface RuntimeServiceCallbacks {
    onRpcPayload?: (payload: Record<string, unknown>) => void;
    onRawRpcMessage?: (message: string) => void;
    onConnected?: () => void;
    onError?: (message: string) => void;
    onStateRefreshRequested?: () => void;
}

interface TaskSwitchDeps {
    saveConversationForTask(taskId: string | null): Promise<void>;
    loadConversationForTask(taskId: string | null): Promise<void>;
}

interface FolderChangeDeps {
    persistWorkingFolderForActiveTask(folder: string | null): Promise<void>;
}

function isRecord(value: unknown): value is Record<string, unknown> {
    return Boolean(value) && typeof value === "object" && !Array.isArray(value);
}

function taskdSessionFileForTask(taskId: string): string {
    return `/sessions/${taskId}/session.json`;
}

function inferProviderFromModel(modelId: string | null | undefined): string | null {
    if (!modelId) {
        return null;
    }

    if (modelId.startsWith("claude")) {
        return "anthropic";
    }

    if (modelId.startsWith("gpt")) {
        return "openai-codex";
    }

    if (modelId.startsWith("gemini")) {
        return "google-gemini-cli";
    }

    return null;
}

export class RuntimeService {
    private callbacks: RuntimeServiceCallbacks;
    private snapshot: RuntimeServiceSnapshot;
    private listeners = new Set<(snapshot: RuntimeServiceSnapshot) => void>();
    private rpcClient: TauriRpcClient | null = null;
    private pendingRpcResponses = new Map<string, PendingRpcResponse>();
    private pendingTaskSwitch: PendingTaskSwitch | null = null;
    private lastTaskReadyAt = new Map<string, number>();
    private workspaceRootInitialized = false;
    private workspaceRootLocked = false;
    private vmWorkspaceRoot: string | null = null;

    constructor(callbacks: RuntimeServiceCallbacks = {}) {
        this.callbacks = callbacks;
        this.snapshot = {
            rpcConnected: false,
            rpcConnecting: false,
            rpcError: null,
            currentTaskId: null,
            currentWorkingFolder: null,
            currentSessionFile: null,
            workspaceRoot: null,
            authProfile: "default",
            taskSwitching: false,
        };
    }

    static async refreshVmLogPath(): Promise<string | null> {
        try {
            const status = await invoke<VmStatusResponse>("vm_status");
            return status.logPath;
        } catch {
            return null;
        }
    }

    subscribe(listener: (snapshot: RuntimeServiceSnapshot) => void) {
        this.listeners.add(listener);
        listener(this.snapshot);
        return () => {
            this.listeners.delete(listener);
        };
    }

    getSnapshot(): RuntimeServiceSnapshot {
        return this.snapshot;
    }

    getRpcClient(): TauriRpcClient | null {
        return this.rpcClient;
    }

    async send(command: Record<string, unknown>) {
        if (!this.rpcClient) {
            throw new Error("RPC client unavailable");
        }

        await this.rpcClient.send(command);
    }

    async sendPrompt(message: string) {
        const content = message.trim();
        if (!content) {
            throw new Error("Prompt message is empty");
        }

        await this.waitForRpcReady();
        const promptId = crypto.randomUUID();
        const result = await this.sendTaskdCommand(
            "prompt",
            {
                message: content,
                promptId,
            },
            RPC_COMMAND_TIMEOUT_MS,
        );

        if (result.accepted !== true) {
            throw new TaskdError("TASK_NOT_READY", "Prompt was not accepted", true);
        }
    }

    async connectRpc() {
        devLog("RuntimeService", "connectRpc start");
        if (this.rpcClient || this.snapshot.rpcConnecting) {
            return;
        }

        this.patch({ rpcConnecting: true, rpcError: null });

        const client = new TauriRpcClient();
        this.rpcClient = client;
        client.subscribe((event) => this.handleRpcEvent(event));

        try {
            devLog(
                "RuntimeService",
                `calling client.connect with folder: ${this.snapshot.currentWorkingFolder ?? "none"}, task: ${
                    this.snapshot.currentTaskId ?? "none"
                }`,
            );
            await this.connectRuntime(client);
            devLog("RuntimeService", "client.connect returned");
        } catch (error) {
            devLog("RuntimeService", `connectRpc error: ${error}`);
            const message = error instanceof Error ? error.message : String(error);
            this.patch({ rpcConnected: false, rpcError: message });
            this.clearPendingRpcResponses(message || "Failed to connect RPC");
            this.rpcClient = null;
            this.vmWorkspaceRoot = null;
            this.callbacks.onError?.(message);
            await client.disconnect().catch(() => undefined);
        } finally {
            devLog("RuntimeService", "connectRpc done");
            this.patch({ rpcConnecting: false });
        }
    }

    async disconnectRpc() {
        if (!this.rpcClient) {
            return;
        }

        await this.rpcClient.disconnect();
        this.clearPendingRpcResponses("RPC disconnected");
        this.rpcClient = null;
        this.vmWorkspaceRoot = null;
        this.patch({
            rpcConnected: false,
            rpcError: null,
        });
    }

    async waitForTaskSwitchComplete(timeoutMs = TASK_SWITCH_TIMEOUT_MS): Promise<void> {
        await this.waitForCondition(() => !this.snapshot.taskSwitching, timeoutMs, "Task switch still in progress");
    }

    async waitForRpcReady(timeoutMs = RPC_READY_TIMEOUT_MS): Promise<void> {
        await this.waitForCondition(() => this.snapshot.rpcConnected, timeoutMs, "RPC not ready");
    }

    async handleTaskSwitch(newTask: TaskMetadata | null, deps: TaskSwitchDeps): Promise<void> {
        await this.handleTaskSwitchRuntime(newTask, deps);
    }

    async handleFolderChange(folder: string | null, deps: FolderChangeDeps): Promise<void> {
        await this.handleFolderChangeRuntime(folder, deps);
    }

    private async connectRuntime(client: TauriRpcClient) {
        await this.ensureWorkspaceRootInitialized();
        const folderForConnect = this.snapshot.workspaceRoot ?? this.snapshot.currentWorkingFolder;

        const authProfile = this.getAuthProfileForVmStart();
        if (authProfile !== this.snapshot.authProfile) {
            this.patch({ authProfile });
        }

        await client.connect(folderForConnect, this.snapshot.currentTaskId, authProfile);
        this.vmWorkspaceRoot = folderForConnect ?? null;
    }

    private getAuthProfileForVmStart(): string {
        try {
            const stored = localStorage.getItem(AUTH_PROFILE_STORAGE_KEY);
            return normalizeAuthProfile(stored);
        } catch {
            // Ignore storage access issues and fall back to default profile.
        }

        return "default";
    }

    private async ensureWorkspaceRootInitialized() {
        if (this.workspaceRootInitialized) {
            return;
        }

        this.workspaceRootInitialized = true;

        try {
            const workspaceRoot = await invoke<string | null>("runtime_workspace_root");
            if (typeof workspaceRoot === "string" && workspaceRoot.trim().length > 0) {
                this.workspaceRootLocked = true;
                this.patch({ workspaceRoot });
            } else {
                this.workspaceRootLocked = false;
            }
        } catch (error) {
            this.workspaceRootLocked = false;
            devLog("RuntimeService", `Failed to resolve workspace root: ${error}`);
        }
    }

    private async restartVmWithWorkspaceRoot(): Promise<void> {
        const client = this.rpcClient;
        if (!client) {
            throw new Error("RPC client unavailable");
        }

        devLog(
            "RuntimeService",
            `Restarting VM to apply workspace root mount: ${this.snapshot.workspaceRoot ?? "(none)"}`,
        );

        this.clearPendingRpcResponses("VM restarting");
        this.patch({
            rpcConnected: false,
            rpcError: null,
        });

        await client.stopVm();
        this.vmWorkspaceRoot = null;
        await this.connectRuntime(client);
        await this.waitForRpcReady();
    }

    private async validateWorkingFolder(folder: string): Promise<WorkingFolderValidation> {
        const trimmed = folder.trim();
        if (!trimmed) {
            throw new Error("Working folder is required");
        }

        await this.ensureWorkspaceRootInitialized();

        const result = await invoke<WorkingFolderValidation>("runtime_validate_working_folder", {
            folder: trimmed,
            workspaceRoot: this.workspaceRootLocked ? this.snapshot.workspaceRoot : null,
        });

        const validatedFolder = typeof result?.folder === "string" ? result.folder : null;
        const workspaceRoot = typeof result?.workspaceRoot === "string" ? result.workspaceRoot : null;
        const relativePath = typeof result?.relativePath === "string" ? result.relativePath : null;

        if (!validatedFolder || !workspaceRoot || relativePath === null) {
            throw new Error("Invalid working folder validation response");
        }

        if (workspaceRoot !== this.snapshot.workspaceRoot) {
            this.patch({ workspaceRoot });
        }

        return {
            folder: validatedFolder,
            workspaceRoot,
            relativePath,
        };
    }

    private async handleTaskSwitchRuntime(newTask: TaskMetadata | null, deps: TaskSwitchDeps) {
        const newTaskId = newTask?.id ?? null;
        const oldTaskId = this.snapshot.currentTaskId;

        if (newTaskId === oldTaskId) {
            return;
        }

        devLog("RuntimeService", `Task switch: ${oldTaskId} -> ${newTaskId}`);
        this.patch({ taskSwitching: true, rpcError: null });

        try {
            await deps.saveConversationForTask(oldTaskId);
            await deps.loadConversationForTask(newTaskId);

            const nextFolder = newTask?.workingFolder ?? null;
            this.patch({
                currentTaskId: newTaskId,
                currentWorkingFolder: nextFolder,
                currentSessionFile: newTaskId ? taskdSessionFileForTask(newTaskId) : null,
            });

            if (!newTaskId || !newTask) {
                return;
            }

            await this.waitForRpcReady();

            const requiredWorkspaceRoot = this.snapshot.workspaceRoot;
            if (newTask.workingFolder && requiredWorkspaceRoot && this.vmWorkspaceRoot !== requiredWorkspaceRoot) {
                await this.restartVmWithWorkspaceRoot();
            }

            await this.ensureTaskdTaskReady(newTask);
            await this.switchTaskdTask(newTaskId);
            this.callbacks.onStateRefreshRequested?.();
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            this.patch({ rpcError: message });
            this.callbacks.onError?.(message);
            throw error;
        } finally {
            this.patch({ taskSwitching: false });
        }
    }

    private async handleFolderChangeRuntime(folder: string | null, deps: FolderChangeDeps) {
        const taskId = this.snapshot.currentTaskId;
        const previousFolder = this.snapshot.currentWorkingFolder;
        const hasBoundFolder = Boolean(taskId && previousFolder);

        if (hasBoundFolder) {
            const requestedFolder = typeof folder === "string" ? folder.trim() : "";
            if (!requestedFolder || requestedFolder !== previousFolder) {
                throw new Error("Working folder is locked for this task. Create a new task to use a different folder.");
            }
            return;
        }

        const requestedFolder = typeof folder === "string" ? folder.trim() : "";
        if (!requestedFolder) {
            if (!taskId) {
                this.patch({ currentWorkingFolder: null });
            }
            return;
        }

        if (!taskId) {
            const validated = await this.validateWorkingFolder(requestedFolder);
            this.patch({ currentWorkingFolder: validated.folder });
            devLog("RuntimeService", `Draft working folder set: ${validated.folder}`);
            return;
        }

        this.patch({ taskSwitching: true, rpcError: null });

        try {
            const validated = await this.validateWorkingFolder(requestedFolder);
            const nextFolder = validated.folder;
            const nextRelativePath = validated.relativePath;

            if (previousFolder === nextFolder) {
                return;
            }

            this.patch({ currentWorkingFolder: nextFolder });
            await deps.persistWorkingFolderForActiveTask(nextFolder);

            if (!this.snapshot.rpcConnected) {
                devLog(
                    "RuntimeService",
                    "Initial working folder set while runtime disconnected; apply deferred until task resume",
                );
                return;
            }

            devLog("RuntimeService", `Applying initial working folder for active task ${taskId}: ${nextFolder}`);
            await this.waitForRpcReady();

            const requiredWorkspaceRoot = this.snapshot.workspaceRoot;
            if (requiredWorkspaceRoot && this.vmWorkspaceRoot !== requiredWorkspaceRoot) {
                await this.restartVmWithWorkspaceRoot();
            }

            await this.stopTaskdTaskIfPresent(taskId);
            await this.sendTaskdCommand("create_or_open_task", {
                taskId,
                workingFolder: nextFolder,
                workingFolderRelative: nextRelativePath,
            });
            await this.switchTaskdTask(taskId);
            this.callbacks.onStateRefreshRequested?.();
        } catch (error) {
            const message = error instanceof Error ? error.message : String(error);
            this.patch({ rpcError: message });
            this.callbacks.onError?.(message);
            throw error;
        } finally {
            this.patch({ taskSwitching: false });
        }
    }

    private emitSnapshot() {
        for (const listener of this.listeners) {
            listener(this.snapshot);
        }
    }

    private patch(next: Partial<RuntimeServiceSnapshot>) {
        this.snapshot = { ...this.snapshot, ...next };
        this.emitSnapshot();
    }

    private markConnected() {
        if (this.snapshot.rpcConnected) {
            return;
        }

        this.patch({
            rpcConnected: true,
            rpcError: null,
        });
        this.callbacks.onConnected?.();
    }

    private handleRpcEvent(event: RpcEvent) {
        if (event.type === "ready") {
            this.markConnected();
            return;
        }

        if (event.type === "error") {
            const message = typeof event.message === "string" ? event.message : "Runtime error";
            this.patch({
                rpcError: message,
                rpcConnected: false,
            });
            this.clearPendingRpcResponses(message);
            this.callbacks.onError?.(message);
            return;
        }

        if (event.type === "rpc" && typeof event.message === "string") {
            this.markConnected();

            try {
                const parsed = JSON.parse(event.message) as Record<string, unknown>;
                this.resolvePendingRpcResponse(parsed);
                this.handleTaskdEvent(parsed);
                this.callbacks.onRpcPayload?.(parsed);
            } catch {
                this.callbacks.onRawRpcMessage?.(event.message);
            }
        }
    }

    private clearPendingRpcResponses(reason: string) {
        for (const [id, pending] of this.pendingRpcResponses) {
            clearTimeout(pending.timeout);
            pending.reject(new Error(reason));
            this.pendingRpcResponses.delete(id);
        }

        this.rejectPendingTaskSwitch(new Error(reason));
    }

    private resolvePendingRpcResponse(payload: Record<string, unknown>) {
        const responseId = typeof payload.id === "string" ? payload.id : null;
        if (!responseId) {
            return;
        }

        const isLegacyResponse = payload.type === "response";
        const isTaskdResponse = typeof payload.ok === "boolean";

        if (!isLegacyResponse && !isTaskdResponse) {
            return;
        }

        const pending = this.pendingRpcResponses.get(responseId);
        if (!pending) {
            return;
        }

        clearTimeout(pending.timeout);
        this.pendingRpcResponses.delete(responseId);
        pending.resolve(payload);
    }

    private async sendRpcCommandWithResponse(
        command: Record<string, unknown>,
        timeoutMs = RPC_COMMAND_TIMEOUT_MS,
    ): Promise<Record<string, unknown>> {
        if (!this.rpcClient) {
            throw new Error("RPC client unavailable");
        }

        const id = crypto.randomUUID();
        const client = this.rpcClient;

        return await new Promise<Record<string, unknown>>((resolve, reject) => {
            const timeout = setTimeout(() => {
                this.pendingRpcResponses.delete(id);
                reject(new Error(`RPC command timed out: ${String(command.type ?? "unknown")}`));
            }, timeoutMs);

            this.pendingRpcResponses.set(id, { resolve, reject, timeout });

            void client.send({ id, ...command }).catch((error) => {
                clearTimeout(timeout);
                this.pendingRpcResponses.delete(id);
                reject(error instanceof Error ? error : new Error(String(error)));
            });
        });
    }

    private rejectPendingTaskSwitch(error: Error) {
        if (!this.pendingTaskSwitch) {
            return;
        }

        const pending = this.pendingTaskSwitch;
        pending.reject(error);
    }

    private waitForTaskReadyEvent(taskId: string, startedAt: number, timeoutMs = TASK_SWITCH_TIMEOUT_MS) {
        const readyAt = this.lastTaskReadyAt.get(taskId);
        if (typeof readyAt === "number" && readyAt >= startedAt) {
            return Promise.resolve();
        }

        this.rejectPendingTaskSwitch(new TaskdError("SWITCH_TIMEOUT", "Task switch superseded", true));

        return new Promise<void>((resolve, reject) => {
            const pending: PendingTaskSwitch = {
                taskId,
                timeout: setTimeout(() => {
                    if (this.pendingTaskSwitch === pending) {
                        this.pendingTaskSwitch = null;
                    }
                    reject(new TaskdError("SWITCH_TIMEOUT", `Timed out waiting for task_ready (${taskId})`, true));
                }, timeoutMs),
                resolve: () => {
                    if (this.pendingTaskSwitch === pending) {
                        this.pendingTaskSwitch = null;
                    }
                    clearTimeout(pending.timeout);
                    resolve();
                },
                reject: (error: Error) => {
                    if (this.pendingTaskSwitch === pending) {
                        this.pendingTaskSwitch = null;
                    }
                    clearTimeout(pending.timeout);
                    reject(error);
                },
            };

            this.pendingTaskSwitch = pending;
        });
    }

    private handleTaskdEvent(payload: Record<string, unknown>) {
        if (payload.type !== "event") {
            return;
        }

        const eventName = typeof payload.event === "string" ? payload.event : null;
        const taskId = typeof payload.taskId === "string" ? payload.taskId : null;

        if (!eventName || !taskId) {
            return;
        }

        if (eventName === "task_ready") {
            this.lastTaskReadyAt.set(taskId, Date.now());
            if (this.pendingTaskSwitch?.taskId === taskId) {
                this.pendingTaskSwitch.resolve();
            }
            return;
        }

        if (eventName !== "task_error") {
            return;
        }

        if (this.pendingTaskSwitch?.taskId !== taskId) {
            return;
        }

        const errorPayload = isRecord(payload.payload) ? payload.payload : {};
        const code = typeof errorPayload.code === "string" ? errorPayload.code : "INTERNAL_ERROR";
        const message =
            typeof errorPayload.message === "string" ? errorPayload.message : `Task switch failed for ${taskId}`;
        const retryable = code === "TASK_NOT_READY" || code === "SWITCH_TIMEOUT";

        this.pendingTaskSwitch.reject(new TaskdError(code, message, retryable));
    }

    private async sendTaskdCommand(
        type: string,
        payload: Record<string, unknown>,
        timeoutMs = RPC_COMMAND_TIMEOUT_MS,
    ): Promise<Record<string, unknown>> {
        const response = await this.sendRpcCommandWithResponse(
            {
                type,
                payload,
            },
            timeoutMs,
        );

        if (!isRecord(response) || typeof response.ok !== "boolean") {
            throw new TaskdError("INTERNAL_ERROR", `Invalid taskd response for ${type}`);
        }

        if (!response.ok) {
            const errorPayload = isRecord(response.error) ? response.error : {};
            const code = typeof errorPayload.code === "string" ? errorPayload.code : "INTERNAL_ERROR";
            const message = typeof errorPayload.message === "string" ? errorPayload.message : `${type} failed`;
            const retryable = errorPayload.retryable === true;
            throw new TaskdError(code, message, retryable);
        }

        return isRecord(response.result) ? response.result : {};
    }

    private async buildCreateOrOpenTaskPayload(task: TaskMetadata): Promise<Record<string, unknown>> {
        const model = typeof task.model === "string" ? task.model : null;
        const provider = inferProviderFromModel(model);
        const thinkingLevel = typeof task.thinkingLevel === "string" ? task.thinkingLevel : null;
        const configuredWorkingFolder = typeof task.workingFolder === "string" ? task.workingFolder : null;

        let workingFolder: string | null = null;
        let workingFolderRelative: string | null = null;

        if (configuredWorkingFolder) {
            const validated = await this.validateWorkingFolder(configuredWorkingFolder);
            workingFolder = validated.folder;
            workingFolderRelative = validated.relativePath;
        }

        const payload: Record<string, unknown> = {
            taskId: task.id,
            workingFolder,
            workingFolderRelative,
        };

        if (provider) {
            payload.provider = provider;
        }
        if (model) {
            payload.model = model;
        }
        if (thinkingLevel) {
            payload.thinkingLevel = thinkingLevel;
        }

        return payload;
    }

    private async stopTaskdTaskIfPresent(taskId: string) {
        try {
            await this.sendTaskdCommand("stop_task", { taskId });
        } catch (error) {
            if (error instanceof TaskdError && error.code === "TASK_NOT_FOUND") {
                return;
            }

            throw error;
        }
    }

    private async ensureTaskdTaskReady(task: TaskMetadata) {
        const payload = await this.buildCreateOrOpenTaskPayload(task);
        const desiredWorkingFolderRelative =
            typeof payload.workingFolderRelative === "string" ? payload.workingFolderRelative : null;

        const stateResult = await this.sendTaskdCommand("get_state", {});
        const taskEntries = Array.isArray(stateResult.tasks) ? stateResult.tasks : [];
        const existing = taskEntries.find((entry) => {
            if (!isRecord(entry)) {
                return false;
            }

            return entry.taskId === task.id;
        });

        const existingState = isRecord(existing) && typeof existing.state === "string" ? existing.state : null;
        const existingWorkingFolderRelative =
            isRecord(existing) && typeof existing.workingFolderRelative === "string"
                ? existing.workingFolderRelative
                : null;

        if (existingState && ["ready", "idle", "active"].includes(existingState)) {
            if (existingWorkingFolderRelative === desiredWorkingFolderRelative) {
                return;
            }

            devLog(
                "RuntimeService",
                `Task ${task.id} working folder changed (${existingWorkingFolderRelative ?? "(scratch)"} -> ${
                    desiredWorkingFolderRelative ?? "(scratch)"
                }); restarting task process`,
            );

            await this.stopTaskdTaskIfPresent(task.id);
            await this.sendTaskdCommand("create_or_open_task", payload);
            return;
        }

        if (existingState && !["missing", "stopped", "errored"].includes(existingState)) {
            throw new TaskdError("TASK_NOT_READY", `task ${task.id} is ${existingState}`, true);
        }

        await this.sendTaskdCommand("create_or_open_task", payload);
    }

    private async switchTaskdTask(taskId: string) {
        const switchStartedAt = Date.now();
        const waitForReady = this.waitForTaskReadyEvent(taskId, switchStartedAt, TASK_SWITCH_TIMEOUT_MS);

        let switchAck: Record<string, unknown>;
        try {
            switchAck = await this.sendTaskdCommand("switch_task", { taskId });
        } catch (error) {
            this.rejectPendingTaskSwitch(error instanceof Error ? error : new Error(String(error)));
            await waitForReady.catch(() => undefined);
            throw error;
        }

        const status = typeof switchAck.status === "string" ? switchAck.status : null;
        if (status !== "switching") {
            const invalidAckError = new TaskdError("INTERNAL_ERROR", "switch_task returned invalid status");
            this.rejectPendingTaskSwitch(invalidAckError);
            await waitForReady.catch(() => undefined);
            throw invalidAckError;
        }

        await waitForReady;
    }

    private async waitForCondition(condition: () => boolean, timeoutMs: number, timeoutMessage: string): Promise<void> {
        if (condition()) {
            return;
        }

        const startedAt = Date.now();
        await new Promise<void>((resolve, reject) => {
            const timer = setInterval(() => {
                if (condition()) {
                    clearInterval(timer);
                    resolve();
                    return;
                }

                if (Date.now() - startedAt > timeoutMs) {
                    clearInterval(timer);
                    reject(new Error(timeoutMessage));
                }
            }, POLL_INTERVAL_MS);
        });
    }
}

```

src/lib/stores/artifactRefreshStore.ts
```
import { writable } from "svelte/store";

export interface ArtifactRefreshEvent {
    taskId: string | null;
    reason: string;
    token: number;
}

const state = writable<ArtifactRefreshEvent>({
    taskId: null,
    reason: "init",
    token: 0,
});

function request(taskId: string | null, reason: string) {
    state.update((current) => ({
        taskId,
        reason,
        token: current.token + 1,
    }));
}

export const artifactRefreshStore = {
    subscribe: state.subscribe,
    request,
};

```

src/lib/stores/previewStore.ts
```
import { writable } from "svelte/store";

export type PreviewSource = "preview" | "artifact";
export type ArtifactSource = "outputs" | "uploads";

export interface PreviewSelection {
    isOpen: boolean;
    taskId: string | null;
    relativePath: string | null;
    requestId: number;
    source: PreviewSource;
    artifactSource: ArtifactSource | null;
}

interface OpenPreviewOptions {
    source?: PreviewSource;
    artifactSource?: ArtifactSource | null;
}

const state = writable<PreviewSelection>({
    isOpen: false,
    taskId: null,
    relativePath: null,
    requestId: 0,
    source: "preview",
    artifactSource: null,
});

let requestCounter = 0;

function open(taskId: string, relativePath: string, options: OpenPreviewOptions = {}) {
    requestCounter += 1;

    const source = options.source ?? "preview";
    const artifactSource = source === "artifact" ? (options.artifactSource ?? "outputs") : null;

    state.set({
        isOpen: true,
        taskId,
        relativePath,
        requestId: requestCounter,
        source,
        artifactSource,
    });
}

function close() {
    requestCounter += 1;
    state.set({
        isOpen: false,
        taskId: null,
        relativePath: null,
        requestId: requestCounter,
        source: "preview",
        artifactSource: null,
    });
}

export const previewStore = {
    subscribe: state.subscribe,
    open,
    close,
};

```

src/lib/stores/taskStore.ts
```
import { derived, get, writable } from "svelte/store";
import { invoke } from "@tauri-apps/api/core";
import type { TaskMetadata } from "$lib/types/task";

const tasks = writable<TaskMetadata[]>([]);
const activeTaskId = writable<string | null>(null);
const activeTask = derived([tasks, activeTaskId], ([list, id]) => list.find((task) => task.id === id) ?? null);

const SESSION_FILE = "/mnt/taskstate/session.json";

// Recent folders (persisted to localStorage)
const RECENT_FOLDERS_KEY = "piwork_recent_folders";
const MAX_RECENT_FOLDERS = 10;
const recentFolders = writable<string[]>(loadRecentFolders());

function loadRecentFolders(): string[] {
    try {
        const stored = localStorage.getItem(RECENT_FOLDERS_KEY);
        return stored ? JSON.parse(stored) : [];
    } catch {
        return [];
    }
}

function saveRecentFolders(folders: string[]) {
    try {
        localStorage.setItem(RECENT_FOLDERS_KEY, JSON.stringify(folders));
    } catch {
        // Ignore storage errors
    }
}

function addRecentFolder(folder: string) {
    recentFolders.update((current) => {
        const filtered = current.filter((f) => f !== folder);
        const updated = [folder, ...filtered].slice(0, MAX_RECENT_FOLDERS);
        saveRecentFolders(updated);
        return updated;
    });
}

function normalizeTask(task: TaskMetadata): TaskMetadata {
    return {
        ...task,
        sessionFile: SESSION_FILE,
    };
}

async function loadTasks() {
    const list = await invoke<TaskMetadata[]>("task_store_list");
    const normalized = list.map(normalizeTask);
    tasks.set(normalized);
    ensureActiveTask(normalized);
}

async function upsertTask(task: TaskMetadata) {
    const normalized = normalizeTask(task);
    await invoke("task_store_upsert", { task: normalized });
    let next: TaskMetadata[] = [];
    tasks.update((current) => {
        next = current.filter((item) => item.id !== normalized.id);
        next.unshift(normalized);
        return next;
    });
    ensureActiveTask(next);
}

async function deleteTask(id: string) {
    await invoke("task_store_delete", { taskId: id });
    let next: TaskMetadata[] = [];
    tasks.update((current) => {
        next = current.filter((item) => item.id !== id);
        return next;
    });
    ensureActiveTask(next);
}

async function deleteAllTasks() {
    await invoke("task_store_delete_all");
    tasks.set([]);
    activeTaskId.set(null);
}

function createTask(title: string, workingFolder: string | null = null) {
    const now = new Date().toISOString();
    const id = crypto.randomUUID();
    const task: TaskMetadata = {
        id,
        title,
        status: "idle",
        createdAt: now,
        updatedAt: now,
        sessionFile: SESSION_FILE,
        workingFolder,
        mounts: [],
        model: null,
        thinkingLevel: null,
        connectorsEnabled: [],
    };

    // Track folder in recent list
    if (workingFolder) {
        addRecentFolder(workingFolder);
    }

    return task;
}

function isSelectable(task: TaskMetadata) {
    return task.status !== "archived";
}

function ensureActiveTask(list: TaskMetadata[]) {
    const currentId = get(activeTaskId);
    if (!currentId) {
        return;
    }

    const currentTask = list.find((task) => task.id === currentId);
    if (currentTask && isSelectable(currentTask)) {
        return;
    }

    activeTaskId.set(null);
}

function setActiveTask(id: string | null) {
    if (!id) {
        activeTaskId.set(null);
        return;
    }

    const list = get(tasks);
    const task = list.find((item) => item.id === id);

    if (!task || !isSelectable(task)) {
        return;
    }

    activeTaskId.set(id);
}

async function saveConversation(taskId: string, conversationJson: string): Promise<void> {
    await invoke("task_store_save_conversation", {
        taskId,
        conversationJson,
    });
}

async function loadConversation(taskId: string): Promise<string | null> {
    return await invoke<string | null>("task_store_load_conversation", {
        taskId,
    });
}

export const taskStore = {
    subscribe: tasks.subscribe,
    activeTaskId: { subscribe: activeTaskId.subscribe },
    activeTask: { subscribe: activeTask.subscribe },
    recentFolders: { subscribe: recentFolders.subscribe },
    load: loadTasks,
    upsert: upsertTask,
    delete: deleteTask,
    deleteAll: deleteAllTasks,
    create: createTask,
    setActive: setActiveTask,
    saveConversation,
    loadConversation,
    addRecentFolder,
};

```

src/lib/theme.ts
```
/**
 * System appearance detection and theme application.
 * Adds/removes `.dark` class on <html> based on system preference.
 */

export function initTheme() {
    const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");

    function apply(dark: boolean) {
        document.documentElement.classList.toggle("dark", dark);
    }

    // Apply on init
    apply(mediaQuery.matches);

    // Listen for changes
    mediaQuery.addEventListener("change", (e) => apply(e.matches));
}

```

src/lib/types/task.ts
```
export interface TaskMount {
    path: string;
    mode: "read" | "write";
}

export interface TaskMetadata {
    id: string;
    title: string;
    status: string;
    createdAt: string;
    updatedAt: string;
    sessionFile?: string | null;
    workingFolder?: string | null;
    mounts?: TaskMount[]; // deprecated, use workingFolder
    model?: string | null;
    thinkingLevel?: string | null;
    connectorsEnabled?: string[];
}

```

src/lib/utils.ts
```
import { clsx, type ClassValue } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
    return twMerge(clsx(inputs));
}

// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type WithoutChild<T> = T extends { child?: any } ? Omit<T, "child"> : T;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export type WithoutChildren<T> = T extends { children?: any } ? Omit<T, "children"> : T;
export type WithoutChildrenOrChild<T> = WithoutChildren<WithoutChild<T>>;
export type WithElementRef<T, U extends HTMLElement = HTMLElement> = T & {
    ref?: U | null;
};

```

src/lib/utils/devLog.ts
```
import { invoke } from "@tauri-apps/api/core";

/**
 * Log to terminal via Tauri backend (visible in `mise run tauri-dev` output).
 * Falls back to console.log if Tauri isn't available.
 */
export function devLog(source: string, message: string) {
    // Also log to browser console for DevTools
    console.log(`[${source}] ${message}`);

    // Send to Rust backend to print to stderr
    invoke("dev_log", { source, message }).catch(() => {
        // Ignore errors (e.g., if not running in Tauri)
    });
}

```

src/lib/utils/notice.svelte.ts
```
/**
 * Creates a notice state manager with auto-clear timer.
 * Use in Svelte 5 components.
 */
export function createNotice(duration = 3000) {
    let value = $state<string | null>(null);
    let timer: ReturnType<typeof setTimeout> | null = null;

    function set(message: string) {
        value = message;
        if (timer) clearTimeout(timer);
        timer = setTimeout(() => {
            value = null;
        }, duration);
    }

    function clear() {
        value = null;
        if (timer) {
            clearTimeout(timer);
            timer = null;
        }
    }

    function cleanup() {
        if (timer) clearTimeout(timer);
    }

    return {
        get value() {
            return value;
        },
        set,
        clear,
        cleanup,
    };
}

```

src/routes/+layout.svelte
```
<script lang="ts">
import "../app.css";
import { onMount } from "svelte";
import { initTheme } from "$lib/theme";

onMount(() => {
    initTheme();
});
</script>

<slot></slot>

```

src/routes/+layout.ts
```
// Tauri doesn't have a Node.js server to do proper SSR
// so we use adapter-static with a fallback to index.html to put the site in SPA mode
// See: https://svelte.dev/docs/kit/single-page-apps
// See: https://v2.tauri.app/start/frontend/sveltekit/ for more info
export const ssr = false;

```

src/routes/+page.svelte
```
<script lang="ts">
import AppShell from "$lib/components/layout/AppShell.svelte";
</script>

<AppShell />

```

src/vitest.d.ts
```
/// <reference types="vitest/globals" />

```

svelte.config.js
```
// Tauri doesn't have a Node.js server to do proper SSR
// so we use adapter-static with a fallback to index.html to put the site in SPA mode
// See: https://svelte.dev/docs/kit/single-page-apps
// See: https://v2.tauri.app/start/frontend/sveltekit/ for more info
import adapter from "@sveltejs/adapter-static";
import { vitePreprocess } from "@sveltejs/vite-plugin-svelte";

/** @type {import('@sveltejs/kit').Config} */
const config = {
    preprocess: vitePreprocess(),
    kit: {
        adapter: adapter({
            fallback: "index.html",
        }),
    },
};

export default config;

```

tailwind.config.ts
```
import type { Config } from "tailwindcss";

export default {
    content: ["./src/**/*.{html,js,svelte,ts}"],
    theme: {
        extend: {},
    },
    plugins: [],
} as Config;

```

tsconfig.json
```
{
    "extends": "./.svelte-kit/tsconfig.json",
    "compilerOptions": {
        "allowJs": true,
        "checkJs": true,
        "esModuleInterop": true,
        "forceConsistentCasingInFileNames": true,
        "resolveJsonModule": true,
        "skipLibCheck": true,
        "sourceMap": true,
        "strict": true,
        "moduleResolution": "bundler"
    }
    // Path aliases are handled by https://svelte.dev/docs/kit/configuration#alias
    // except $lib which is handled by https://svelte.dev/docs/kit/configuration#files
    //
    // If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
    // from the referenced tsconfig.json - TypeScript does not merge them in
}

```

vite.config.js
```
import { defineConfig } from "vite";
import { sveltekit } from "@sveltejs/kit/vite";
import tailwindcss from "@tailwindcss/vite";

// @ts-expect-error process is a nodejs global
const host = process.env.TAURI_DEV_HOST;

// https://vite.dev/config/
export default defineConfig(async () => ({
    plugins: [tailwindcss(), sveltekit()],

    // Vite options tailored for Tauri development and only applied in `tauri dev` or `tauri build`
    //
    // 1. prevent Vite from obscuring rust errors
    clearScreen: false,
    // 2. tauri expects a fixed port, fail if that port is not available
    server: {
        port: 1420,
        strictPort: true,
        host: host || false,
        hmr: host
            ? {
                  protocol: "ws",
                  host,
                  port: 1421,
              }
            : undefined,
        watch: {
            // 3. tell Vite to ignore watching `src-tauri`
            ignored: ["**/src-tauri/**"],
        },
    },

    test: {
        environment: "jsdom",
        globals: true,
        setupFiles: ["src/lib/__tests__/setup.ts"],
    },
}));

```

